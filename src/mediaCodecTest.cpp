#include <gmock/gmock.h>
#include <gtest/gtest.h>

#include "hb_media_codec.h"
#include "hb_media_error.h"
#include "include/common.h"
#ifdef __cplusplus
extern "C" {
#endif				/* __cplusplus */
#include <libavformat/avformat.h>
#include <libavutil/timestamp.h>
#ifdef __cplusplus
}
#endif				/* __cplusplus */

#include <time.h>
#include <unistd.h>
#include <sys/syscall.h>
#define gettid() syscall(SYS_gettid)

#define TAG "[MediaCodecTest]"

#define DYNAMIC_START_NUM 120
#define SET_BYTE(_p, _b) \
    *_p++ = (unsigned char)_b;

#define SET_BUFFER(_p, _buf, _len) \
    memcpy(_p, _buf, _len); \
    (_p) += (_len);

using namespace ::testing;

namespace mediaCodec {
namespace test {
typedef enum ENC_CONFIG_MESSAGE {
    ENC_CONFIG_NONE = (0 << 0),
    ENC_CONFIG_LONGTERM_REF = (1 << 0),
    ENC_CONFIG_INTRA_REFRESH = (1 << 1),
    ENC_CONFIG_RATE_CONTROL = (1 << 2),
    ENC_CONFIG_DEBLK_FILTER = (1 << 3),
    ENC_CONFIG_SAO = (1 << 4),
    ENC_CONFIG_ENTROPY = (1 << 5),
    ENC_CONFIG_VUI_TIMING = (1 << 6),
    ENC_CONFIG_SLICE = (1 << 7),
    ENC_CONFIG_REQUEST_IDR = (1 << 8),
    ENC_CONFIG_SKIP_PIC = (1 << 9),
    ENC_CONFIG_SMART_BG = (1 << 10),
    ENC_CONFIG_MONOCHROMA = (1 << 11),
    ENC_CONFIG_PRED_UNIT = (1 << 12),
    ENC_CONFIG_TRANSFORM = (1 << 13),
    ENC_CONFIG_ROI = (1 << 14),
    ENC_CONFIG_MODE_DECISION = (1 << 15),
    ENC_CONFIG_USER_DATA = (1 << 16),
    ENC_CONFIG_MJPEG = (1 << 17),
    ENC_CONFIG_JPEG = (1 << 18),
    ENC_CONFIG_CAMERA = (1 << 19),
    ENC_CONFIG_INSERT_USERDATA = (1 << 20),
    ENC_CONFIG_VUI = (1 << 21),
    ENC_CONFIG_3DNR = (1 << 22),
    ENC_CONFIG_REQUEST_IDR_HEADER = (1 << 23),
    ENC_CONFIG_ENABLE_IDR = (1 << 24),
    ENC_CONFIG_ENABLE_EXP_HEADER = (1 << 25),
    ENC_CONFIG_ROI_AVG_QP = (1 << 26),
    ENC_CONFIG_ROI_EX = (1 << 27),
    ENC_CONFIG_TRANS_BITRATE = (1 << 28),
    ENC_CONFIG_TOTAL = (1 << 29),
} ENC_CONFIG_MESSAGE;

typedef struct MediaCodecTestContext {
    media_codec_context_t *context;
    // resource
    FILE *inFile;
    FILE *outFile;
    FILE *inMd5File;
    int ionFd;
    char *inputFileName;
    char *outputFileName;
    char *inputMd5FileName;
    ExternalFrameBuffer *exFb;
    ExternalStreamBuffer *exBs;
    int abnormal;
    int workMode;

    // encode parameters
    ENC_CONFIG_MESSAGE message;
    mc_video_longterm_ref_mode_t ref_mode;
    mc_rate_control_params_t rc_params;
    hb_u32 max_bitrate;
    mc_video_intra_refresh_params_t intra_refr;
    mc_video_deblk_filter_params_t deblk_filter;
    mc_h265_sao_params_t sao;
    mc_h264_entropy_params_t entropy;
    mc_video_vui_params_t vui;
    mc_video_vui_timing_params_t vui_timing;
    mc_video_slice_params_t slice;
    mc_video_3dnr_enc_params_t noise_reduction;
    mc_video_smart_bg_enc_params_t smart_bg;
    mc_video_pred_unit_params_t pred_unit;
    mc_video_transform_params_t transform;
    mc_video_roi_params_t roi;
    hb_u32 roi_avg_qp;
    mc_video_roi_params_ex_t roiEx;
    mc_video_mode_decision_params_t mode_decision;
    uint32_t force_idr_header_num;
    uint32_t force_idr_header;
    int enable_idr_num;
    int req_idr_num;
    int skip_pic_num;
    int insert_userData_num;
    int enable_explicit_header;
    int qpmap_enable;
    hb_byte qpmap_array;
    hb_u32 qpmap_count;

    // for dynamic parameters
    ENC_CONFIG_MESSAGE dynamicMessage;
    mc_video_longterm_ref_mode_t ref_mode_dynamic;
    mc_rate_control_params_t rc_params_dynamic;
    hb_u32 max_bitrate_dynamic;
    mc_video_deblk_filter_params_t deblk_filter_dynamic;
    mc_h265_sao_params_t sao_dynamic;
    mc_h264_entropy_params_t entropy_dynamic;
    mc_video_vui_params_t vui_dynamic;
    mc_video_vui_timing_params_t vui_timing_dynamic;
    mc_video_slice_params_t slice_dynamic;
    mc_video_3dnr_enc_params_t noise_reduction_dynamic;
    mc_video_smart_bg_enc_params_t smart_bg_dynamic;
    mc_video_pred_unit_params_t pred_unit_dynamic;
    mc_video_transform_params_t transform_dynamic;
    mc_video_roi_params_t roi_dynamic;
    hb_u32 roi_avg_qp_dynamic;
    mc_video_roi_params_ex_t roiEx_dynamic;
    mc_video_mode_decision_params_t mode_decision_dynamic;
    uint32_t force_idr_header_num_dynamic;
    uint32_t force_idr_header_dynamic;
    int enable_idr_num_dynamic;
    int enable_explicit_header_dynamic;
    int qpmap_enable_dynamic;
    hb_byte qpmap_array_dynamic;
    hb_u32 qpmap_count_dynamic;

    // decode parameters
    int enable_get_userdata;
    uint32_t feedingSize;

    // test parameters
    int md5Test;
    int pfTest;
    int stabilityTest;
    int stabilityParaTest;
    int targetFps;
    int testLog;
    int testAbnormalQuit;
    int32_t duration; // s
    int vlc_buf_size;
    int pollEncFd;
    int pollDecFd;
    Uint64 testStartTime;
    int input_num;
    int32_t delaytest;
    int32_t delaytime; //ms
    int bitfullTest;
    int dynamicTest;
    Uint64 frametime;
    int32_t readonce;

    // async parameters
    AVFormatContext* avContext; //decoder
    AVPacket avpacket; //decoder
    int videoIndex; //decoder
    int firstPacket; //decoder
    int lastStream; // encoder and decoder
    int lastFrame; // encoder
} MediaCodecTestContext;

class MediaCodecTest:public testing::Test {
protected:
static void SetUpTestCase() {
    std::cout<<"Setup MediaCodecTest test case"<<std::endl;
}

static void TearDownTestCase() {
    std::cout<<"Tear down MediaCodecTest test case"<<std::endl;
}

virtual void SetUp() {
    mOutputPrefix = G_OUTPUT_PREFIX;
    mInputPrefix = G_VIDEO_INPUT_PREFIX;
    mOutputSpecPrefix = G_VIDEO_OUTPUT_SPEC_PREFIX;
    mInputSpecPrefix = G_VIDEO_INPUT_SPEC_PREFIX;
    mTestWidth = mGlobalUserWidth;
    mTestHeight = mGlobalUserHeight;
    if(mGlobalUserPixFmt >= MC_PIXEL_FORMAT_YUV420P &&
        mGlobalUserPixFmt <= MC_PIXEL_FORMAT_NV21) {
        mTestPixFmt = (mc_pixel_format_t)mGlobalUserPixFmt;
    } else {
        printf("%s Invalid pixel format %d. Using default 0.\n", TAG,
            mGlobalUserPixFmt);
        mTestPixFmt = MC_PIXEL_FORMAT_YUV420P;
    }
    if(mGlobalBitrate >= 0 &&
        mGlobalBitrate <= 700000) {
        mTargetBitrate = mGlobalBitrate;
    } else {
        printf("%s Invalid bitrate %f. Using default 5000.\n", TAG,
            mGlobalBitrate);
        mTargetBitrate = 5000;
    }
    mTestPF = mGlobalPF;
    mTargetFPS = 60;
    if (mGlobalCodecId == TEST_CODEC_ID_H265 ||
        mGlobalCodecId == TEST_CODEC_ID_H264) {
        mTestCodec = mGlobalCodecId;
    } else {
        printf("%s Invalid codec id %d. Using default %d.\n", TAG,
            mGlobalCodecId, TEST_CODEC_ID_H265);
        mTestCodec = TEST_CODEC_ID_H265;
    }
    mTestLog = mGlobalLog;
    mTestTime = mGlobalTestTime;
    if (mGlobalThreadNum > 0 && mGlobalThreadNum <= MAX_VPU_INSTANCE) {
        mTestThreadNum = mGlobalThreadNum;
        printf("%s Thread number %d.\n", TAG, mGlobalThreadNum);
    } else {
        printf("%s Invalid thread number %d. Using default 1.\n", TAG,
            mGlobalThreadNum);
        mTestThreadNum = 1;
    }
    mTestMd5 = mGlobalMd5;
    mTestWorkMode = mGlobalWorkMode;
    if (mTestWorkMode != THREAD_WORK_MODE_POLL &&
        mTestWorkMode != THREAD_WORK_MODE_ASYNC &&
        mTestWorkMode != THREAD_WORK_MODE_SYNC) {
        printf("%s Invalid work mode %d. Using default %d.\n", TAG,
            mTestWorkMode, THREAD_WORK_MODE_POLL);
        mTestWorkMode = THREAD_WORK_MODE_POLL;
    }
    mTestFeedMode = (mc_av_stream_feeding_mode_t)mGlobalFeedMode;
    if (mTestFeedMode != MC_FEEDING_MODE_FRAME_SIZE &&
        mTestFeedMode != MC_FEEDING_MODE_STREAM_SIZE) {
        printf("%s Invalid work mode %d. Using default %d.\n", TAG,
            mTestFeedMode, MC_FEEDING_MODE_FRAME_SIZE);
        mTestFeedMode = MC_FEEDING_MODE_FRAME_SIZE;
    }
    mTestBufMode = mGlobalBufMode;
    if (mTestBufMode != THREAD_BUF_MODE_INTERNAL &&
        mTestBufMode != THREAD_BUF_MODE_EXTERNAL) {
        printf("%s Invalid buf mode %d. Using default %d.\n", TAG,
            mTestBufMode, THREAD_BUF_MODE_INTERNAL);
        mTestBufMode = THREAD_BUF_MODE_INTERNAL;
    }
    mTestRCMode = mGlobalRCMode;
#ifdef J5
    if (mTestRCMode <= MC_AV_RC_MODE_H264QPMAP ||
        mTestRCMode >= MC_AV_RC_MODE_TOTAL)
#else
    if (mTestRCMode <= MC_AV_RC_MODE_NONE ||
        mTestRCMode >= MC_AV_RC_MODE_TOTAL)
#endif
    {
        printf("%s Invalid buf mode %d. Using default %d.\n", TAG,
            mTestRCMode, MC_AV_RC_MODE_H265CBR);
        mTestRCMode = MC_AV_RC_MODE_H265CBR;
    }
    mTestDelay = mGlobalDelay;
    mTestDelayTime = mGlobalDelayTime;
    mTestFrameRate = mGlobalFrameRate;
    mTestReadOnce = mGlobalReadOnce;
    mTestGopIdx = mGlobalGopPresetIdx;
}

virtual void TearDown()
{
}

public:
    uint32_t mCoreIdx;
    const char *mOutputPrefix;
    const char *mInputPrefix;
    const char *mOutputSpecPrefix;
    const char *mInputSpecPrefix;
    int32_t mTestWidth;
    int32_t mTestHeight;
    mc_pixel_format_t mTestPixFmt;
    float mTargetBitrate;
    uint32_t mTestPF;
    uint32_t mTargetFPS;
    int32_t mTestCodec;
    int32_t mTestLog;
    int32_t mTestTime;
    int32_t mTestThreadNum;
    int32_t mTestMd5;
    int32_t mTestWorkMode;
    int32_t mTestBufMode;
    int32_t mTestRCMode;
    mc_av_stream_feeding_mode_t mTestFeedMode;
    int32_t mTestDelay;
    int32_t mTestDelayTime;
    int32_t mTestFrameRate;
    int32_t mTestReadOnce;
    int32_t mTestGopIdx;
};

uint8_t uuid[] =
    "dc45e9bd-e6d948b7-962cd820-d923eeef+HorizonAI";
uint8_t uuid2[] =
    "dc45e9bd-e6d948b7-962cd820-d923eeef+HorizonAI2";
uint8_t uuid3[] =
    "dc45e9bd-e6d948b7-962cd820-d923eeef+HorizonAI3";
uint8_t uuid4[] =
    "dc45e9bd-e6d948b7-962cd820-d923eeef+HorizonAI4";
uint8_t uuid5[] =
    "dc45e9bd-e6d948b7-962cd820-d923eeef+HorizonAI5";

static float get_system_time_ms(void) {
    uint64_t sys_us;
    struct timeval currtime;

    gettimeofday(&currtime, NULL);
    sys_us = currtime.tv_sec * 1000000 + currtime.tv_usec;

    return sys_us/1000.0;
}

static void set_message(MediaCodecTestContext *ctx) {
    ASSERT_NE(ctx, nullptr);
    media_codec_context_t *context = ctx->context;
    ASSERT_NE(context, nullptr);
    if (ctx->testLog)
        printf("%s set message %d\n", TAG, ctx->message);
    if (ctx->message & ENC_CONFIG_LONGTERM_REF) {
        ASSERT_EQ(hb_mm_mc_set_longterm_ref_mode(context, &ctx->ref_mode),
            (int32_t)0);
    }

    if (ctx->message & ENC_CONFIG_INTRA_REFRESH) {
        ASSERT_EQ(hb_mm_mc_set_intra_refresh_config(context, &ctx->intra_refr),
            (int32_t)0);
    }

    if (ctx->message & ENC_CONFIG_DEBLK_FILTER) {
        ASSERT_EQ(hb_mm_mc_set_deblk_filter_config(context, &ctx->deblk_filter),
            (int32_t)0);
    }

    if (ctx->message & ENC_CONFIG_SAO) {
        ASSERT_EQ(hb_mm_mc_set_sao_config(context, &ctx->sao),
            (int32_t)0);
    }

    if (ctx->message & ENC_CONFIG_ENTROPY) {
        ASSERT_EQ(hb_mm_mc_set_entropy_config(context, &ctx->entropy),
            (int32_t)0);
    }

    if (ctx->message & ENC_CONFIG_VUI) {
        ASSERT_EQ(hb_mm_mc_set_vui_config(context, &ctx->vui),
            (int32_t)0);
    }

    if (ctx->message & ENC_CONFIG_VUI_TIMING) {
        ASSERT_EQ(hb_mm_mc_set_vui_timing_config(context, &ctx->vui_timing),
            (int32_t)0);
    }

    if (ctx->message & ENC_CONFIG_SLICE) {
        ASSERT_EQ(hb_mm_mc_set_slice_config(context, &ctx->slice),
            (int32_t)0);
    }

    if (ctx->message & ENC_CONFIG_INSERT_USERDATA) {
        int ret  = 0;
        hb_u32 length = sizeof(uuid)/sizeof(uuid[0]);
        ret = hb_mm_mc_insert_user_data(context, uuid, length);
        printf("insert user data 1 %d\n", ret);
        ASSERT_EQ(ret,(int32_t)0);
        length = sizeof(uuid2)/sizeof(uuid2[0]);
        ret = hb_mm_mc_insert_user_data(context, uuid2, length);
        printf("insert user data 2 %d\n", ret);
        ASSERT_EQ(ret,(int32_t)0);
        length = sizeof(uuid3)/sizeof(uuid3[0]);
        ret = hb_mm_mc_insert_user_data(context, uuid3, length);
        printf("insert user data 3 %d\n", ret);
        ASSERT_EQ(ret,(int32_t)0);
        length = sizeof(uuid4)/sizeof(uuid4[0]);
        ret = hb_mm_mc_insert_user_data(context, uuid4, length);
        printf("insert user data 4 %d\n", ret);
        ASSERT_EQ(ret,(int32_t)0);
        length = sizeof(uuid5)/sizeof(uuid5[0]);
        ret = hb_mm_mc_insert_user_data(context, uuid5, length);
        printf("insert user data 5 %d\n", ret);
        ASSERT_EQ(ret,(int32_t)0);
        ret = hb_mm_mc_insert_user_data(context, uuid, length);
        printf("insert user data 6 %d\n", ret);
        ASSERT_NE(ret,(int32_t)0);
    }

    if (ctx->message & ENC_CONFIG_ENABLE_IDR) {
        // disable idr frame first
        if (ctx->enable_idr_num) {
            ASSERT_EQ(hb_mm_mc_enable_idr_frame(context, 0),
                (int32_t)0);
        }
    }

    if (ctx->message & ENC_CONFIG_REQUEST_IDR_HEADER) {
        if (ctx->force_idr_header_num == 0) {
            ASSERT_EQ(hb_mm_mc_request_idr_header(context, ctx->force_idr_header),
                (int32_t)0);
        }
    }

    if (ctx->message & ENC_CONFIG_3DNR) {
#ifdef J5
        ASSERT_EQ(hb_mm_mc_set_3dnr_enc_config(context, &ctx->noise_reduction),
            (int32_t)HB_MEDIA_ERR_UNSUPPORTED_FEATURE);
#else
        ASSERT_EQ(hb_mm_mc_set_3dnr_enc_config(context, &ctx->noise_reduction),
            (int32_t)0);
#endif
    }

    if (ctx->message & ENC_CONFIG_SMART_BG) {
#ifdef J5
        ASSERT_EQ(hb_mm_mc_set_smart_bg_enc_config(context, &ctx->smart_bg),
            (int32_t)HB_MEDIA_ERR_UNSUPPORTED_FEATURE);
#else
        ASSERT_EQ(hb_mm_mc_set_smart_bg_enc_config(context, &ctx->smart_bg),
            (int32_t)0);
#endif
    }

    if (ctx->message & ENC_CONFIG_PRED_UNIT) {
        ASSERT_EQ(hb_mm_mc_set_pred_unit_config(context, &ctx->pred_unit),
            (int32_t)0);
    }

    if (ctx->message & ENC_CONFIG_TRANSFORM) {
        ASSERT_EQ(hb_mm_mc_set_transform_config(context, &ctx->transform),
            (int32_t)0);
    }

    if (ctx->message & ENC_CONFIG_ROI) {
        ASSERT_EQ(hb_mm_mc_set_roi_config(context, &ctx->roi),
            (int32_t)0);
    }

    if (ctx->message & ENC_CONFIG_ROI_AVG_QP) {
        ASSERT_EQ(hb_mm_mc_set_roi_avg_qp(context, ctx->roi_avg_qp),
            (int32_t)0);
    }

#ifdef J5
    if (ctx->message & ENC_CONFIG_ROI_EX) {
        ASSERT_EQ(hb_mm_mc_set_roi_config_ex(context, &ctx->roiEx),
            (int32_t)0);
    }
#endif

    if (ctx->message & ENC_CONFIG_MODE_DECISION) {
#ifdef J5
        ASSERT_EQ(hb_mm_mc_set_mode_decision_config(context, &ctx->mode_decision),
            (int32_t)HB_MEDIA_ERR_UNSUPPORTED_FEATURE);
#else
        ASSERT_EQ(hb_mm_mc_set_mode_decision_config(context, &ctx->mode_decision),
            (int32_t)0);
#endif
    }

    if (ctx->message & ENC_CONFIG_ENABLE_EXP_HEADER) {
        ASSERT_EQ(hb_mm_mc_set_explicit_header_config(context, ctx->enable_explicit_header),
            (int32_t)0);
    }
#ifdef J5
    if (ctx->message & ENC_CONFIG_TRANS_BITRATE) {
        ASSERT_EQ(hb_mm_mc_set_max_bit_rate_config(context, ctx->max_bitrate),
            (int32_t)0);
    }
#endif
}

// TODO Supplement the userdata setting and improve this
static void set_default_dynamic_message(MediaCodecTestContext *ctx) {
    ASSERT_NE(ctx, nullptr);
    media_codec_context_t *context = ctx->context;
    ASSERT_NE(context, nullptr);
    if (ctx->testLog)
        printf("%s set dynamic message %d\n", TAG, ctx->dynamicMessage);

    if (ctx->dynamicMessage & ENC_CONFIG_LONGTERM_REF) {
        mc_video_longterm_ref_mode_t *ref_mode = &ctx->ref_mode;
        hb_mm_mc_get_longterm_ref_mode(context, ref_mode);
        ref_mode->use_longterm = TRUE;
        ref_mode->longterm_pic_using_period = 20;
        ref_mode->longterm_pic_period = 30;
        EXPECT_EQ(hb_mm_mc_set_longterm_ref_mode(context, &ctx->ref_mode),
            (int32_t)0);
    }

    if (ctx->dynamicMessage & ENC_CONFIG_RATE_CONTROL) {
        mc_rate_control_params_t *rc_params = &ctx->rc_params;
        rc_params->mode = context->video_enc_params.rc_params.mode;
        hb_mm_mc_get_rate_control_config(context, rc_params);
        switch (rc_params->mode) {
        case MC_AV_RC_MODE_H264CBR:
            rc_params->h264_cbr_params.bit_rate = 5000;
            rc_params->h264_cbr_params.intra_period = 60;
            break;
        case MC_AV_RC_MODE_H264VBR:
            rc_params->h264_vbr_params.intra_qp = 20;
            rc_params->h264_vbr_params.intra_period = 30;
            break;
        case MC_AV_RC_MODE_H264AVBR:
            rc_params->h264_avbr_params.intra_period = 15;
            rc_params->h264_avbr_params.intra_qp = 25;
            rc_params->h264_avbr_params.bit_rate = 2000;
            rc_params->h264_avbr_params.vbv_buffer_size = 3000;
            rc_params->h264_avbr_params.min_qp_I = 15;
            rc_params->h264_avbr_params.max_qp_I = 50;
            rc_params->h264_avbr_params.min_qp_P = 15;
            rc_params->h264_avbr_params.max_qp_P = 45;
            rc_params->h264_avbr_params.min_qp_B = 15;
            rc_params->h264_avbr_params.max_qp_B = 48;
            rc_params->h264_avbr_params.hvs_qp_enable = 0;
            rc_params->h264_avbr_params.hvs_qp_scale = 2;
            rc_params->h264_avbr_params.max_delta_qp = 5;
            rc_params->h264_avbr_params.qp_map_enable = 0;
            break;
        case MC_AV_RC_MODE_H264FIXQP:
            rc_params->h264_fixqp_params.force_qp_I = 23;
            rc_params->h264_fixqp_params.force_qp_P = 23;
            rc_params->h264_fixqp_params.force_qp_B = 23;
            rc_params->h264_fixqp_params.intra_period = 23;
            break;
        case MC_AV_RC_MODE_H264QPMAP:
            break;
        case MC_AV_RC_MODE_H265CBR:
            rc_params->h265_cbr_params.bit_rate = 5000;
            rc_params->h265_cbr_params.intra_period = 60;
            break;
        case MC_AV_RC_MODE_H265VBR:
            rc_params->h265_vbr_params.intra_qp = 20;
            rc_params->h265_vbr_params.intra_period = 30;
            break;
        case MC_AV_RC_MODE_H265AVBR:
            rc_params->h265_avbr_params.intra_period = 15;
            rc_params->h265_avbr_params.intra_qp = 25;
            rc_params->h265_avbr_params.bit_rate = 2000;
            rc_params->h265_avbr_params.vbv_buffer_size = 3000;
            rc_params->h265_avbr_params.min_qp_I = 15;
            rc_params->h265_avbr_params.max_qp_I = 50;
            rc_params->h265_avbr_params.min_qp_P = 15;
            rc_params->h265_avbr_params.max_qp_P = 45;
            rc_params->h265_avbr_params.min_qp_B = 15;
            rc_params->h265_avbr_params.max_qp_B = 48;
            rc_params->h265_avbr_params.hvs_qp_enable = 0;
            rc_params->h265_avbr_params.hvs_qp_scale = 2;
            rc_params->h265_avbr_params.max_delta_qp = 5;
            rc_params->h265_avbr_params.qp_map_enable = 0;
            break;
        case MC_AV_RC_MODE_H265FIXQP:
            rc_params->h265_fixqp_params.force_qp_I = 23;
            rc_params->h265_fixqp_params.force_qp_P = 23;
            rc_params->h265_fixqp_params.force_qp_B = 23;
            rc_params->h265_fixqp_params.intra_period = 23;
            break;
        case MC_AV_RC_MODE_H265QPMAP:
            break;
        default:
            break;
        }
        EXPECT_EQ(hb_mm_mc_set_rate_control_config(context, &ctx->rc_params),
            (int32_t)0);
    }

    if (ctx->dynamicMessage & ENC_CONFIG_DEBLK_FILTER) {
        mc_video_deblk_filter_params_t *deblk_filter = &ctx->deblk_filter;
        hb_mm_mc_get_deblk_filter_config(context, deblk_filter);
        if (context->codec_id == MEDIA_CODEC_ID_H264) {
            deblk_filter->h264_deblk.disable_deblocking_filter_idc = 2;
            deblk_filter->h264_deblk.slice_alpha_c0_offset_div2 = 6;
            deblk_filter->h264_deblk.slice_beta_offset_div2 = 6;
        } else {
            deblk_filter->h265_deblk.slice_deblocking_filter_disabled_flag = 1;
            deblk_filter->h265_deblk.slice_beta_offset_div2 = 6;
            deblk_filter->h265_deblk.slice_tc_offset_div2 = 6;
            deblk_filter->h265_deblk.slice_loop_filter_across_slices_enabled_flag = 1;
        }
        EXPECT_EQ(hb_mm_mc_set_deblk_filter_config(context, &ctx->deblk_filter),
            (int32_t)0);
    }

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        if (ctx->dynamicMessage & ENC_CONFIG_ENTROPY) {
            mc_h264_entropy_params_t *entropy = &ctx->entropy;
            hb_mm_mc_get_entropy_config(context, entropy);
            entropy->entropy_coding_mode = 0;
            EXPECT_EQ(hb_mm_mc_set_entropy_config(context, &ctx->entropy),
                (int32_t)0);
        }
    }

#ifndef J5
    if (ctx->dynamicMessage & ENC_CONFIG_REQUEST_IDR_HEADER) {
        EXPECT_EQ(hb_mm_mc_request_idr_header(context, ctx->force_idr_header),
            (int32_t)0);
    }
#endif

    //ctx->message = ENC_CONFIG_ENABLE_IDR;
    if (ctx->dynamicMessage & ENC_CONFIG_ENABLE_IDR) {
        EXPECT_EQ(hb_mm_mc_enable_idr_frame(context, ctx->enable_idr_num),
            (int32_t)0);
    }

    if (ctx->dynamicMessage & ENC_CONFIG_SKIP_PIC) {
        ctx->skip_pic_num = 16;
    }
    if (ctx->dynamicMessage & ENC_CONFIG_REQUEST_IDR) {
        ctx->req_idr_num = 35;
    }
    if (ctx->dynamicMessage & ENC_CONFIG_SLICE) {
        mc_video_slice_params_t *slice = &ctx->slice;
        hb_mm_mc_get_slice_config(context, slice);
        if (context->codec_id == MEDIA_CODEC_ID_H264) {
            slice->h264_slice.h264_slice_mode = 0;
            slice->h264_slice.h264_slice_arg = 60;
        } else {
            slice->h265_slice.h265_dependent_slice_mode = 0;
            slice->h265_slice.h265_dependent_slice_arg = 80;
            slice->h265_slice.h265_independent_slice_mode = 1;
            slice->h265_slice.h265_independent_slice_arg = 100;
        }
        EXPECT_EQ(hb_mm_mc_set_slice_config(context, &ctx->slice),
            (int32_t)0);
    }

#ifndef J5
    if (ctx->dynamicMessage & ENC_CONFIG_3DNR) {
        mc_video_3dnr_enc_params_t *noise_rd = &ctx->noise_reduction;
        hb_mm_mc_get_3dnr_enc_config(context, noise_rd);
        EXPECT_EQ(hb_mm_mc_set_3dnr_enc_config(context, &ctx->noise_reduction),
            (int32_t)0);
    }
#endif

#ifndef J5
    if (ctx->dynamicMessage & ENC_CONFIG_SMART_BG) {
        mc_video_smart_bg_enc_params_t *smart_bg = &ctx->smart_bg;
        hb_mm_mc_get_smart_bg_enc_config(context, smart_bg);
        smart_bg->bg_detect_enable = 0;
        smart_bg->bg_threshold_diff = 8;
        smart_bg->bg_threshold_mean_diff = 1;
        smart_bg->bg_lambda_qp = 32;
        smart_bg->bg_delta_qp = 3;
        smart_bg->s2fme_disable = 0;
        EXPECT_EQ(hb_mm_mc_set_smart_bg_enc_config(context, &ctx->smart_bg),
            (int32_t)0);
    }
#endif

    if (ctx->dynamicMessage & ENC_CONFIG_PRED_UNIT) {
        mc_video_pred_unit_params_t *pred_unit = &ctx->pred_unit;
        hb_mm_mc_get_pred_unit_config(context, pred_unit);
        if (context->codec_id == MEDIA_CODEC_ID_H264) {
            pred_unit->h264_intra_pred.constrained_intra_pred_flag = 1;
        } else {
            pred_unit->h265_pred_unit.intra_nxn_enable = 1;
            pred_unit->h265_pred_unit.constrained_intra_pred_flag = 1;
            pred_unit->h265_pred_unit.strong_intra_smoothing_enabled_flag = 0;
            pred_unit->h265_pred_unit.max_num_merge = 2;
        }
        EXPECT_EQ(hb_mm_mc_set_pred_unit_config(context, &ctx->pred_unit),
            (int32_t)0);
    }

    if (ctx->dynamicMessage & ENC_CONFIG_TRANSFORM) {
        mc_video_transform_params_t *transform = &ctx->transform;
        hb_mm_mc_get_transform_config(context, transform);
        if (context->codec_id == MEDIA_CODEC_ID_H264) {
            transform->h264_transform.transform_8x8_enable = 1;
            transform->h264_transform.chroma_cb_qp_offset = 4;
            transform->h264_transform.chroma_cr_qp_offset = 3;
            transform->h264_transform.user_scaling_list_enable = 0;
        } else {
            transform->h265_transform.chroma_cb_qp_offset = 6;
            transform->h265_transform.chroma_cr_qp_offset = 5;
            transform->h265_transform.user_scaling_list_enable = 0;
        }
        EXPECT_EQ(hb_mm_mc_set_transform_config(context, &ctx->transform),
            (int32_t)0);
    }

    if (ctx->dynamicMessage & ENC_CONFIG_ROI) {
        mc_video_roi_params_t *roi = &ctx->roi;
        hb_mm_mc_get_roi_config(context, roi);
        roi->roi_enable = 0;
        EXPECT_EQ(hb_mm_mc_set_roi_config(context, &ctx->roi),
            (int32_t)0);
    }

    if (ctx->dynamicMessage & ENC_CONFIG_ROI_AVG_QP) {
        hb_u32 *roi_avg_qp = &ctx->roi_avg_qp;
        EXPECT_EQ(hb_mm_mc_set_roi_avg_qp(context, *roi_avg_qp),
            (int32_t)0);
    }

#ifdef J5
    if (ctx->dynamicMessage & ENC_CONFIG_ROI_EX) {
        mc_video_roi_params_ex_t *roiEx = &ctx->roiEx;
        hb_mm_mc_get_roi_config_ex(context, 0, roiEx);
        roiEx->roi_enable = 0;
        EXPECT_EQ(hb_mm_mc_set_roi_config_ex(context, &ctx->roiEx),
            (int32_t)0);
    }
#endif

#ifndef J5
    if (ctx->dynamicMessage & ENC_CONFIG_MODE_DECISION) {
        mc_video_mode_decision_params_t *mode_decision = &ctx->mode_decision;
        hb_mm_mc_get_mode_decision_config(context, mode_decision);
        mode_decision->mode_decision_enable = FALSE;
        mode_decision->pu04_delta_rate = 76;
        mode_decision->pu08_delta_rate = 80;
        mode_decision->pu16_delta_rate = 86;
        mode_decision->pu32_delta_rate = 87;
        mode_decision->pu04_intra_planar_delta_rate = 0;
        mode_decision->pu04_intra_dc_delta_rate = 0;
        mode_decision->pu04_intra_angle_delta_rate = 0;
        mode_decision->pu08_intra_planar_delta_rate = 0;
        mode_decision->pu08_intra_dc_delta_rate = 0;
        mode_decision->pu08_intra_angle_delta_rate = 0;
        mode_decision->pu16_intra_planar_delta_rate = 0;
        mode_decision->pu16_intra_dc_delta_rate = 0;
        mode_decision->pu16_intra_angle_delta_rate = 0;
        mode_decision->pu32_intra_planar_delta_rate = 0;
        mode_decision->pu32_intra_dc_delta_rate = 0;
        mode_decision->pu32_intra_angle_delta_rate = 0;
        mode_decision->cu08_intra_delta_rate = 0;
        mode_decision->cu08_inter_delta_rate = 0;
        mode_decision->cu08_merge_delta_rate = 0;
        mode_decision->cu16_intra_delta_rate = 0;
        mode_decision->cu16_inter_delta_rate = 0;
        mode_decision->cu16_merge_delta_rate = 0;
        mode_decision->cu32_intra_delta_rate = 0;
        mode_decision->cu32_inter_delta_rate = 0;
        mode_decision->cu32_merge_delta_rate = 0;
        EXPECT_EQ(hb_mm_mc_set_mode_decision_config(context, &ctx->mode_decision),
            (int32_t)0);
    }
#endif

#ifdef J5
    if (ctx->dynamicMessage & ENC_CONFIG_TRANS_BITRATE) {
        hb_u32 *max_bitrate = &ctx->max_bitrate;
        hb_mm_mc_get_max_bit_rate_config(context, max_bitrate);
        EXPECT_EQ(hb_mm_mc_set_max_bit_rate_config(context, ctx->max_bitrate),
            (int32_t)0);
    }
#endif
}

static void set_dynamic_message(MediaCodecTestContext *ctx) {
    ASSERT_NE(ctx, nullptr);
    media_codec_context_t *context = ctx->context;
    ASSERT_NE(context, nullptr);
    if (ctx->testLog)
        printf("%s set dynamic message %d\n", TAG, ctx->dynamicMessage);

    if (ctx->dynamicMessage & ENC_CONFIG_LONGTERM_REF) {
        EXPECT_EQ(hb_mm_mc_set_longterm_ref_mode(context, &ctx->ref_mode_dynamic),
            (int32_t)0);
    }

    if (ctx->dynamicMessage & ENC_CONFIG_RATE_CONTROL) {
        EXPECT_EQ(hb_mm_mc_set_rate_control_config(context, &ctx->rc_params_dynamic),
            (int32_t)0);
    }

    if (ctx->dynamicMessage & ENC_CONFIG_DEBLK_FILTER) {
        EXPECT_EQ(hb_mm_mc_set_deblk_filter_config(context, &ctx->deblk_filter_dynamic),
            (int32_t)0);
    }

    if (ctx->dynamicMessage & ENC_CONFIG_VUI) {
        ASSERT_EQ(hb_mm_mc_set_vui_config(context, &ctx->vui_dynamic),
            (int32_t)0);
    }

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        if (ctx->dynamicMessage & ENC_CONFIG_ENTROPY) {
            EXPECT_EQ(hb_mm_mc_set_entropy_config(context, &ctx->entropy_dynamic),
                (int32_t)0);
        }
    }

#ifndef J5
    if (ctx->dynamicMessage & ENC_CONFIG_REQUEST_IDR_HEADER) {
        EXPECT_EQ(hb_mm_mc_request_idr_header(context, ctx->force_idr_header_dynamic),
            (int32_t)0);
    }
#endif

    //ctx->message = ENC_CONFIG_ENABLE_IDR;
    if (ctx->dynamicMessage & ENC_CONFIG_ENABLE_IDR) {
        EXPECT_EQ(hb_mm_mc_enable_idr_frame(context, ctx->enable_idr_num_dynamic),
            (int32_t)0);
    }

    if (ctx->dynamicMessage & ENC_CONFIG_SLICE) {
        EXPECT_EQ(hb_mm_mc_set_slice_config(context, &ctx->slice_dynamic),
            (int32_t)0);
    }

#ifndef J5
    if (ctx->dynamicMessage & ENC_CONFIG_3DNR) {
        EXPECT_EQ(hb_mm_mc_set_3dnr_enc_config(context, &ctx->noise_reduction_dynamic),
            (int32_t)0);
    }
#endif

#ifndef J5
    if (ctx->dynamicMessage & ENC_CONFIG_SMART_BG) {
        EXPECT_EQ(hb_mm_mc_set_smart_bg_enc_config(context, &ctx->smart_bg_dynamic),
            (int32_t)0);
    }
#endif

    if (ctx->dynamicMessage & ENC_CONFIG_PRED_UNIT) {
        EXPECT_EQ(hb_mm_mc_set_pred_unit_config(context, &ctx->pred_unit_dynamic),
            (int32_t)0);
    }

    if (ctx->dynamicMessage & ENC_CONFIG_TRANSFORM) {
        EXPECT_EQ(hb_mm_mc_set_transform_config(context, &ctx->transform_dynamic),
            (int32_t)0);
    }

    if (ctx->dynamicMessage & ENC_CONFIG_ROI) {
        EXPECT_EQ(hb_mm_mc_set_roi_config(context, &ctx->roi_dynamic),
            (int32_t)0);
    }

    if (ctx->dynamicMessage & ENC_CONFIG_ROI_AVG_QP) {
        hb_u32 *roi_avg_qp = &ctx->roi_avg_qp_dynamic;
        EXPECT_EQ(hb_mm_mc_set_roi_avg_qp(context, *roi_avg_qp),
            (int32_t)0);
    }

#ifdef J5
    if (ctx->dynamicMessage & ENC_CONFIG_ROI_EX) {
        EXPECT_EQ(hb_mm_mc_set_roi_config_ex(context, &ctx->roiEx_dynamic),
            (int32_t)0);
    }
#endif

#ifndef J5
    if (ctx->dynamicMessage & ENC_CONFIG_MODE_DECISION) {
        EXPECT_EQ(hb_mm_mc_set_mode_decision_config(context, &ctx->mode_decision_dynamic),
            (int32_t)0);
    }
#endif

#ifdef J5
    if (ctx->dynamicMessage & ENC_CONFIG_TRANS_BITRATE) {
        EXPECT_EQ(hb_mm_mc_set_max_bit_rate_config(context, ctx->max_bitrate_dynamic),
            (int32_t)0);
    }
#endif
}

static void on_vlc_buffer_message(hb_ptr userdata, hb_s32 * vlc_buf) {
    MediaCodecTestContext *ctx = (MediaCodecTestContext *)userdata;
    ASSERT_NE(vlc_buf, nullptr);
    ASSERT_NE(ctx, nullptr);
    ASSERT_GE(ctx->vlc_buf_size, 0);
    if (ctx->testLog) {
        printf("%s %s VLC Buffer size = %d; Reset to %d.\n", TAG, __FUNCTION__,
            *vlc_buf, ctx->vlc_buf_size);
    }
    *vlc_buf = ctx->vlc_buf_size;
}

static int check_and_init_test(MediaCodecTestContext *ctx) {
    int32_t ret = 0;
    char *inputFileName, *outputFileName, *inputMd5FileName;
    EXPECT_NE(ctx, nullptr);
    EXPECT_NE(ctx->context, nullptr);
    if (ctx == NULL || ctx->context == NULL) {
        return -1;
    }
    inputFileName = ctx->inputFileName;
    outputFileName = ctx->outputFileName;
    inputMd5FileName = ctx->inputMd5FileName;

    printf("%s[%d:%d] Thread work in %s mode\n", TAG, getpid(), gettid(),
        ctx->workMode == THREAD_WORK_MODE_SYNC ? "sync" :
        (ctx->workMode == THREAD_WORK_MODE_ASYNC ? "async" : "poll"));

    printf("%s[%d:%d] InputFileName = %s\n", TAG, getpid(), gettid(), inputFileName);
    printf("%s[%d:%d] OutputFileName = %s\n", TAG, getpid(), gettid(), outputFileName);
    printf("%s[%d:%d] InputMd5File = %s\n", TAG, getpid(), gettid(), inputMd5FileName);

    EXPECT_NE(inputFileName, nullptr);
    EXPECT_NE(outputFileName, nullptr);
    if (inputFileName == NULL || outputFileName == NULL) {
        return -1;
    }

    ctx->inFile = fopen(inputFileName, "rb");
    EXPECT_NE(ctx->inFile, nullptr);
    ctx->outFile = fopen(outputFileName, "wb+");
    EXPECT_NE(ctx->outFile, nullptr);
    if (ctx->inFile == NULL || ctx->outFile == NULL) {
        return -1;
    }

    if (ctx->md5Test == TRUE) {
        if (inputMd5FileName) {
            ctx->inMd5File = fopen(inputMd5FileName, "rb");
        }
        EXPECT_NE(ctx->inMd5File, nullptr);
        if (ctx->inMd5File == NULL) {
            return -1;
        }
    }

    // allocate ion buffers
    ret = hb_mem_module_open();
    EXPECT_EQ(ret, 0);
    if (ret == 0) {
        ctx->ionFd = 1;
    }

    if (ctx->context->encoder == TRUE) {
        printf("%s[%d:%d] Thread use %s buffer mode, %d rc mode\n", TAG, getpid(), gettid(),
            ctx->context->video_enc_params.external_frame_buf ?
            "external" : "internal", 
            ctx->context->video_enc_params.rc_params.mode);
        if (ctx->context->video_enc_params.external_frame_buf) {
            ctx->exFb = (ExternalFrameBuffer *) malloc(
                ctx->context->video_enc_params.frame_buf_count * sizeof(ExternalFrameBuffer));
            EXPECT_NE(ctx->exFb, nullptr);
            if (ctx->exFb == NULL) {
                return -1;
            }
            for (Uint32 i=0; i<ctx->context->video_enc_params.frame_buf_count; i++) {
                ctx->exFb[i].buf.size = ctx->context->video_enc_params.width
                    * ctx->context->video_enc_params.height * 3/2; // only for yuv420;
                ret = allocate_ion_mem(ctx->ionFd, &ctx->exFb[i].buf);
                EXPECT_EQ(ret, 0);
                if (ret != 0) {
                    return ret;
                }
                ctx->exFb[i].valid = 1;
                ctx->exFb[i].src_idx = i;
                if (ctx->readonce != 0) {
                    ret = fread((void *)ctx->exFb[i].buf.virt_addr, 1,
                        ctx->exFb[i].buf.size, ctx->inFile);
                    if (ret <= 0) {
                        ret = fseek(ctx->inFile, 0, SEEK_SET);
                        if(ret != 0) {
                            printf("%s Failed to rewind input file (pid=%d, tid=%d)\n",
                                TAG, getpid(), gettid());
                            return ret;
                        }
                    }
                }
            }
        }
    } else {
        printf("%s[%d:%d] Thread use %s buffer mode, %d feed mode.\n", TAG, getpid(), gettid(),
            ctx->context->video_dec_params.external_bitstream_buf ?
            "external" : "internal",
            ctx->context->video_dec_params.feed_mode);
        if (ctx->context->video_dec_params.external_bitstream_buf) {
            ctx->exBs = (ExternalStreamBuffer *) malloc(
                    ctx->context->video_dec_params.bitstream_buf_count * sizeof(ExternalStreamBuffer));
            EXPECT_NE(ctx->exBs, nullptr);
            if (ctx->exBs == NULL) {
                return -1;
            }

            for (Uint32 i=0; i<ctx->context->video_dec_params.bitstream_buf_count; i++) {
                ctx->exBs[i].buf.size = ctx->context->video_dec_params.bitstream_buf_size;
                ret = allocate_ion_mem(ctx->ionFd, &ctx->exBs[i].buf);
                EXPECT_EQ(ret, 0);
                if (ret != 0) {
                    return ret;
                }
                ctx->exBs[i].valid = 1;
                ctx->exBs[i].src_idx = i;
                if (ctx->readonce) {
                    ctx->exBs[i].onceflags = 0;
                }
            }
        }

    }

    // open decode files
    if (ctx->context->encoder != TRUE) {
        if (ctx->context->video_dec_params.feed_mode == MC_FEEDING_MODE_FRAME_SIZE) {
            ret = avformat_open_input(&ctx->avContext, ctx->inputFileName, 0, 0);
            EXPECT_GE(ret, 0);
            if (ret < 0) {
                return ret;
            }
            ret = avformat_find_stream_info(ctx->avContext, 0);
            EXPECT_GE(ret, 0);
            if (ret < 0) {
                return ret;
            }
            ctx->videoIndex = av_find_best_stream(ctx->avContext, AVMEDIA_TYPE_VIDEO, -1, -1, NULL, 0);
            EXPECT_GE(ctx->videoIndex, 0);
            if (ctx->videoIndex < 0) {
                return -1;
            }
            av_init_packet(&ctx->avpacket);
        } else {
            if (ctx->feedingSize == 0) {
                uint32_t KB = 1024;
                int32_t probability10;

                srand((uint32_t)time(NULL));
                ctx->feedingSize = rand() % MAX_FEEDING_SIZE;
                probability10 = (ctx->feedingSize % 100) < 10;
                if (ctx->feedingSize < KB) {
                    if (probability10 == FALSE)
                        ctx->feedingSize *= 100;
                }
            }
            printf("%s[%d:%d] Feeding size = %d\n", TAG,
                getpid(), gettid(), ctx->feedingSize);
        }
        ctx->firstPacket = 1;
    }
    return 0;
}

static int check_and_release_test(MediaCodecTestContext *ctx) {
    int32_t ret = 0;
    int md5Match, wholeFileSize = 0;
    uint8_t *md5Buffer = NULL;
    EXPECT_NE(ctx, nullptr);
    EXPECT_NE(ctx->context, nullptr);
    EXPECT_NE(ctx->inFile, nullptr);
    EXPECT_NE(ctx->outFile, nullptr);
    if (ctx == NULL || ctx->context == NULL || ctx->inFile == NULL ||
        ctx->outFile == NULL) {
        return -1;
    }

    if (ctx->context->encoder != TRUE) {
        if (ctx->context->video_dec_params.feed_mode == MC_FEEDING_MODE_FRAME_SIZE) {
            if (ctx->avContext) {
                avformat_close_input(&ctx->avContext);
            }
        }
    }
    if (ctx->context->encoder == TRUE) {
        if (ctx->context->video_enc_params.external_frame_buf) {
            if (ctx->exFb) {
                for (Uint32 i=0; i<ctx->context->video_enc_params.frame_buf_count; i++) {
                    ret = release_ion_mem(ctx->ionFd, &ctx->exFb[i].buf);
                    EXPECT_EQ(ret, 0);
                }
                free(ctx->exFb);
            }
        }
    } else {
        if (ctx->context->video_dec_params.external_bitstream_buf) {
            if (ctx->exBs) {
                for (Uint32 i=0; i<ctx->context->video_dec_params.bitstream_buf_count; i++) {
                    ret = release_ion_mem(ctx->ionFd, &ctx->exBs[i].buf);
                    EXPECT_EQ(ret, 0);
                }
                free(ctx->exBs);
            }
        }
    }

    if (ctx->ionFd)
        hb_mem_module_close();

    if (ctx->md5Test && ctx->inMd5File) {
        fseek(ctx->outFile, 0, SEEK_END);
        wholeFileSize = ftell(ctx->outFile);
        fseek(ctx->outFile, 0, SEEK_SET);
        md5Buffer = (uint8_t *)malloc(wholeFileSize);
        EXPECT_NE(md5Buffer, nullptr);
        if (md5Buffer == NULL) {
            return -1;
        }
        if (fread(md5Buffer, wholeFileSize, 1, ctx->outFile) <= 0) {
            printf("%s no output data read.\n", TAG);
        }
        md5Match = compare_md5_value(MD5_SIZE, ctx->inMd5File,
            md5Buffer, wholeFileSize);
        free(md5Buffer);

        fclose(ctx->inMd5File);
        EXPECT_EQ(md5Match, 1);
        if (md5Match != 1) {
            return -1;
        }
    }

    if (ctx->outFile)
        fclose(ctx->outFile);

    if (ctx->inFile)
        fclose(ctx->inFile);

    return 0;
}

static int read_input_frames(MediaCodecTestContext *ctx,
                media_codec_buffer_t *inputBuffer) {
    Uint64 curTime = 0;
    Int32 doRead = TRUE, doRewind = FALSE, ret = 0;
    Uint32 bufIdx = 0, srcIdx = 0;
    void *bufPtr = NULL;
    size_t bufSize = 0;
    EXPECT_NE(ctx, nullptr);
    EXPECT_NE(ctx->context, nullptr);
    EXPECT_NE(ctx->inFile, nullptr);
    EXPECT_NE(ctx->outFile, nullptr);
    EXPECT_NE(inputBuffer, nullptr);
    if (ctx == NULL || ctx->context == NULL || ctx->inFile == NULL ||
        ctx->outFile == NULL || inputBuffer == NULL) {
        printf("%s[%d:%d] Invalid parameters(%s).\n",
            TAG, getpid(), gettid(), __FUNCTION__);
        return -1;
    }

    if (ctx->stabilityTest || ctx->pfTest) {
        doRewind = TRUE;
        curTime = osal_gettime();
        if ((curTime - ctx->testStartTime)/1000 < (uint32_t)ctx->duration) {
            doRead = TRUE;
        } else {
            printf("%s[%d:%d] Time up(%d)\n",
                TAG, getpid(), gettid(), ctx->duration);
            doRead = FALSE;
            ret  = 0;
        }
    }

    if (ctx->context->video_enc_params.external_frame_buf) {
        // release input buffer and take it as the new input buffer
        for (bufIdx = 0; bufIdx < ctx->context->video_enc_params.frame_buf_count;
            bufIdx++) {
            if (ctx->exFb[bufIdx].valid &&
                ctx->exFb[bufIdx].src_idx == inputBuffer->vframe_buf.src_idx) {
                srcIdx = inputBuffer->vframe_buf.src_idx;
                break;
            }
        }
        EXPECT_NE(bufIdx, ctx->context->video_enc_params.frame_buf_count);
        if (bufIdx == ctx->context->video_enc_params.frame_buf_count) {
            return -1;
        }
        bufPtr = (void *)ctx->exFb[srcIdx].buf.virt_addr;
        bufSize = inputBuffer->vframe_buf.size;
        inputBuffer->vframe_buf.vir_ptr[0] =
            (hb_u8 *)ctx->exFb[srcIdx].buf.virt_addr;
        inputBuffer->vframe_buf.vir_ptr[1] = (hb_u8 *)
            ctx->exFb[srcIdx].buf.virt_addr + (inputBuffer->vframe_buf.size
            * 2 / 3);
        inputBuffer->vframe_buf.vir_ptr[2] = (hb_u8 *)
            ctx->exFb[srcIdx].buf.virt_addr + (inputBuffer->vframe_buf.size
            * 2 / 3 * 5 / 4);
        inputBuffer->vframe_buf.phy_ptr[0] =
            ctx->exFb[srcIdx].buf.phys_addr;
        inputBuffer->vframe_buf.phy_ptr[1] =
            ctx->exFb[srcIdx].buf.phys_addr + (inputBuffer->vframe_buf.size
            * 2 / 3);
        inputBuffer->vframe_buf.phy_ptr[2] =
            ctx->exFb[srcIdx].buf.phys_addr + (inputBuffer->vframe_buf.size
            * 2 / 3 * 5 / 4);
        inputBuffer->vframe_buf.fd[0] = -1;
        if (ctx->readonce != 0) {
            return bufSize;
        }
    } else {
        bufPtr = inputBuffer->vframe_buf.vir_ptr[0];
        bufSize = inputBuffer->vframe_buf.size;
    }

    if (doRead == FALSE) {
        return ret;
    }

    do {
        ret = fread(bufPtr, 1, bufSize, ctx->inFile);
        if (ret <= 0 && doRewind == FALSE) {
            printf("%s[%d:%d] Failed to read input file (size=%d)\n",
                TAG, getpid(), gettid(), bufSize);
        }

        if (ret <= 0 && doRewind == TRUE) {
            if(fseek(ctx->inFile, 0, SEEK_SET)) {
                printf("%s Failed to rewind input file (pid=%d, tid=%d)\n",
                    TAG, getpid(), gettid());
                break;
            }
        }
    } while (ret == 0 && doRewind == TRUE);

    if (ctx->qpmap_enable) {
        inputBuffer->vframe_buf.qp_map_valid = 1;
        inputBuffer->vframe_buf.qp_map_array = ctx->qpmap_array;
        inputBuffer->vframe_buf.qp_map_array_count = ctx->qpmap_count;
    }
    if (ctx->qpmap_enable_dynamic && ctx->input_num == DYNAMIC_START_NUM) {
        inputBuffer->vframe_buf.qp_map_valid = 1;
        inputBuffer->vframe_buf.qp_map_array = ctx->qpmap_array_dynamic;
        inputBuffer->vframe_buf.qp_map_array_count = ctx->qpmap_count_dynamic;
    }

    return ret;
}

static int write_output_streams(MediaCodecTestContext *ctx,
                media_codec_buffer_t *outputBuffer) {
    int32_t ret = 0;
    EXPECT_NE(ctx, nullptr);
    EXPECT_NE(ctx->context, nullptr);
    EXPECT_NE(ctx->inFile, nullptr);
    EXPECT_NE(ctx->outFile, nullptr);
    EXPECT_NE(outputBuffer, nullptr);
    if (ctx == NULL || ctx->context == NULL || ctx->inFile == NULL ||
        ctx->outFile == NULL || outputBuffer == NULL) {
        printf("%s[%d:%d] Invalid parameters(%s).\n",
            TAG, getpid(), gettid(), __FUNCTION__);
        return -1;
    }
    if (!ctx->stabilityTest && !ctx->pfTest) {
        fwrite(outputBuffer->vstream_buf.vir_ptr, outputBuffer->vstream_buf.size,
            1, ctx->outFile);
    }

    return ret;
}

static int do_encode_params_setting(MediaCodecTestContext *ctx,
            media_codec_buffer_t *inputBuffer) {
    media_codec_context_t *context;
    int32_t ret = 0;
    EXPECT_NE(ctx, nullptr);
    EXPECT_NE(ctx->context, nullptr);
    if (ctx == NULL || ctx->context == NULL || ctx->inFile == NULL ||
        ctx->outFile == NULL || inputBuffer == NULL) {
        printf("%s[%d:%d] Invalid parameters(%s).\n",
            TAG, getpid(), gettid(), __FUNCTION__);
        return -1;
    }
    context = ctx->context;

    if ((ctx->stabilityTest && ctx->stabilityParaTest)) {
        set_default_dynamic_message(ctx);
    }

    if (ctx->dynamicTest && ctx->input_num == DYNAMIC_START_NUM) {
        set_dynamic_message(ctx);
    }

    if (ctx->input_num == ctx->req_idr_num) {
        ret = hb_mm_mc_request_idr_frame(context);
        EXPECT_EQ(ret, (int32_t)0);
        if (ret) {
            return ret;
        }
    }
    if (ctx->input_num == ctx->skip_pic_num) {
        ret = hb_mm_mc_skip_pic(context, inputBuffer->vframe_buf.src_idx);
        EXPECT_EQ(ret, (int32_t)0);
        if (ret) {
            return ret;
        }
    }
    if (ctx->input_num == ctx->enable_idr_num) {
        ret = hb_mm_mc_enable_idr_frame(context, 1);
        EXPECT_EQ(ret, (int32_t)0);
        if (ret) {
            return ret;
        }
    }

    if (ctx->input_num == (int)ctx->force_idr_header_num) {
        ret = hb_mm_mc_request_idr_header(context, ctx->force_idr_header);
        EXPECT_EQ(ret, (int32_t)0);
        if (ret) {
            return ret;
        }
    }
    if (ctx->input_num == ctx->insert_userData_num) {
        uint8_t uuidTmp[] =
            "dc45e9bd-e6d948b7-962cd820-d923eeef+HorizonAILast";
        hb_u32 length = sizeof(uuidTmp)/sizeof(uuidTmp[0]);
        ret = hb_mm_mc_insert_user_data(context, uuidTmp, length);
        EXPECT_EQ(ret, (int32_t)0);
        if (ret) {
            return ret;
        }
    }

    return ret;
}

// sync mode
static void do_sync_encoding(void *arg) {
    hb_s32 ret = 0;
    int step = 0;
    int32_t encStartTime = 0, encFinishTime = 0;
    MediaCodecTestContext *ctx = (MediaCodecTestContext *)arg;
    media_codec_context_t *context;
    media_codec_buffer_t inputBuffer;
    media_codec_buffer_t outputBuffer;
    media_codec_output_buffer_info_t info;

    ctx->workMode = THREAD_WORK_MODE_SYNC;
    ASSERT_EQ(check_and_init_test(ctx), 0);
    context = ctx->context;

    //get start time
    ctx->testStartTime = osal_gettime();

    if (ctx->testLog) {
        printf("%s[%d:%d] Step %d initialize (outFile=%s, FileFd=%p)\n",
            TAG, getpid(), gettid(), step++, ctx->outputFileName, ctx->outFile);
    }
    ret = hb_mm_mc_initialize(context);
    ASSERT_EQ(ret, (int32_t)0);
    set_message(ctx);

    media_codec_callback_t callback;
    callback.on_vlc_buffer_message = on_vlc_buffer_message;
    if (ctx->vlc_buf_size > 0) {
        ret = hb_mm_mc_set_vlc_buffer_listener(context, &callback, ctx);
        ASSERT_EQ(ret, (int32_t)0);
    }

    if (ctx->testLog) {
        printf("%s[%d:%d] Step %d configure\n", TAG, getpid(), gettid(), step++);
    }
    ret = hb_mm_mc_configure(context);
    ASSERT_EQ(ret, (int32_t)0);

    if (ctx->testLog) {
        printf("%s[%d:%d] Step %d start\n", TAG, getpid(), gettid(), step++);
    }
    mc_av_codec_startup_params_t startup_params;
    startup_params.video_enc_startup_params.receive_frame_number = 0;
    ret = hb_mm_mc_start(context, &startup_params);
    ASSERT_EQ(ret, (int32_t)0);

    do {
        if (!ctx->lastFrame) {
            if (ctx->testLog) {
                printf("%s[%d:%d] Step %d dequeue input\n", TAG, getpid(), gettid(), step++);
            }
            // process input buffers
            memset(&inputBuffer, 0x00, sizeof(media_codec_buffer_t));
            ret = hb_mm_mc_dequeue_input_buffer(context, &inputBuffer, 3000);
            //EXPECT_EQ(ret, (int32_t)0);
            if (ctx->testLog) {
                printf("%s[%d:%d] input buffer viraddr %p phy addr %p, size = %d\n",
                    TAG, getpid(), gettid(), inputBuffer.vframe_buf.vir_ptr[0],
                    inputBuffer.vframe_buf.phy_ptr[0],
                    inputBuffer.vframe_buf.size);
            }

            if (!ret) {
                if (ctx->testLog) {
                    printf("%s[%d:%d] Step %d feed input\n", TAG, getpid(), gettid(), step++);
                }
                ret = read_input_frames(ctx, &inputBuffer);
                if (ret <= 0) {
                    printf("%s[%d:%d] There is no more input data(ret=%d)!\n",
                        TAG, getpid(), gettid(), ret);
                    inputBuffer.vframe_buf.size = 0;
                    inputBuffer.vframe_buf.frame_end = TRUE;
                    ctx->lastFrame = 1;
                } 

                ctx->input_num++;
                ASSERT_EQ(do_encode_params_setting(ctx, &inputBuffer), 0);

                if (ctx->testLog) {
                    printf("%s[%d:%d] Step %d queue input (size=%d)\n",
                        TAG, getpid(), gettid(), step++, inputBuffer.vframe_buf.size);
                }
                ret = hb_mm_mc_queue_input_buffer(context, &inputBuffer, 100);
                EXPECT_EQ(ret, (int32_t)0);
                if (ret != 0) {
                    break;
                }
                if (ctx->delaytest) {
                    encStartTime = osal_gettime();
                }
            } else {
                printf("%s[%d:%d] dequeue input buffer fail.\n", TAG, getpid(), gettid());
                if (ret != (int32_t)HB_MEDIA_ERR_WAIT_TIMEOUT) {
                    if (ctx->bitfullTest) {
                        EXPECT_EQ(ret, (int32_t)HB_MEDIA_ERR_OUTPUT_BUF_FULL);
                        break;
                    }
                    EXPECT_EQ(ret, (int32_t)0);
                    break;
                }
            }
        }

        if (!ctx->lastStream) {
            if (ctx->testLog) {
                printf("%s[%d:%d] Step %d dequeue output\n", TAG, getpid(), gettid(), step++);
            }
            // process output buffers
            memset(&outputBuffer, 0x00, sizeof(media_codec_buffer_t));
            memset(&info, 0x00, sizeof(media_codec_output_buffer_info_t));
            ret = hb_mm_mc_dequeue_output_buffer(context, &outputBuffer, &info, 3000);
            //EXPECT_EQ(ret, (int32_t)0);
            if (ctx->testLog) {
                printf("%s[%d:%d] output bufferviraddr %p phy addr %x, size = %d, outFile = %p\n",
                    TAG, getpid(), gettid(), outputBuffer.vstream_buf.vir_ptr,
                    outputBuffer.vstream_buf.phy_ptr, outputBuffer.vstream_buf.size,
                    ctx->outFile);
            }
            if (!ret) {
                if (ctx->testLog) {
                    printf("%s[%d:%d] Step %d write output file\n",
                        TAG, getpid(), gettid(), step++);
                }
                if (ctx->delaytest) {
                    encFinishTime = osal_gettime();
                    if ((encFinishTime - encStartTime) >= ctx->delaytime) {
                        printf("%s[%d:%d] Encoding time is %d, more than %dms\n",
                            TAG, getpid(), gettid(), (encFinishTime - encStartTime), ctx->delaytime);
                        ASSERT_LE((encFinishTime - encStartTime), ctx->delaytime);
                    }
                }
                ASSERT_EQ(write_output_streams(ctx, &outputBuffer), 0);
                if (ctx->testLog) {
                    printf("%s[%d:%d] Step %d queue output\n", TAG, getpid(), gettid(), step++);
                }
                ret = hb_mm_mc_queue_output_buffer(context, &outputBuffer, 100);
                EXPECT_EQ(ret, (int32_t)0);
                if (outputBuffer.vstream_buf.stream_end) {
                    printf("%s[%d:%d] There is no more output data!\n", TAG, getpid(), gettid());
                    ctx->lastStream = 1;
                    break;
                }
                if (ret) {
                    break;
                }
            } else {
                printf("%s[%d:%d] dequeue output buffer fail(ret=0x%x).\n", TAG, getpid(),
                    gettid(), ret);
                if (ret != (int32_t)HB_MEDIA_ERR_WAIT_TIMEOUT) {
                    if (ctx->bitfullTest) {
                        EXPECT_EQ(ret, (int32_t)HB_MEDIA_ERR_OUTPUT_BUF_FULL);
                        break;
                    }
                    EXPECT_EQ(ret, (int32_t)0);
                    break;
                }
            }
        }
    }while(TRUE);

    if (!ctx->testAbnormalQuit) {
        ret = hb_mm_mc_stop(context);
        EXPECT_EQ(ret, (int32_t)0);

        ret = hb_mm_mc_release(context);
        EXPECT_EQ(ret, (int32_t)0);
    }

    ASSERT_EQ(check_and_release_test(ctx), 0);
}

static void on_encoder_input_buffer_available(hb_ptr userdata, media_codec_buffer_t *inputBuffer) {
    MediaCodecTestContext *asyncCtx = (MediaCodecTestContext *)userdata;
    int step = 0;
    hb_s32 ret = 0;
    ASSERT_NE(asyncCtx, nullptr);
    ASSERT_NE(asyncCtx->context, nullptr);
    ASSERT_NE(asyncCtx->inFile, nullptr);
    ASSERT_NE(inputBuffer, nullptr);

    if (asyncCtx->targetFps <= 0) {
        asyncCtx->targetFps = 60;
    }

    if (asyncCtx->testLog) {
        printf("%s[%d:%d] input buffer viraddr %p phy addr %x, size = %d\n",
            TAG, getpid(), gettid(), inputBuffer->vframe_buf.vir_ptr[0],
            inputBuffer->vframe_buf.phy_ptr[0],
            inputBuffer->vframe_buf.size);
   }

    if (!asyncCtx->lastFrame) {
        if (asyncCtx->testLog) {
            printf("%s[%d:%d] Step %d feed input\n", TAG, getpid(), gettid(), step++);
        }
        ret = read_input_frames(asyncCtx, inputBuffer);
        if (ret <= 0) {
            printf("%s[%d:%d] There is no more input data!\n", TAG, getpid(), gettid());
            inputBuffer->vframe_buf.size = 0;
            inputBuffer->vframe_buf.frame_end = TRUE;
            asyncCtx->lastFrame = 1;
        } 
        asyncCtx->input_num++;
        ASSERT_EQ(do_encode_params_setting(asyncCtx, inputBuffer), 0);
    } else {
        printf("%s[%d:%d] Don't call me again!!!(%s)\n", TAG, getpid(),
            gettid(), __FUNCTION__);
        inputBuffer->vframe_buf.frame_end = TRUE;
        inputBuffer->vframe_buf.size = 0;
    }
}

static void on_encoder_output_buffer_available(hb_ptr userdata, media_codec_buffer_t *outputBuffer, media_codec_output_buffer_info_t *extraInfo) {
    MediaCodecTestContext *asyncCtx = (MediaCodecTestContext *)userdata;
    int step = 0;
    ASSERT_NE(asyncCtx, nullptr);
    ASSERT_NE(asyncCtx->context, nullptr);
    ASSERT_NE(asyncCtx->outFile, nullptr);
    ASSERT_NE(outputBuffer, nullptr);
    ASSERT_NE(extraInfo, nullptr);

    mc_h264_h265_output_stream_info_t info = extraInfo->video_stream_info;

    if (asyncCtx->testLog)
        printf("%s[%d:%d] output bufferviraddr %p phy addr %x, size = %d, outFile = %p, info=%p\n",
            TAG, getpid(), gettid(), outputBuffer->vstream_buf.vir_ptr,
            outputBuffer->vstream_buf.phy_ptr,
            outputBuffer->vstream_buf.size, asyncCtx->outFile, &info);
    if (asyncCtx->testLog)
        printf("%s[%d:%d] Step %d write output file\n",
            TAG, getpid(), gettid(), step++);
    ASSERT_EQ(write_output_streams(asyncCtx, outputBuffer), 0);
    if (outputBuffer->vstream_buf.stream_end) {
        printf("%s[%d:%d] There is no more output data!\n", TAG, getpid(), gettid());
        asyncCtx->lastStream = 1;
    }
}

static void on_encoder_media_codec_message(hb_ptr userdata, hb_s32 error) {
    MediaCodecTestContext *asyncCtx = (MediaCodecTestContext *)userdata;
    ASSERT_NE(asyncCtx, nullptr);
    ASSERT_NE(asyncCtx->context, nullptr);
    if (error) {
        asyncCtx->lastStream = 1;
        printf("%s[%d:%d] ERROR happened!\n", TAG, getpid(), gettid());
    }
}

// async mode
static void do_async_encoding(void *arg) {
    hb_s32 ret = 0;
    int step = 0;
    MediaCodecTestContext *ctx = (MediaCodecTestContext *)arg;
    media_codec_context_t *context;
    media_codec_callback_t callback;

    ctx->workMode = THREAD_WORK_MODE_ASYNC;
    ASSERT_EQ(check_and_init_test(ctx), 0);;
    context = ctx->context;

    //get current time
    ctx->testStartTime = osal_gettime();

    if (ctx->testLog) {
        printf("%s[%d:%d] Step %d initialize (outFile=%s, FileFd=%p)\n",
            TAG, getpid(), gettid(), step++, ctx->outputFileName, ctx->outFile);
    }
    ret = hb_mm_mc_initialize(context);
    ASSERT_EQ(ret, (int32_t)0);
    set_message(ctx);

    if (ctx->testLog) {
        printf("%s[%d:%d] Step %d register listener\n",
            TAG, getpid(), gettid(), step++);
    }
    callback.on_input_buffer_available = on_encoder_input_buffer_available;
    callback.on_output_buffer_available = on_encoder_output_buffer_available;
    callback.on_media_codec_message = on_encoder_media_codec_message;
    ret = hb_mm_mc_set_callback(context, &callback, ctx);
    ASSERT_EQ(ret, (int32_t)0);

    if (ctx->testLog) {
        printf("%s[%d:%d] Step %d configure\n", TAG, getpid(), gettid(), step++);
    }
    ret = hb_mm_mc_configure(context);
    ASSERT_EQ(ret, (int32_t)0);

    if (ctx->testLog) {
        printf("%s[%d:%d] Step %d start\n", TAG, getpid(), gettid(), step++);
    }
    mc_av_codec_startup_params_t startup_params;
    startup_params.video_enc_startup_params.receive_frame_number = 0;
    ret = hb_mm_mc_start(context, &startup_params);
    ASSERT_EQ(ret, (int32_t)0);

    while(!ctx->lastStream) {
        sleep(1);
    }

    ret = hb_mm_mc_stop(context);
    EXPECT_EQ(ret, (int32_t)0);

    ret = hb_mm_mc_release(context);
    EXPECT_EQ(ret, (int32_t)0);

    ASSERT_EQ(check_and_release_test(ctx), 0);
}

// poll mode
static void do_poll_encoding_select(void *arg) {
    hb_s32 ret = 0;
    int pollFd;
    int step = 0;
    fd_set readFds;
    float t1, t2;
    MediaCodecTestContext *ctx = (MediaCodecTestContext *)arg;
    media_codec_context_t *context;
    mc_inter_status_t status;
    media_codec_buffer_t outputBuffer;
    media_codec_output_buffer_info_t info;
    ASSERT_NE(ctx, nullptr);
    ASSERT_NE(ctx->context, nullptr);
    ASSERT_NE(ctx->outFile, nullptr);
    context = ctx->context;

    pollFd = ctx->pollEncFd;
    ASSERT_GT(pollFd, 0);

    do {
        FD_ZERO(&readFds);
        FD_SET(pollFd, &readFds);
        t1 = get_system_time_ms();
        printf("%s[%d:%d] start select: %5f\n", TAG, getpid(), gettid(), t1);
        ret = select(pollFd+1, &readFds, NULL, NULL, NULL);
        t2 = get_system_time_ms();
        printf("%s[%d:%d] select cost: %5f\n", TAG, getpid(), gettid(), t2 -t1);
        if (ret < 0) {
            printf("%s[%d:%d] Failed to select fd = %d.(err %s)\n",
                TAG, getpid(), gettid(), pollFd, strerror(errno));
            ctx->abnormal = TRUE;
            break;
        } else if (ret == 0) {
            printf("%s[%d:%d] Time out to select fd = %d.\n",
                TAG, getpid(), gettid(), pollFd);
            ctx->abnormal = TRUE;
            break;
        } else {
            if (FD_ISSET(pollFd, &readFds)) {
                if (ctx->testLog) {
                    printf("%s[%d:%d] Step %d dequeue output\n",
                        TAG, getpid(), gettid(), step++);
                }
                // process output buffers
                ASSERT_EQ(hb_mm_mc_get_status(context, &status), (int32_t)0);
                if (ctx->testLog) {
                    printf("%s[%d:%d] output count %d input count %d\n", TAG, getpid(), gettid(),
                    status.cur_output_buf_cnt, status.cur_input_buf_cnt);
                }
                //while (status.cur_output_buf_cnt--) {
                    memset(&outputBuffer, 0x00, sizeof(media_codec_buffer_t));
                    memset(&info, 0x00, sizeof(media_codec_output_buffer_info_t));
                    ret = hb_mm_mc_dequeue_output_buffer(context, &outputBuffer, &info, 1000);
                    EXPECT_EQ(ret, (int32_t)0);
                    if (ctx->testLog) {
                        printf("%s[%d:%d] output bufferviraddr %p phy addr %x, size = %d, outFile = %p\n",
                            TAG, getpid(), gettid(), outputBuffer.vstream_buf.vir_ptr,
                            outputBuffer.vstream_buf.phy_ptr,
                            outputBuffer.vstream_buf.size, ctx->outFile);
                    }
                    if (!ret) {
                        if (ctx->testLog) {
                            printf("%s[%d:%d] Step %d write output file\n",
                                TAG, getpid(), gettid(), step++);
                        }
                        ASSERT_EQ(write_output_streams(ctx, &outputBuffer), 0);
                        if (ctx->testLog) {
                            printf("%s[%d:%d] Step %d queue output\n",
                                TAG, getpid(), gettid(), step++);
                        }
                        ret = hb_mm_mc_queue_output_buffer(context, &outputBuffer, 100);
                        EXPECT_EQ(ret, (int32_t)0);
                        if (outputBuffer.vstream_buf.stream_end) {
                            printf("%s[%d:%d] There is no more output data!\n",
                                TAG, getpid(), gettid());
                            ctx->lastStream = 1;
                            break;
                        }
                        if (ret) {
                            ctx->abnormal = TRUE;
                            break;
                        }
                    } else {
                        printf("%s[%d:%d] dequeue output buffer fail.\n", TAG, getpid(), gettid());
                        if (ret == (int32_t)HB_MEDIA_ERR_UNKNOWN
                            || ret == (int32_t)HB_MEDIA_ERR_OPERATION_NOT_ALLOWED) {
                            ctx->abnormal = TRUE;
                            break;
                        }
                    }
                //  ASSERT_EQ(hb_mm_mc_get_status(context, &status), (int32_t)0);
                //}
            }
        }
    } while (!ctx->lastStream && !ctx->abnormal);
    printf("%s[%d:%d] Quit thread %s.\n", TAG, getpid(), gettid(), __FUNCTION__);

    ASSERT_EQ(hb_mm_mc_close_fd(context, pollFd), 0);
}

static void do_poll_encoding(void *arg) {
    pthread_t thread_id;
    void* retVal;
    hb_s32 ret = 0;
    int step = 0;
    Uint64 queueTime = 0, intervalTime = 0;
    MediaCodecTestContext *ctx = (MediaCodecTestContext *)arg;
    media_codec_context_t *context;

    ctx->workMode = THREAD_WORK_MODE_POLL;
    ASSERT_EQ(check_and_init_test(ctx), 0);;
    context = ctx->context;

    //get start time
    ctx->testStartTime = osal_gettime();

    if (ctx->testLog) {
        printf("%s[%d:%d] Step %d initialize (outFile=%s)\n",
            TAG, getpid(), gettid(), step++, ctx->outputFileName);
    }
    ret = hb_mm_mc_initialize(context);
    ASSERT_EQ(ret, (int32_t)0);
    set_message(ctx);

    if (ctx->testLog)
        printf("%s[%d:%d] Step %d configure\n",
            TAG, getpid(), gettid(), step++);
    ret = hb_mm_mc_configure(context);
    ASSERT_EQ(ret, (int32_t)0);

    printf("%s[%d:%d] Step %d start\n",
        TAG, getpid(), gettid(), step++);
    mc_av_codec_startup_params_t startup_params;
    startup_params.video_enc_startup_params.receive_frame_number = 0;
    ret = hb_mm_mc_start(context, &startup_params);
    EXPECT_EQ(ret, (int32_t)0);

    ASSERT_EQ(hb_mm_mc_get_fd(context, &ctx->pollEncFd), 0);
    pthread_create(&thread_id, NULL, (void* (*)(void*))do_poll_encoding_select, ctx);

    do {
        if (ctx->testLog)
            printf("%s[%d:%d] Step %d dequeue input\n",
                TAG, getpid(), gettid(), step++);
        // process input buffers
        media_codec_buffer_t inputBuffer;
        memset(&inputBuffer, 0x00, sizeof(media_codec_buffer_t));
        ret = hb_mm_mc_dequeue_input_buffer(context, &inputBuffer, 3000);
        //EXPECT_EQ(ret, (int32_t)0);
        if (ctx->testLog)
            printf("%s[%d:%d] input buffer viraddr %p phy addr %x, size = %d\n",
                TAG, getpid(), gettid(), inputBuffer.vframe_buf.vir_ptr[0],
                inputBuffer.vframe_buf.phy_ptr[0],
                inputBuffer.vframe_buf.size);

        if (!ret) {
            if (ctx->testLog)
                printf("%s[%d:%d] Step %d feed input (pid=%d, tid=%d)\n",
                    TAG, getpid(), gettid(), step++);
            ret = read_input_frames(ctx, &inputBuffer);
            if (!ret) {
                printf("%s[%d:%d] There is no more input data!\n",
                    TAG, getpid(), gettid());
                inputBuffer.vframe_buf.frame_end = TRUE;
                ctx->lastFrame = 1;
            }

            ctx->input_num++;
            ASSERT_EQ(do_encode_params_setting(ctx, &inputBuffer), 0);

            //EXPECT_EQ(ret, (int32_t)TRUE);
            if (ctx->testLog)
                printf("%s[%d:%d] Step %d queue input\n",
                    TAG, getpid(), gettid(), step++);
            if (ctx->frametime > 0) {
                if (queueTime > 0) {
                    intervalTime = osal_gettimeus() - queueTime;
                    printf("%s interval time %lld\n", TAG, intervalTime);
                    if (intervalTime < ctx->frametime) {
                        usleep(ctx->frametime - intervalTime);
                    }
                }
            }
            ret = hb_mm_mc_queue_input_buffer(context, &inputBuffer, 100);
            EXPECT_EQ(ret, (int32_t)0);
            if (ret != 0) {
                break;
            }
            if (ctx->frametime > 0) {
                queueTime = osal_gettimeus();
            }
        } else {
            printf("%s[%d:%d] dequeue input buffer fail.\n",
                TAG, getpid(), gettid());
            if (ret == (int32_t)HB_MEDIA_ERR_UNKNOWN
                || ret == (int32_t)HB_MEDIA_ERR_OPERATION_NOT_ALLOWED) {
                EXPECT_EQ(ret, (int32_t)0);
                break;
            }
        }
    }while(!ctx->lastFrame && !ctx->abnormal);

    pthread_join(thread_id, &retVal);
    printf("%s[%d:%d] thread return = %ld\n", TAG, getpid(), gettid(), (intptr_t)retVal);

    ret = hb_mm_mc_stop(context);
    EXPECT_EQ(ret, (int32_t)0);

    ret = hb_mm_mc_release(context);
    EXPECT_EQ(ret, (int32_t)0);
    printf("%s[%d:%d] Quit thread %s.\n", TAG, getpid(), gettid(), __FUNCTION__);

    ASSERT_EQ(check_and_release_test(ctx), 0);
}

static int build_dec_seq_header(uint8_t *        pbHeader,
    const media_codec_id_t codStd, const AVStream* st, int* sizelength)
{
    AVCodecParameters* avc = st->codecpar;

    uint8_t* pbMetaData = avc->extradata;
    int nMetaData = avc->extradata_size;
    uint8_t* p =    pbMetaData;
    uint8_t *a =    p + 4 - ((long) p & 3);
    uint8_t* t =    pbHeader;
    int         size;
    int         sps, pps, i, nal;

    size = 0;
    *sizelength = 4; // default size length(in bytes) = 4
    if (codStd == MEDIA_CODEC_ID_H264) {
        if (nMetaData > 1 && pbMetaData && pbMetaData[0] == 0x01) {
            // check mov/mo4 file format stream
            p += 4;
            *sizelength = (*p++ & 0x3) + 1;
            sps = (*p & 0x1f); // Number of sps
            p++;
            for (i = 0; i < sps; i++) {
                nal = (*p << 8) + *(p + 1) + 2;
                SET_BYTE(t, 0x00);
                SET_BYTE(t, 0x00);
                SET_BYTE(t, 0x00);
                SET_BYTE(t, 0x01);
                SET_BUFFER(t, p+2, nal-2);
                p += nal;
                size += (nal - 2 + 4); // 4 => length of start code to be inserted
            }

            pps = *(p++); // number of pps
            for (i = 0; i < pps; i++)
            {
                nal = (*p << 8) + *(p + 1) + 2;
                SET_BYTE(t, 0x00);
                SET_BYTE(t, 0x00);
                SET_BYTE(t, 0x00);
                SET_BYTE(t, 0x01);
                SET_BUFFER(t, p+2, nal-2);
                p += nal;
                size += (nal - 2 + 4); // 4 => length of start code to be inserted
            }
        }
        else if(nMetaData > 3) {
            size = -1;// return to meaning of invalid stream data;
            for (; p < a; p++) {
                if (p[0] == 0 && p[1] == 0 && p[2] == 1)  {
                    // find startcode
                    size = avc->extradata_size;
                    if (pbMetaData && 0x00 == pbMetaData[size-1]) {
                        size-=1;
                    }
                    if (!pbHeader || !pbMetaData)
                        return 0;
                    SET_BUFFER(pbHeader, pbMetaData, size);
                    break;
                }
            }
        }
    } else if (codStd == MEDIA_CODEC_ID_H265) {
        if (nMetaData > 1 && pbMetaData && pbMetaData[0] == 0x01) {
            static const int8_t nalu_header[4] = { 0, 0, 0, 1 };
            int numOfArrays = 0;
            uint16_t numNalus = 0;
            uint16_t nalUnitLength = 0;
            uint32_t offset = 0;

            p += 21;
            *sizelength = (*p++ & 0x3) + 1;
            numOfArrays = *p++;

            while(numOfArrays--) {
                p++;   // NAL type
                numNalus = (*p << 8) + *(p + 1);
                p+=2;
                for(i = 0;i < numNalus;i++)
                {
                    nalUnitLength = (*p << 8) + *(p + 1);
                    p+=2;
                    //if(i == 0)
                    {
                        memcpy(pbHeader + offset, nalu_header, 4);
                        offset += 4;
                        memcpy(pbHeader + offset, p, nalUnitLength);
                        offset += nalUnitLength;
                    }
                    p += nalUnitLength;
                }
            }

            size = offset;
        } else if(nMetaData > 3) {
            size = -1;// return to meaning of invalid stream data;

            for (; p < a; p++)
            {
                if (p[0] == 0 && p[1] == 0 && p[2] == 1) // find startcode
                {
                    size = avc->extradata_size;
                    if (!pbHeader || !pbMetaData)
                        return 0;
                    SET_BUFFER(pbHeader, pbMetaData, size);
                    break;
                }
            }
        }
    } else {
        SET_BUFFER(pbHeader, pbMetaData, nMetaData);
        size = nMetaData;
    }

    return size;
}

static int read_input_streams(MediaCodecTestContext *ctx,
                media_codec_buffer_t *inputBuffer) {
    Uint64 curTime = 0;
    int ret = 0, ret2 = 0;
    Uint32 bufIdx = 0, srcIdx = 0;
    Int32 doRead = TRUE, doRewind = FALSE;
    uint8_t *seqHeader = NULL;
    int seqHeaderSize = 0;
    void *bufPtr = NULL;
    int avalBufSize = 0;
    EXPECT_NE(ctx, nullptr);
    EXPECT_NE(ctx->context, nullptr);
    EXPECT_NE(ctx->inFile, nullptr);
    EXPECT_NE(ctx->outFile, nullptr);
    EXPECT_NE(inputBuffer, nullptr);
    if (ctx == NULL || ctx->context == NULL || ctx->inFile == NULL ||
        ctx->outFile == NULL || inputBuffer == NULL) {
        printf("%s[%d:%d] Invalid parameters(%s).\n",
            TAG, getpid(), gettid(), __FUNCTION__);
        return -1;
    }

    if (ctx->stabilityTest || ctx->pfTest) {
        doRewind = TRUE;
        curTime = osal_gettime();
        if ((curTime - ctx->testStartTime)/1000 < (uint32_t)ctx->duration) {
            doRead = TRUE;
        } else {
            printf("%s[%d:%d] Time up(%d)\n",
                TAG, getpid(), gettid(), ctx->duration);
            doRead = FALSE;
            ret = 0;
        }
    }

    if (ctx->context->video_dec_params.external_bitstream_buf) {
        // release input buffer and take it as the new input buffer
        for (bufIdx = 0;
            bufIdx < ctx->context->video_dec_params.bitstream_buf_count;
            bufIdx++) {
            if (ctx->exBs[bufIdx].valid &&
                ctx->exBs[bufIdx].src_idx == inputBuffer->vstream_buf.src_idx) {
                srcIdx = inputBuffer->vstream_buf.src_idx;
                break;
            }
        }
        EXPECT_NE(bufIdx, ctx->context->video_dec_params.bitstream_buf_count);
        if (bufIdx == ctx->context->video_dec_params.bitstream_buf_count) {
            return -1;
        }
        bufPtr = (void *)ctx->exBs[srcIdx].buf.virt_addr;

        if (ctx->context->video_dec_params.feed_mode == 
            MC_FEEDING_MODE_FRAME_SIZE) {
            avalBufSize = ctx->exBs[srcIdx].buf.size;
        } else {
            avalBufSize = (ctx->exBs[srcIdx].buf.size < (int)ctx->feedingSize) ?
                ctx->exBs[srcIdx].buf.size : ctx->feedingSize;
        }
        inputBuffer->vstream_buf.fd = ctx->exBs[srcIdx].buf.fd;
        inputBuffer->vstream_buf.phy_ptr =
            ctx->exBs[srcIdx].buf.phys_addr;
        inputBuffer->vstream_buf.vir_ptr =
            (hb_u8 *)ctx->exBs[srcIdx].buf.virt_addr;
        if (ctx->readonce != 0 && ctx->exBs[srcIdx].onceflags >= (int32_t)ctx->context->video_dec_params.bitstream_buf_count) {
            inputBuffer->vstream_buf.size = ctx->exBs[srcIdx].readsize;
            return avalBufSize;
        }
    } else {
        bufPtr = (void *)inputBuffer->vstream_buf.vir_ptr;
        if (ctx->context->video_dec_params.feed_mode == 
            MC_FEEDING_MODE_FRAME_SIZE) {
            avalBufSize = inputBuffer->vstream_buf.size;
        } else {
            avalBufSize = (inputBuffer->vstream_buf.size < ctx->feedingSize) ?
                inputBuffer->vstream_buf.size : ctx->feedingSize;
        }
    }

    if (doRead == FALSE) {
        return ret;
    }

    // MC_FEEDING_MODE_FRAME_SIZE mode
    if (ctx->context->video_dec_params.feed_mode == MC_FEEDING_MODE_FRAME_SIZE) {
        do {
            if (ctx->avpacket.size == 0) {
                ret = av_read_frame(ctx->avContext, &ctx->avpacket);
                if (ret < 0 && doRewind == FALSE) {
                    printf("%s[%d:%d] Failed to read input file (error=0x%x)\n",
                        TAG, getpid(), gettid(), ret);
                }

                if (ret < 0 && doRewind == TRUE) {
                    avformat_close_input(&ctx->avContext);
                    ret2 = avformat_open_input(&ctx->avContext, ctx->inputFileName, 0, 0);
                    EXPECT_GE(ret2, 0);
                    if (ret2 < 0) {
                        ret = ret2;
                        break;
                    }
                    /*ret = avformat_find_stream_info(ctx->avContext, 0);
                    EXPECT_GE(ret, 0);
                    if (ret < 0) {
                        break;
                    }
                    ctx->videoIndex = av_find_best_stream(ctx->avContext, AVMEDIA_TYPE_VIDEO, -1, -1, NULL, 0);
                    EXPECT_GE(ctx->videoIndex, 0);
                    if (ctx->videoIndex < 0) {
                        ret = -1;
                        break;
                    }*/
                    av_init_packet(&ctx->avpacket);
                }
            } else {
                if (ctx->testLog) {
                    printf("%s[%d:%d] Reuse previous stream packet size %d\n",
                        TAG, getpid(), gettid(), ctx->avpacket.size);
                }
            }
        } while (ret < 0 && doRewind == TRUE);

        if (ret < 0) {
            if (ret == AVERROR_EOF || ctx->avContext->pb->eof_reached == TRUE) {
                printf("%s[%d:%d] End of file!\n", TAG, getpid(), gettid());
                ret = 0;
            } else {
                printf("%s[%d:%d] Failed to av_read_frame error(0x%08x)\n",
                    TAG, getpid(), gettid(), ret);
            }
            return ret;
        }

        if (ctx->testLog) {
            printf("%s[%d:%d] Read packet size %d\n",
                TAG, getpid(), gettid(), ctx->avpacket.size);
        }
        seqHeaderSize = 0;
        if (ctx->firstPacket) {
            AVCodecParameters* codec;
            int retSize = 0;
            codec = ctx->avContext->streams[ctx->videoIndex]->codecpar;
            seqHeader = (uint8_t*)malloc(codec->extradata_size + 1024);
            if (seqHeader == NULL) {
                printf("%s[%d:%d] Failed to mallock seqHeader\n",
                    TAG, getpid(), gettid());
                ret = -1;
                return ret;
            }
            memset((void*)seqHeader, 0x00, codec->extradata_size + 1024);

            seqHeaderSize = build_dec_seq_header(seqHeader,
                ctx->context->codec_id,
                ctx->avContext->streams[ctx->videoIndex], &retSize);
            if (seqHeaderSize < 0) {
                printf("%s[%d:%d] Failed to build seqHeader\n",
                    TAG, getpid(), gettid());
                ret = -1;
                return ret;
            }

            ctx->firstPacket = 0;
        }

        if ((ctx->avpacket.size <= avalBufSize)
            && (seqHeaderSize <= avalBufSize)) {
            int bufSize = 0;
            if (seqHeaderSize) {
                memcpy(bufPtr, seqHeader, seqHeaderSize);
                bufSize = seqHeaderSize;
                /*memcpy((char *)bufPtr+bufSize,ctx->avpacket.data, ctx->avpacket.size);
                bufSize += ctx->avpacket.size;
                av_packet_unref(&ctx->avpacket);
                ctx->avpacket.size = 0;*/
            } else {
                memcpy(bufPtr,ctx->avpacket.data, ctx->avpacket.size);
                bufSize = ctx->avpacket.size;
                av_packet_unref(&ctx->avpacket);
                ctx->avpacket.size = 0;
                if (ctx->readonce != 0 && ctx->context->video_dec_params.external_bitstream_buf != 0) {
                    ctx->exBs[srcIdx].readsize = bufSize;
                    ctx->exBs[srcIdx].onceflags++;
                }
            }
            inputBuffer->vstream_buf.size = bufSize;
        printf("%d, srcIdx:%d, phys_addr:%llx, virt_addr:%llx, size:%d\n", __LINE__, srcIdx, inputBuffer->vstream_buf.phy_ptr, inputBuffer->vstream_buf.vir_ptr, inputBuffer->vstream_buf.size);
        } else {
            printf("%s[%d:%d] The stream buffer is too "
                "small!\n", TAG, getpid(), gettid());
            return -1;
        }
        if (seqHeader) {
            free(seqHeader);
            seqHeader = NULL;
        }
        return 1;
    }

    // MC_FEEDING_MODE_STREAM_SIZE mode
    do {
        ret = fread(bufPtr, 1, avalBufSize, ctx->inFile);
        if (ret <= 0 && doRewind == FALSE) {
            printf("%s[%d:%d] Failed to read input file (error=0x%x)\n",
                TAG, getpid(), gettid(), ret);
        }

        if (ret <= 0 && doRewind == TRUE) {
            if(fseek(ctx->inFile, 0, SEEK_SET)) {
                printf("%s Failed to rewind input file (pid=%d, tid=%d)\n",
                    TAG, getpid(), gettid());
                break;
            }
        }
    } while (ret == 0 && doRewind == TRUE);
    inputBuffer->vstream_buf.size = ret > 0 ? ret : 0;

    return ret;
}

static int write_output_frames(MediaCodecTestContext *ctx,
                media_codec_buffer_t *outputBuffer) {
    int32_t ret = 0;
    EXPECT_NE(ctx, nullptr);
    EXPECT_NE(ctx->context, nullptr);
    EXPECT_NE(ctx->inFile, nullptr);
    EXPECT_NE(ctx->outFile, nullptr);
    EXPECT_NE(outputBuffer, nullptr);
    if (ctx == NULL || ctx->context == NULL || ctx->inFile == NULL ||
        ctx->outFile == NULL || outputBuffer == NULL) {
        printf("%s[%d:%d] Invalid parameters(%s).\n",
            TAG, getpid(), gettid(), __FUNCTION__);
        return -1;
    }
    if (!ctx->stabilityTest && !ctx->pfTest) {
        fwrite(outputBuffer->vframe_buf.vir_ptr[0], outputBuffer->vframe_buf.size,
            1, ctx->outFile);
    }

    return ret;
}

static int do_decode_params_checking(MediaCodecTestContext *ctx,
            media_codec_buffer_t *outputBuffer) {
    media_codec_context_t *context;
    int32_t ret = 0;
    EXPECT_NE(ctx, nullptr);
    EXPECT_NE(ctx->context, nullptr);
    if (ctx == NULL || ctx->context == NULL || ctx->inFile == NULL ||
        ctx->outFile == NULL || outputBuffer == NULL) {
        printf("%s[%d:%d] Invalid parameters(%s).\n",
            TAG, getpid(), gettid(), __FUNCTION__);
        return -1;
    }
    context = ctx->context;

    if (ctx->enable_get_userdata) {
        mc_user_data_buffer_t userdata = {0};
        ret = hb_mm_mc_get_user_data(context, &userdata, 0);
        if (!ret) {
            printf("%s[%d:%d] Get userdata %d:\n", TAG, getpid(), gettid(), userdata.size);
            for (uint32_t i = 0; i < userdata.size; i++) {
                if (i < 16) {
                    printf("%s[%d:%d] userdata[i]:%x\n", TAG, getpid(), gettid(), userdata.virt_addr[i]);
                } else {
                    printf("%s[%d:%d] userdata[i]:%c\n", TAG, getpid(), gettid(), userdata.virt_addr[i]);
                }
            }
            ret = hb_mm_mc_release_user_data(context, &userdata);
        } else {
            ret = 0;
        }
    }

    return ret;
}

// sync mode
static void do_sync_decoding(void *arg) {
    int ret = 0;
    int step = 0;
    MediaCodecTestContext *ctx = (MediaCodecTestContext *)arg;
    media_codec_context_t *context;
    media_codec_callback_t callback;
    media_codec_buffer_t inputBuffer;
    media_codec_buffer_t outputBuffer;
    media_codec_output_buffer_info_t info;
    int32_t decStartTime = 0, decFinishTime = 0;

    ctx->workMode = THREAD_WORK_MODE_SYNC;
    ASSERT_EQ(check_and_init_test(ctx), 0);
    context = ctx->context;

    //get current time
    ctx->testStartTime = osal_gettime();

    if (ctx->testLog) {
        printf("%s[%d:%d] Step %d initialize (outFile=%s, FileFd=%p)\n",
            TAG, getpid(), gettid(), step++, ctx->outputFileName, ctx->outFile);
    }
    ret = hb_mm_mc_initialize(context);
    ASSERT_EQ(ret, (int32_t)0);

    callback.on_vlc_buffer_message = on_vlc_buffer_message;
    if (ctx->vlc_buf_size > 0) {
        ret = hb_mm_mc_set_vlc_buffer_listener(context, &callback, ctx);
        ASSERT_EQ(ret, (int32_t)0);
    }

    if (ctx->testLog) {
        printf("%s[%d:%d] Step %d configure\n", TAG, getpid(), gettid(), step++);
    }
    ret = hb_mm_mc_configure(context);
    EXPECT_EQ(ret, (int32_t)0);

    if (ctx->testLog) {
        printf("%s[%d:%d] Step %d start\n", TAG, getpid(), gettid(), step++);
    }
    mc_av_codec_startup_params_t startup_params;
    memset(&startup_params, 0x00, sizeof(mc_av_codec_startup_params_t));
    ret = hb_mm_mc_start(context, &startup_params);
    EXPECT_EQ(ret, (int32_t)0);

    do {
        if (!ctx->lastStream) {
            if (ctx->testLog) {
                printf("%s[%d:%d] Step %d dequeue input\n", TAG, getpid(), gettid(), step++);
            }
            // process input buffers
            ret = hb_mm_mc_dequeue_input_buffer(context, &inputBuffer, 3000);
            //EXPECT_EQ(ret, (int32_t)0);
            if (!ret) {
                if (ctx->testLog) {
                    printf("%s[%d:%d] input buffer viraddr %p phy addr %x, size = %d\n",
                        TAG, getpid(), gettid(), inputBuffer.vstream_buf.vir_ptr,
                        inputBuffer.vstream_buf.phy_ptr,
                        inputBuffer.vstream_buf.size);
                }

                if (ctx->testLog) {
                    printf("%s[%d:%d] Step %d feed input (pid=%d, tid=%d)\n", TAG, getpid(), gettid(), step++);
                }

                ret = read_input_streams(ctx, &inputBuffer);
                if (ret <= 0) {
                    printf("%s[%d:%d] There is no more input data(ret=%d)!\n",
                        TAG, getpid(), gettid(), ret);
                    inputBuffer.vstream_buf.stream_end = TRUE;
                    inputBuffer.vstream_buf.size = 0;
                    ctx->lastStream = 1;
                }

                //EXPECT_EQ(ret, (int32_t)TRUE);
                if (ctx->testLog) {
                    printf("%s[%d:%d] Step %d queue input(size=%d)\n",
                        TAG, getpid(), gettid(), step++, inputBuffer.vstream_buf.size);
                }
                ret = hb_mm_mc_queue_input_buffer(context, &inputBuffer, 100);
                EXPECT_EQ(ret, (int32_t)0);
                if (ret != 0) {
                    break;
                }
                if (ctx->delaytest) {
                    decStartTime = osal_gettime();
                }
            } else {
                if (ret != (int32_t)HB_MEDIA_ERR_WAIT_TIMEOUT) {
                    EXPECT_EQ(ret, (int32_t)0);
                    char info[256];
                    hb_mm_strerror(ret, info, 256);
                    printf("%s[%d:%d] dequeue input buffer fail.(%s)\n", TAG, getpid(), gettid(), info);
                    break;
                }
            }
        }

        if (!ctx->lastFrame) {
            if (ctx->testLog) {
                printf("%s[%d:%d] Step %d dequeue output\n", TAG, getpid(), gettid(), step++);
            }
            // process output buffers
            memset(&outputBuffer, 0x00, sizeof(media_codec_buffer_t));
            memset(&info, 0x00, sizeof(media_codec_output_buffer_info_t));
            ret = hb_mm_mc_dequeue_output_buffer(context, &outputBuffer, &info, 100);
            //EXPECT_EQ(ret, (int32_t)0);
            if (!ret) {
                if (ctx->testLog) {
                    printf("%s[%d:%d] output bufferviraddr %p phy addr %x, size = %d, outFile = %p\n",
                        TAG, getpid(), gettid(), outputBuffer.vframe_buf.vir_ptr[0],
                        outputBuffer.vframe_buf.phy_ptr[0],
                        outputBuffer.vframe_buf.size, ctx->outFile);
                }
                if (ctx->testLog) {
                    printf("%s[%d:%d] Step %d write output file\n", TAG, getpid(), gettid(), step++);
                }
                if (ctx->delaytest) {
                    decFinishTime = osal_gettime();
                    if ((decFinishTime - decStartTime) >= ctx->delaytime) {
                        printf("%s[%d:%d] Decoding time is %d, more than %dms\n",
                            TAG, getpid(), gettid(), (decFinishTime - decStartTime), ctx->delaytime);
                        ASSERT_LE((decFinishTime - decStartTime), ctx->delaytime);
                    }
                }
                ASSERT_EQ(write_output_frames(ctx, &outputBuffer), 0);
                if (ctx->testLog) {
                    printf("%s[%d:%d] Step %d queue output\n", TAG, getpid(), gettid(), step++);
                }

                ASSERT_EQ(do_decode_params_checking(ctx, &outputBuffer), 0);

                ret = hb_mm_mc_queue_output_buffer(context, &outputBuffer, 100);
                EXPECT_EQ(ret, (int32_t)0);
                if (outputBuffer.vframe_buf.frame_end) {
                    printf("%s[%d:%d] There is no more output data!\n", TAG, getpid(), gettid());
                    ctx->lastFrame = 1;
                    break;
                }
                if (ret) {
                    break;
                }
            } else {
                char info[256];
                hb_mm_strerror(ret, info, 256);
                printf("%s[%d:%d] dequeue output buffer fail.(%s)\n", TAG, getpid(), gettid(), info);
                if (ret != (int32_t)HB_MEDIA_ERR_WAIT_TIMEOUT) {
                    EXPECT_EQ(ret, (int32_t)0);
                    break;
                }
                if (ctx->stabilityTest && ctx->lastStream ==1) {
                    break;
                }
            }
        }
    }while(TRUE);

    ret = hb_mm_mc_stop(context);
    EXPECT_EQ(ret, (int32_t)0);

    ret = hb_mm_mc_release(context);
    EXPECT_EQ(ret, (int32_t)0);

    ASSERT_EQ(check_and_release_test(ctx), 0);
}

static void on_decocder_input_buffer_available(hb_ptr userdata, media_codec_buffer_t *inputBuffer) {
    MediaCodecTestContext *asyncCtx = (MediaCodecTestContext *)userdata;
    int ret = 0, step = 0;
    ASSERT_NE(asyncCtx, nullptr);
    ASSERT_NE(asyncCtx->context, nullptr);
    ASSERT_NE(asyncCtx->avContext, nullptr);
    ASSERT_NE(inputBuffer, nullptr);

    if (asyncCtx->testLog) {
        printf("%s[%d:%d] input buffer viraddr %p phy addr %x, size = %d\n",
            TAG, getpid(), gettid(), inputBuffer->vstream_buf.vir_ptr,
            inputBuffer->vstream_buf.phy_ptr,
            inputBuffer->vstream_buf.size);
    }

    if (!asyncCtx->lastStream) {
        if (asyncCtx->testLog) {
            printf("%s[%d:%d] Step %d feed input\n", TAG, getpid(), gettid(), step++);
        }

        ret = read_input_streams(asyncCtx, inputBuffer);
        if (ret <= 0) {
            printf("%s[%d:%d] There is no more input data(ret=%d)!\n",
                TAG, getpid(), gettid(), ret);
            inputBuffer->vstream_buf.stream_end = TRUE;
            inputBuffer->vstream_buf.size = 0;
            asyncCtx->lastStream = 1;
        }
    } else {
        printf("%s[%d:%d] Don't call me again!!!(%s)\n", TAG, getpid(), gettid(), __FUNCTION__);
        inputBuffer->vstream_buf.stream_end = TRUE;
        inputBuffer->vstream_buf.size = 0;
    }
}

static void on_decocder_output_buffer_available(hb_ptr userdata, media_codec_buffer_t *outputBuffer, media_codec_output_buffer_info_t *extraInfo) {
    MediaCodecTestContext *asyncCtx = (MediaCodecTestContext *)userdata;
    int step = 0;
    ASSERT_NE(asyncCtx, nullptr);
    ASSERT_NE(asyncCtx->context, nullptr);
    ASSERT_NE(asyncCtx->outFile, nullptr);
    ASSERT_NE(outputBuffer, nullptr);
    ASSERT_NE(extraInfo, nullptr);

    mc_h264_h265_output_frame_info_t info = extraInfo->video_frame_info;

    if (asyncCtx->testLog) {
        printf("%s[%d:%d] output bufferviraddr %p phy addr %x, size = %d, outFile = %p, info=%p\n",
            TAG, getpid(), gettid(), outputBuffer->vframe_buf.vir_ptr[0],
            outputBuffer->vframe_buf.phy_ptr[0],
            outputBuffer->vframe_buf.size, asyncCtx->outFile, &info);
    }
    if (asyncCtx->testLog) {
        printf("%s[%d:%d] Step %d write output file\n",
            TAG, getpid(), gettid(), step++);
    }

    ASSERT_EQ(write_output_frames(asyncCtx, outputBuffer), 0);
    if (outputBuffer->vframe_buf.frame_end) {
        printf("%s[%d:%d] There is no more output data!\n", TAG, getpid(), gettid());
        asyncCtx->lastFrame = 1;
    }
    ASSERT_EQ(do_decode_params_checking(asyncCtx, outputBuffer), 0);
}

static void on_decocder_media_codec_message(hb_ptr userdata, hb_s32 error) {
    MediaCodecTestContext *asyncCtx = (MediaCodecTestContext *)userdata;
    ASSERT_NE(asyncCtx, nullptr);
    if (error) {
        asyncCtx->lastFrame = 1;
        printf("%s[%d:%d] ERROR happened!\n", TAG, getpid(), gettid());
    }
}

// async mode
static void do_async_decoding(void *arg) {
    hb_s32 ret = 0;
    int step = 0;
    MediaCodecTestContext *ctx = (MediaCodecTestContext *)arg;
    media_codec_context_t *context;
    media_codec_callback_t callback;

    ctx->workMode = THREAD_WORK_MODE_ASYNC;
    ASSERT_EQ(check_and_init_test(ctx), 0);
    context = ctx->context;

    //get start time
    ctx->testStartTime = osal_gettime();

    if (ctx->testLog) {
        printf("%s[%d:%d] Step %d initialize (pid=%d, tid=%d) (outFile=%s, FileFd=%p,"
            "inputFileName=%s)\n",
            TAG, getpid(), gettid(), step++, ctx->outputFileName,
            ctx->outFile, ctx->inputFileName);
    }
    ret = hb_mm_mc_initialize(context);
    ASSERT_EQ(ret, (int32_t)0);

    if (ctx->testLog)
        printf("%s[%d:%d] Step %d create\n",TAG, getpid(), gettid(), step++);

    if (ctx->testLog) {
        printf("%s[%d:%d] Step %d register listener\n", TAG, getpid(), gettid(), step++);
    }
    callback.on_input_buffer_available = on_decocder_input_buffer_available;
    callback.on_output_buffer_available = on_decocder_output_buffer_available;
    callback.on_media_codec_message = on_decocder_media_codec_message;
    ret = hb_mm_mc_set_callback(context, &callback, ctx);
    ASSERT_EQ(ret, (int32_t)0);

    if (ctx->testLog) {
        printf("%s[%d:%d] Step %d configure\n", TAG, getpid(), gettid(), step++);
    }
    ret = hb_mm_mc_configure(context);
    ASSERT_EQ(ret, (int32_t)0);

    if (ctx->testLog) {
        printf("%s[%d:%d] Step %d start\n", TAG, getpid(), gettid(), step++);
    }
    mc_av_codec_startup_params_t startup_params;
    memset(&startup_params, 0x00, sizeof(mc_av_codec_startup_params_t));
    ret = hb_mm_mc_start(context, &startup_params);
    EXPECT_EQ(ret, (int32_t)0);

    while(!ctx->lastFrame) {
        sleep(1);
    }

    ret = hb_mm_mc_stop(context);
    EXPECT_EQ(ret, (int32_t)0);

    ret = hb_mm_mc_release(context);
    EXPECT_EQ(ret, (int32_t)0);

    ASSERT_EQ(check_and_release_test(ctx), 0);
}

// poll mode
static void do_poll_decoding_select(void *arg) {
    hb_s32 ret = 0;
    int pollFd;
    int step = 0;
    float t1, t2;
    fd_set readFds;
    MediaCodecTestContext *ctx = (MediaCodecTestContext *)arg;
    media_codec_context_t *context;
    media_codec_buffer_t outputBuffer;
    media_codec_output_buffer_info_t info;
    mc_inter_status_t status;
    ASSERT_NE(ctx, nullptr);
    ASSERT_NE(ctx->context, nullptr);
    ASSERT_NE(ctx->outFile, nullptr);
    context = ctx->context;

    pollFd = ctx->pollDecFd;
    ASSERT_GT(pollFd, 0);

    do {
        FD_ZERO(&readFds);
        FD_SET(pollFd, &readFds);
        t1 = get_system_time_ms();
        printf("%s[%d:%d] start select: %5f\n", TAG, getpid(), gettid(), t1);
        ret = select(pollFd+1, &readFds, NULL, NULL, NULL);
        t2 = get_system_time_ms();
        printf("%s[%d:%d] select cost: %5f\n", TAG, getpid(), gettid(), t2 -t1);
        if (ret < 0) {
            printf("%s[%d:%d] Failed to select fd = %d.(err %s)\n", TAG, getpid(), gettid(), pollFd, strerror(errno));
            ctx->abnormal = TRUE;
            break;
        } else if (ret == 0) {
            printf("%s[%d:%d] Time out to select fd = %d.\n", TAG, getpid(), gettid(), pollFd);
            ctx->abnormal = TRUE;
            break;
        } else {
            if (FD_ISSET(pollFd, &readFds)) {
                if (ctx->testLog) {
                    printf("%s[%d:%d] Step %d dequeue output\n", TAG, getpid(), gettid(), step++);
                }
                // process output buffers
                ASSERT_EQ(hb_mm_mc_get_status(context, &status), (int32_t)0);
                if (ctx->testLog) {
                    printf("%s[%d:%d] output count %d input count %d\n",
                    TAG, getpid(), gettid(), status.cur_output_buf_cnt, status.cur_input_buf_cnt);
                }
                //while (status.cur_output_buf_cnt--) {
                    memset(&outputBuffer, 0x00, sizeof(media_codec_buffer_t));
                    memset(&info, 0x00, sizeof(media_codec_output_buffer_info_t));
                    ret = hb_mm_mc_dequeue_output_buffer(context, &outputBuffer, &info, 1000);
                    //EXPECT_EQ(ret, (int32_t)0);
                    if (!ret) {
                        if (ctx->testLog) {
                            printf("%s[%d:%d] output bufferviraddr %p phy addr %x, size = %d, outFile = %p\n",
                                TAG, getpid(), gettid(), outputBuffer.vframe_buf.vir_ptr[0],
                                outputBuffer.vframe_buf.phy_ptr[0],
                                outputBuffer.vframe_buf.size, ctx->outFile);
                        }
                        if (ctx->testLog) {
                            printf("%s[%d:%d] Step %d write output file\n", TAG, getpid(), gettid(), step++);
                        }
                        ASSERT_EQ(write_output_frames(ctx, &outputBuffer), 0);
                        if (ctx->testLog) {
                            printf("%s[%d:%d] Step %d queue output\n", TAG, getpid(), gettid(), step++);
                        }
                        ASSERT_EQ(do_decode_params_checking(ctx, &outputBuffer), 0);

                        ret = hb_mm_mc_queue_output_buffer(context, &outputBuffer, 100);
                        EXPECT_EQ(ret, (int32_t)0);
                        if (outputBuffer.vframe_buf.frame_end) {
                            printf("%s[%d:%d] There is no more output data!\n",
                                TAG, getpid(), gettid());
                            ctx->lastFrame = 1;
                            break;
                        }
                        if (ret) {
                            break;
                        }
                    } else {
                        printf("%s[%d:%d] dequeue output buffer fail.\n", TAG, getpid(), gettid());
                        if (ret == (int32_t)HB_MEDIA_ERR_UNKNOWN
                            || ret == (int32_t)HB_MEDIA_ERR_OPERATION_NOT_ALLOWED) {
                            ctx->abnormal = TRUE;
                            break;
                        }
                    }
                //  ASSERT_EQ(hb_mm_mc_get_status(context, &status), (int32_t)0);
                //}
            }
        }
    } while (!ctx->lastFrame && !ctx->abnormal);
    printf("%s[%d:%d] Quit thread %s.\n", TAG, getpid(), gettid(), __FUNCTION__);

    ASSERT_EQ(hb_mm_mc_close_fd(context, pollFd), 0);
}

static void do_poll_decoding(void *arg) {
    pthread_t thread_id;
    void* retVal;
    hb_s32 ret = 0;
    int step = 0;
    MediaCodecTestContext *ctx = (MediaCodecTestContext *)arg;
    media_codec_context_t *context;
    media_codec_buffer_t inputBuffer;
    Uint64 queueTime = 0, intervalTime = 0;

    ctx->workMode = THREAD_WORK_MODE_POLL;
    ASSERT_EQ(check_and_init_test(ctx), 0);
    context = ctx->context;

    //get start time
    ctx->testStartTime = osal_gettime();

    if (ctx->testLog) {
        printf("%s[%d:%d] Step %d initialize(outFile=%s)\n",
            TAG, getpid(), gettid(), step++, ctx->outputFileName);
    }
    ret = hb_mm_mc_initialize(context);
    ASSERT_EQ(ret, (int32_t)0);

    if (ctx->testLog) {
        printf("%s[%d:%d] Step %d configure\n", TAG, getpid(), gettid(), step++);
    }
    ret = hb_mm_mc_configure(context);
    ASSERT_EQ(ret, (int32_t)0);

    if (ctx->testLog) {
        printf("%s[%d:%d] Step %d start\n", TAG, getpid(), gettid(), step++);
    }
    mc_av_codec_startup_params_t startup_params;
    memset(&startup_params, 0x00, sizeof(mc_av_codec_startup_params_t));
    ret = hb_mm_mc_start(context, &startup_params);
    EXPECT_EQ(ret, (int32_t)0);

    ASSERT_EQ(hb_mm_mc_get_fd(context, &ctx->pollDecFd), 0);
    pthread_create(&thread_id, NULL, (void* (*)(void*))do_poll_decoding_select, ctx);

    do {
        if (ctx->testLog) {
            printf("%s[%d:%d] Step %d dequeue input\n", TAG, getpid(), gettid(), step++);
        }
        // process input buffers
        ret = hb_mm_mc_dequeue_input_buffer(context, &inputBuffer, 3000);
        //EXPECT_EQ(ret, (int32_t)0);
        if (!ret) {
            if (ctx->testLog) {
                printf("%s[%d:%d] input buffer viraddr %p phy addr %x, size = %d\n",
                    TAG, getpid(), gettid(), inputBuffer.vstream_buf.vir_ptr,
                    inputBuffer.vstream_buf.phy_ptr,
                    inputBuffer.vstream_buf.size);
            }

            if (ctx->testLog) {
                printf("%s[%d:%d] Step %d feed input\n", TAG, getpid(), gettid(), step++);
            }

            ret = read_input_streams(ctx, &inputBuffer);
            if (ret <= 0) {
                printf("%s[%d:%d] There is no more input data(ret=%d)!\n",
                    TAG, getpid(), gettid(), ret);
                inputBuffer.vstream_buf.stream_end = TRUE;
                inputBuffer.vstream_buf.size = 0;
                ctx->lastStream = 1;
            }

            //EXPECT_EQ(ret, (int32_t)TRUE);
            if (ctx->testLog) {
                printf("%s[%d:%d] Step %d queue input\n", TAG, getpid(), gettid(), step++);
            }
            if (ctx->frametime > 0) {
                if (queueTime > 0) {
                    intervalTime = osal_gettimeus() - queueTime;
                    printf("%s interval time %lld\n", TAG, intervalTime);
                    if (intervalTime < ctx->frametime) {
                        usleep(ctx->frametime - intervalTime);
                    }
                }
            }
            ret = hb_mm_mc_queue_input_buffer(context, &inputBuffer, 100);
            EXPECT_EQ(ret, (int32_t)0);
            if (ret != 0) {
                break;
            }
            if (ctx->frametime > 0) {
                queueTime = osal_gettimeus();
            }
        } else {
            printf("%s[%d:%d] dequeue input buffer fail\n", TAG, getpid(), gettid());
            if (ret == (int32_t)HB_MEDIA_ERR_UNKNOWN
                || ret == (int32_t)HB_MEDIA_ERR_OPERATION_NOT_ALLOWED) {
                ctx->abnormal = TRUE;
                break;
            }
        }
    }while(!ctx->lastStream && !ctx->abnormal);

    pthread_join(thread_id, &retVal);
    printf("%s[%d:%d] thread return = %ld\n", TAG, getpid(), gettid(), (intptr_t)retVal);

    ret = hb_mm_mc_stop(context);
    EXPECT_EQ(ret, (int32_t)0);

    ret = hb_mm_mc_release(context);
    EXPECT_EQ(ret, (int32_t)0);

    ASSERT_EQ(check_and_release_test(ctx), 0);
}

static media_codec_id_t get_codec_id(int32_t testCodec) {
    return testCodec == TEST_CODEC_ID_H265 ?
        MEDIA_CODEC_ID_H265 : MEDIA_CODEC_ID_H264;
}

static int get_rc_params(media_codec_context_t *context,
            mc_rate_control_params_t *rc_params) {
    int ret = 0;
    ret = hb_mm_mc_get_rate_control_config(context, rc_params);
    if (ret) {
        printf("%s Failed to get rc params ret=0x%x\n", TAG, ret);
        return ret;
    }
    switch (rc_params->mode) {
    case MC_AV_RC_MODE_H264CBR:
        rc_params->h264_cbr_params.intra_period = 30;
        rc_params->h264_cbr_params.intra_qp = 30;
        rc_params->h264_cbr_params.bit_rate = 5000;
        rc_params->h264_cbr_params.frame_rate = 30;
        rc_params->h264_cbr_params.initial_rc_qp = 20;
        rc_params->h264_cbr_params.vbv_buffer_size = 20;
        rc_params->h264_cbr_params.mb_level_rc_enalbe = 1;
        rc_params->h264_cbr_params.min_qp_I = 8;
        rc_params->h264_cbr_params.max_qp_I = 50;
        rc_params->h264_cbr_params.min_qp_P = 8;
        rc_params->h264_cbr_params.max_qp_P = 50;
        rc_params->h264_cbr_params.min_qp_B = 8;
        rc_params->h264_cbr_params.max_qp_B = 50;
        rc_params->h264_cbr_params.hvs_qp_enable = 1;
        rc_params->h264_cbr_params.hvs_qp_scale = 2;
        rc_params->h264_cbr_params.max_delta_qp = 10;
        rc_params->h264_cbr_params.qp_map_enable = 0;
        break;
    case MC_AV_RC_MODE_H264VBR:
        rc_params->h264_vbr_params.intra_qp = 20;
        rc_params->h264_vbr_params.intra_period = 30;
        rc_params->h264_vbr_params.intra_qp = 35;
        break;
    case MC_AV_RC_MODE_H264AVBR:
        rc_params->h264_avbr_params.intra_period = 15;
        rc_params->h264_avbr_params.intra_qp = 25;
        rc_params->h264_avbr_params.bit_rate = 2000;
        rc_params->h264_avbr_params.vbv_buffer_size = 3000;
        rc_params->h264_avbr_params.min_qp_I = 15;
        rc_params->h264_avbr_params.max_qp_I = 50;
        rc_params->h264_avbr_params.min_qp_P = 15;
        rc_params->h264_avbr_params.max_qp_P = 45;
        rc_params->h264_avbr_params.min_qp_B = 15;
        rc_params->h264_avbr_params.max_qp_B = 48;
        rc_params->h264_avbr_params.hvs_qp_enable = 0;
        rc_params->h264_avbr_params.hvs_qp_scale = 2;
        rc_params->h264_avbr_params.max_delta_qp = 5;
        rc_params->h264_avbr_params.qp_map_enable = 0;
        break;
    case MC_AV_RC_MODE_H264FIXQP:
        rc_params->h264_fixqp_params.force_qp_I = 23;
        rc_params->h264_fixqp_params.force_qp_P = 23;
        rc_params->h264_fixqp_params.force_qp_B = 23;
        rc_params->h264_fixqp_params.intra_period = 23;
        break;
    case MC_AV_RC_MODE_H264QPMAP:
        break;
    case MC_AV_RC_MODE_H265CBR:
        rc_params->h265_cbr_params.intra_period = 20;
        rc_params->h265_cbr_params.intra_qp = 30;
        rc_params->h265_cbr_params.bit_rate = 5000;
        rc_params->h265_cbr_params.frame_rate = 30;
        if (context->video_enc_params.width >= 480 ||
            context->video_enc_params.height >= 480) {
            rc_params->h265_cbr_params.initial_rc_qp = 30;
            rc_params->h265_cbr_params.vbv_buffer_size = 3000;
            rc_params->h265_cbr_params.ctu_level_rc_enalbe = 1;
        } else {
            rc_params->h265_cbr_params.initial_rc_qp = 20;
            rc_params->h265_cbr_params.vbv_buffer_size = 20;
            rc_params->h265_cbr_params.ctu_level_rc_enalbe = 1;
        }
        rc_params->h265_cbr_params.min_qp_I = 8;
        rc_params->h265_cbr_params.max_qp_I = 50;
        rc_params->h265_cbr_params.min_qp_P = 8;
        rc_params->h265_cbr_params.max_qp_P = 50;
        rc_params->h265_cbr_params.min_qp_B = 8;
        rc_params->h265_cbr_params.max_qp_B = 50;
        rc_params->h265_cbr_params.hvs_qp_enable = 1;
        rc_params->h265_cbr_params.hvs_qp_scale = 2;
        rc_params->h265_cbr_params.max_delta_qp = 10;
        rc_params->h265_cbr_params.qp_map_enable = 0;
        break;
    case MC_AV_RC_MODE_H265VBR:
        rc_params->h265_vbr_params.intra_qp = 20;
        rc_params->h265_vbr_params.intra_period = 30;
        rc_params->h265_vbr_params.intra_qp = 35;
        break;
    case MC_AV_RC_MODE_H265AVBR:
        rc_params->h265_avbr_params.intra_period = 15;
        rc_params->h265_avbr_params.intra_qp = 25;
        rc_params->h265_avbr_params.bit_rate = 2000;
        rc_params->h265_avbr_params.vbv_buffer_size = 3000;
        rc_params->h265_avbr_params.min_qp_I = 15;
        rc_params->h265_avbr_params.max_qp_I = 50;
        rc_params->h265_avbr_params.min_qp_P = 15;
        rc_params->h265_avbr_params.max_qp_P = 45;
        rc_params->h265_avbr_params.min_qp_B = 15;
        rc_params->h265_avbr_params.max_qp_B = 48;
        rc_params->h265_avbr_params.hvs_qp_enable = 0;
        rc_params->h265_avbr_params.hvs_qp_scale = 2;
        rc_params->h265_avbr_params.max_delta_qp = 5;
        rc_params->h265_avbr_params.qp_map_enable = 0;
        break;
    case MC_AV_RC_MODE_H265FIXQP:
        rc_params->h265_fixqp_params.force_qp_I = 23;
        rc_params->h265_fixqp_params.force_qp_P = 23;
        rc_params->h265_fixqp_params.force_qp_B = 23;
        rc_params->h265_fixqp_params.intra_period = 23;
        break;
    case MC_AV_RC_MODE_H265QPMAP:
        break;
    default:
        ret = HB_MEDIA_ERR_INVALID_PARAMS;
        break;
    }
    return ret;
}

TEST_F(MediaCodecTest, test_hb_mm_mc_get_descriptor) {
    // Test invalid parameters
    ASSERT_EQ(hb_mm_mc_get_descriptor(MEDIA_CODEC_ID_NONE), nullptr);
    ASSERT_EQ(hb_mm_mc_get_descriptor(MEDIA_CODEC_ID_TOTAL), nullptr);

    // Test common case
    for (int id=MEDIA_CODEC_ID_H264; id<MEDIA_CODEC_ID_AAC; id++) {
        ASSERT_NE(hb_mm_mc_get_descriptor((media_codec_id_t)id), nullptr);
    }
}

TEST_F(MediaCodecTest, test_hb_mm_mc_get_default_context) {
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    // Test invalid parameters
    ASSERT_EQ(hb_mm_mc_get_default_context(MEDIA_CODEC_ID_NONE,
        TRUE, context), (int32_t)HB_MEDIA_ERR_INVALID_PARAMS);
    ASSERT_EQ(hb_mm_mc_get_default_context(MEDIA_CODEC_ID_TOTAL,
        FALSE, context), (int32_t)HB_MEDIA_ERR_INVALID_PARAMS);
    ASSERT_EQ(hb_mm_mc_get_default_context(MEDIA_CODEC_ID_H264,
        FALSE, NULL), (int32_t)HB_MEDIA_ERR_INVALID_PARAMS);

    // Test common case
    for (int id=MEDIA_CODEC_ID_H264; id<MEDIA_CODEC_ID_AAC; id++) {
        ASSERT_EQ(hb_mm_mc_get_default_context((media_codec_id_t)id,
            FALSE, context), (int32_t)0);
        ASSERT_EQ(hb_mm_mc_get_default_context((media_codec_id_t)id,
            TRUE, context), (int32_t)0);
    }
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_hb_mm_mc_initialize) {
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    ASSERT_EQ(hb_mm_mc_get_default_context(context->codec_id,
        context->encoder, context), 0);

    // Test NULL parameters
    ASSERT_EQ(hb_mm_mc_initialize(NULL), (int32_t)HB_MEDIA_ERR_INVALID_PARAMS);

    // Test invalid parameters
    context->codec_id = MEDIA_CODEC_ID_NONE;
    ASSERT_EQ(hb_mm_mc_initialize(context), (int32_t)HB_MEDIA_ERR_INVALID_PARAMS);
    context->codec_id = MEDIA_CODEC_ID_TOTAL;
    ASSERT_EQ(hb_mm_mc_initialize(context), (int32_t)HB_MEDIA_ERR_INVALID_PARAMS);
    context->codec_id = mTestCodec == TEST_CODEC_ID_H265 ?
        MEDIA_CODEC_ID_H265 : MEDIA_CODEC_ID_H264;

    // Test normal case
    ASSERT_EQ(hb_mm_mc_initialize(context), 0);
    ASSERT_NE(context->instance_index, -1);

    // Test reinitialize
    ASSERT_EQ(hb_mm_mc_initialize(context),
        (int32_t)HB_MEDIA_ERR_OPERATION_NOT_ALLOWED);

    // Test modified instance_index
    int32_t tmp = context->instance_index;
    context->instance_index = 20;
    ASSERT_EQ(hb_mm_mc_initialize(context), (int32_t)HB_MEDIA_ERR_INVALID_INSTANCE);

    context->instance_index = tmp;
    ASSERT_EQ(hb_mm_mc_release(context), (int32_t)0);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_hb_mm_mc_set_callback) {
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    ASSERT_EQ(hb_mm_mc_get_default_context(context->codec_id,
        context->encoder, context), 0);

    media_codec_callback_t userCb;
    userCb.on_input_buffer_available = on_encoder_input_buffer_available;
    userCb.on_output_buffer_available = on_encoder_output_buffer_available;
    userCb.on_media_codec_message = on_encoder_media_codec_message;
    MediaCodecTestContext asyncCtx;
    memset(&asyncCtx, 0x00, sizeof(MediaCodecTestContext));
    asyncCtx.context = context;

    // Test before initialization
    ASSERT_EQ(hb_mm_mc_set_callback(context, &userCb, &asyncCtx),
        (int32_t)HB_MEDIA_ERR_OPERATION_NOT_ALLOWED);

    ASSERT_EQ(hb_mm_mc_initialize(context), 0);
    // Test invalid parameters
    ASSERT_EQ(hb_mm_mc_set_callback(NULL, &userCb, &asyncCtx),
        (int32_t)HB_MEDIA_ERR_INVALID_PARAMS);
    ASSERT_EQ(hb_mm_mc_set_callback(context, NULL, &asyncCtx),
        (int32_t)HB_MEDIA_ERR_INVALID_PARAMS);
    ASSERT_EQ(hb_mm_mc_set_callback(context, &userCb, NULL),
        (int32_t)HB_MEDIA_ERR_INVALID_PARAMS);

    // Test normal case
    ASSERT_EQ(hb_mm_mc_set_callback(context, &userCb, &asyncCtx),
        (int32_t)0);

    // Test setting again
    asyncCtx.lastStream = FALSE;
    ASSERT_EQ(hb_mm_mc_set_callback(context, &userCb, &asyncCtx),
        (int32_t)0);

    // Test modified instance_index
    int32_t tmp = context->instance_index;
    context->instance_index = -1;
    ASSERT_EQ(hb_mm_mc_set_callback(context, &userCb, &asyncCtx),
        (int32_t)HB_MEDIA_ERR_INVALID_INSTANCE);

    context->instance_index = tmp;
    ASSERT_EQ(hb_mm_mc_release(context), (int32_t)0);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_hb_mm_mc_configure) {
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    media_codec_callback_t userCb;
    userCb.on_input_buffer_available = on_encoder_input_buffer_available;
    userCb.on_output_buffer_available = on_encoder_output_buffer_available;
    userCb.on_media_codec_message = on_encoder_media_codec_message;
    MediaCodecTestContext asyncCtx;
    memset(&asyncCtx, 0x00, sizeof(MediaCodecTestContext));
    asyncCtx.context = context;

    // Test before initialization
    ASSERT_EQ(hb_mm_mc_configure(context),
        (int32_t)HB_MEDIA_ERR_OPERATION_NOT_ALLOWED);

    ASSERT_EQ(hb_mm_mc_initialize(context), 0);
    ASSERT_EQ(hb_mm_mc_set_callback(context, &userCb, &asyncCtx),
        (int32_t)0);

    // Test invalid parameters
    ASSERT_EQ(hb_mm_mc_configure(NULL),
        (int32_t)HB_MEDIA_ERR_INVALID_PARAMS);
    int32_t tmp = context->instance_index;
    context->instance_index = -1;
    ASSERT_EQ(hb_mm_mc_configure(context),
        (int32_t)HB_MEDIA_ERR_INVALID_INSTANCE);
    context->instance_index = tmp;

    // Test normal case
    ASSERT_EQ(hb_mm_mc_configure(context), (int32_t)0);

    // Test configuration again
    ASSERT_EQ(hb_mm_mc_configure(context),
        (int32_t)HB_MEDIA_ERR_OPERATION_NOT_ALLOWED);

    ASSERT_EQ(hb_mm_mc_release(context), (int32_t)0);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_hb_mm_mc_start) {
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id =  get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree= MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    media_codec_callback_t userCb;
    userCb.on_input_buffer_available = on_encoder_input_buffer_available;
    userCb.on_output_buffer_available = on_encoder_output_buffer_available;
    userCb.on_media_codec_message = on_encoder_media_codec_message;
    MediaCodecTestContext asyncCtx;
    memset(&asyncCtx, 0x00, sizeof(MediaCodecTestContext));
    asyncCtx.context = context;

    // Test before initialization
    mc_av_codec_startup_params_t startup_params;
    startup_params.video_enc_startup_params.receive_frame_number = 0;
    ASSERT_EQ(hb_mm_mc_start(context, &startup_params),
        (int32_t)HB_MEDIA_ERR_OPERATION_NOT_ALLOWED);

    ASSERT_EQ(hb_mm_mc_initialize(context), 0);
    ASSERT_EQ(hb_mm_mc_set_callback(context, &userCb, &asyncCtx),
        (int32_t)0);
    ASSERT_EQ(hb_mm_mc_configure(context), (int32_t)0);

    // Test invalid parameters
    ASSERT_EQ(hb_mm_mc_start(NULL, NULL),
        (int32_t)HB_MEDIA_ERR_INVALID_PARAMS);
    int32_t tmp = context->instance_index;
    context->instance_index = -1;
    ASSERT_EQ(hb_mm_mc_start(context, NULL),
        (int32_t)HB_MEDIA_ERR_INVALID_INSTANCE);
    context->instance_index = tmp;

    // Test normal case
    ASSERT_EQ(hb_mm_mc_start(context, NULL), (int32_t)0);

    // Test configuration again
    ASSERT_EQ(hb_mm_mc_start(context, NULL),
        (int32_t)HB_MEDIA_ERR_OPERATION_NOT_ALLOWED);

    ASSERT_EQ(hb_mm_mc_release(context), (int32_t)0);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_hb_mm_mc_stop) {
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    media_codec_callback_t userCb;
    userCb.on_input_buffer_available = on_encoder_input_buffer_available;
    userCb.on_output_buffer_available = on_encoder_output_buffer_available;
    userCb.on_media_codec_message = on_encoder_media_codec_message;
    MediaCodecTestContext asyncCtx;
    memset(&asyncCtx, 0x00, sizeof(MediaCodecTestContext));
    asyncCtx.context = context;

    // Test before initialization
    ASSERT_EQ(hb_mm_mc_stop(context),
        (int32_t)HB_MEDIA_ERR_OPERATION_NOT_ALLOWED);

    ASSERT_EQ(hb_mm_mc_initialize(context), 0);
    ASSERT_EQ(hb_mm_mc_set_callback(context, &userCb, &asyncCtx),
        (int32_t)0);
    ASSERT_EQ(hb_mm_mc_configure(context), (int32_t)0);
    ASSERT_EQ(hb_mm_mc_start(context, NULL), (int32_t)0);

    // Test invalid parameters
    ASSERT_EQ(hb_mm_mc_stop(NULL),
        (int32_t)HB_MEDIA_ERR_INVALID_PARAMS);
    int32_t tmp = context->instance_index;
    context->instance_index = -1;
    ASSERT_EQ(hb_mm_mc_stop(context),
        (int32_t)HB_MEDIA_ERR_INVALID_INSTANCE);
    context->instance_index = tmp;

    // Test normal case
    ASSERT_EQ(hb_mm_mc_stop(context), (int32_t)0);

    // Test configuration again
    ASSERT_EQ(hb_mm_mc_stop(context),
        (int32_t)HB_MEDIA_ERR_OPERATION_NOT_ALLOWED);

    ASSERT_EQ(hb_mm_mc_release(context), (int32_t)0);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_hb_mm_mc_pause) {
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    media_codec_callback_t userCb;
    userCb.on_input_buffer_available = on_encoder_input_buffer_available;
    userCb.on_output_buffer_available = on_encoder_output_buffer_available;
    userCb.on_media_codec_message = on_encoder_media_codec_message;
    MediaCodecTestContext asyncCtx;
    memset(&asyncCtx, 0x00, sizeof(MediaCodecTestContext));
    asyncCtx.context = context;

    // Test before initialization
    ASSERT_EQ(hb_mm_mc_pause(context),
        (int32_t)HB_MEDIA_ERR_OPERATION_NOT_ALLOWED);

    ASSERT_EQ(hb_mm_mc_initialize(context), 0);
    ASSERT_EQ(hb_mm_mc_set_callback(context, &userCb, &asyncCtx),
        (int32_t)0);
    ASSERT_EQ(hb_mm_mc_configure(context), (int32_t)0);
    ASSERT_EQ(hb_mm_mc_start(context, NULL), (int32_t)0);

    // Test invalid parameters
    ASSERT_EQ(hb_mm_mc_pause(NULL),
        (int32_t)HB_MEDIA_ERR_INVALID_PARAMS);
    int32_t tmp = context->instance_index;
    context->instance_index = -1;
    ASSERT_EQ(hb_mm_mc_pause(context),
        (int32_t)HB_MEDIA_ERR_INVALID_INSTANCE);
    context->instance_index = tmp;

    // Test normal case
    ASSERT_EQ(hb_mm_mc_pause(context), (int32_t)0);

    // Test configuration again
    ASSERT_EQ(hb_mm_mc_pause(context),
        (int32_t)HB_MEDIA_ERR_OPERATION_NOT_ALLOWED);

    ASSERT_EQ(hb_mm_mc_release(context), (int32_t)0);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_hb_mm_mc_flush) {
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    // Test before initialization
    ASSERT_EQ(hb_mm_mc_flush(context),
        (int32_t)HB_MEDIA_ERR_OPERATION_NOT_ALLOWED);

    ASSERT_EQ(hb_mm_mc_initialize(context), 0);
    ASSERT_EQ(hb_mm_mc_configure(context), (int32_t)0);
    ASSERT_EQ(hb_mm_mc_start(context, NULL), (int32_t)0);

    // Test invalid parameters
    ASSERT_EQ(hb_mm_mc_flush(NULL),
        (int32_t)HB_MEDIA_ERR_INVALID_PARAMS);
    int32_t tmp = context->instance_index;
    context->instance_index = -1;
    ASSERT_EQ(hb_mm_mc_flush(context),
        (int32_t)HB_MEDIA_ERR_INVALID_INSTANCE);
    context->instance_index = tmp;

    // Test normal case
    ASSERT_EQ(hb_mm_mc_flush(context), (int32_t)0);

    // Test configuration again
    ASSERT_EQ(hb_mm_mc_flush(context), (int32_t)0);

    ASSERT_EQ(hb_mm_mc_release(context), (int32_t)0);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_hb_mm_mc_release) {
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    media_codec_callback_t userCb;
    userCb.on_input_buffer_available = on_encoder_input_buffer_available;
    userCb.on_output_buffer_available = on_encoder_output_buffer_available;
    userCb.on_media_codec_message = on_encoder_media_codec_message;
    MediaCodecTestContext asyncCtx;
    memset(&asyncCtx, 0x00, sizeof(MediaCodecTestContext));
    asyncCtx.context = context;

    // Test before initialization
    ASSERT_EQ(hb_mm_mc_release(context),
        (int32_t)HB_MEDIA_ERR_OPERATION_NOT_ALLOWED);

    ASSERT_EQ(hb_mm_mc_initialize(context), 0);
    ASSERT_EQ(hb_mm_mc_set_callback(context, &userCb, &asyncCtx),
        (int32_t)0);
    ASSERT_EQ(hb_mm_mc_configure(context), (int32_t)0);
    ASSERT_EQ(hb_mm_mc_start(context, NULL), (int32_t)0);

    // Test invalid parameters
    ASSERT_EQ(hb_mm_mc_release(NULL),
        (int32_t)HB_MEDIA_ERR_INVALID_PARAMS);
    int32_t tmp = context->instance_index;
    context->instance_index = -1;
    ASSERT_EQ(hb_mm_mc_release(context),
        (int32_t)HB_MEDIA_ERR_INVALID_INSTANCE);
    context->instance_index = tmp;

    // Test normal case
    ASSERT_EQ(hb_mm_mc_release(context), (int32_t)0);

    // Test configuration again
    ASSERT_EQ(hb_mm_mc_release(context),
        (int32_t)HB_MEDIA_ERR_OPERATION_NOT_ALLOWED);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_hb_mm_mc_get_state) {
    media_codec_state_t state = MEDIA_CODEC_STATE_NONE;
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    /*media_codec_callback_t userCb;
    userCb.on_input_buffer_available = on_encoder_input_buffer_available;
    userCb.on_output_buffer_available = on_encoder_output_buffer_available;
    userCb.on_media_codec_message = on_encoder_media_codec_message;*/

    // Test before initialization
    ASSERT_EQ(hb_mm_mc_get_state(context, NULL),
        (int32_t)HB_MEDIA_ERR_INVALID_PARAMS);
    ASSERT_EQ(hb_mm_mc_get_state(context, &state), (int32_t)0);
    ASSERT_EQ(state, (int32_t)MEDIA_CODEC_STATE_UNINITIALIZED);

    ASSERT_EQ(hb_mm_mc_initialize(context), 0);
    ASSERT_EQ(hb_mm_mc_get_state(context, &state), (int32_t)0);
    ASSERT_EQ(state, (int32_t)MEDIA_CODEC_STATE_INITIALIZED);

    //ASSERT_EQ(hb_mm_mc_set_callback(context, &userCb, &asyncCtx),
    //    (int32_t)0);
    ASSERT_EQ(hb_mm_mc_get_state(context, &state), (int32_t)0);
    ASSERT_EQ(state, (int32_t)MEDIA_CODEC_STATE_INITIALIZED);

    ASSERT_EQ(hb_mm_mc_configure(context), (int32_t)0);
    ASSERT_EQ(hb_mm_mc_get_state(context, &state), (int32_t)0);
    ASSERT_EQ(state, (int32_t)MEDIA_CODEC_STATE_CONFIGURED);

    ASSERT_EQ(hb_mm_mc_start(context, NULL), (int32_t)0);
    ASSERT_EQ(hb_mm_mc_get_state(context, &state), (int32_t)0);
    ASSERT_EQ(state, (int32_t)MEDIA_CODEC_STATE_STARTED);

    ASSERT_EQ(hb_mm_mc_flush(context), (int32_t)0);
    ASSERT_EQ(hb_mm_mc_get_state(context, &state), (int32_t)0);
    ASSERT_EQ(state, (int32_t)MEDIA_CODEC_STATE_STARTED);

    ASSERT_EQ(hb_mm_mc_pause(context), (int32_t)0);
    ASSERT_EQ(hb_mm_mc_get_state(context, &state), (int32_t)0);
    ASSERT_EQ(state, (int32_t)MEDIA_CODEC_STATE_PAUSED);

    ASSERT_EQ(hb_mm_mc_stop(context), (int32_t)0);
    ASSERT_EQ(hb_mm_mc_get_state(context, &state), (int32_t)0);
    ASSERT_EQ(state, (int32_t)MEDIA_CODEC_STATE_INITIALIZED);

    ASSERT_EQ(hb_mm_mc_release(context), (int32_t)0);
    ASSERT_EQ(hb_mm_mc_get_state(context, &state), (int32_t)0);
    ASSERT_EQ(state, (int32_t)MEDIA_CODEC_STATE_UNINITIALIZED);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_hb_mm_mc_get_status) {
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    // Test before initialization
    mc_inter_status_t status = {0,};
    ASSERT_EQ(hb_mm_mc_get_status(context, &status),
        (int32_t)HB_MEDIA_ERR_OPERATION_NOT_ALLOWED);

    ASSERT_EQ(hb_mm_mc_initialize(context), 0);
    ASSERT_EQ(hb_mm_mc_get_status(context, &status), (int32_t)0);

    ASSERT_EQ(hb_mm_mc_configure(context), (int32_t)0);
    ASSERT_EQ(hb_mm_mc_get_status(context, &status), (int32_t)0);

    ASSERT_EQ(hb_mm_mc_start(context, NULL), (int32_t)0);
    ASSERT_EQ(hb_mm_mc_get_status(context, &status), (int32_t)0);

    ASSERT_EQ(hb_mm_mc_flush(context), (int32_t)0);
    ASSERT_EQ(hb_mm_mc_get_status(context, &status), (int32_t)0);

    ASSERT_EQ(hb_mm_mc_pause(context), (int32_t)0);
    ASSERT_EQ(hb_mm_mc_get_status(context, &status), (int32_t)0);

    ASSERT_EQ(hb_mm_mc_stop(context), (int32_t)0);
    ASSERT_EQ(hb_mm_mc_get_status(context, &status), (int32_t)0);

    ASSERT_EQ(hb_mm_mc_release(context), (int32_t)0);
    ASSERT_EQ(hb_mm_mc_get_status(context, &status),
        (int32_t)HB_MEDIA_ERR_OPERATION_NOT_ALLOWED);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_hb_mm_mc_dequeue_input_buffer) {
    FILE *outputFp;
    FILE *inputFp;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    //AVFormatContext *avFmtCtx = NULL;
    //ASSERT_EQ(avformat_open_input(&avFmtCtx, inputFileName, NULL, NULL), 0);
    //ASSERT_EQ(avformat_find_stream_info(avFmtCtx, NULL), 0);
    //ASSERT_GT(avFmtCtx->nb_streams, 1);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    printf("%s InputFileName = %s\n", TAG, inputFileName);
    printf("%s OutputFileName = %s\n", TAG, outputFileName);

    outputFp = fopen(outputFileName, "wb");
    ASSERT_NE(outputFp, nullptr);
    inputFp = fopen(inputFileName, "rb");
    ASSERT_NE(inputFp, nullptr);

    media_codec_buffer_t inputBuffer;
    memset(&inputBuffer, 0x00, sizeof(media_codec_buffer_t));
    ASSERT_EQ(hb_mm_mc_dequeue_input_buffer(context, &inputBuffer, 10000),
        (int32_t)HB_MEDIA_ERR_OPERATION_NOT_ALLOWED);


    ASSERT_EQ(hb_mm_mc_initialize(context), (int32_t)0);
    ASSERT_EQ(hb_mm_mc_configure(context), (int32_t)0);
    ASSERT_EQ(hb_mm_mc_start(context, NULL), (int32_t)0);

    for (hb_u32 i=0; i<params->frame_buf_count; i++) {
        EXPECT_EQ(hb_mm_mc_dequeue_input_buffer(context, &inputBuffer, 10000),
            (int32_t)0);
    }

    ASSERT_EQ(hb_mm_mc_release(context), (int32_t)0);
    if (inputFp) {
        fclose(inputFp);
    }
    if (outputFp) {
        fclose(outputFp);
    }
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_hb_mm_mc_queue_input_buffer) {
    FILE *outputFp;
    FILE *inputFp;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    //AVFormatContext *avFmtCtx = NULL;
    //ASSERT_EQ(avformat_open_input(&avFmtCtx, inputFileName, NULL, NULL), 0);
    //ASSERT_EQ(avformat_find_stream_info(avFmtCtx, NULL), 0);
    //ASSERT_GT(avFmtCtx->nb_streams, 1);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    printf("%s InputFileName = %s\n", TAG, inputFileName);
    printf("%s OutputFileName = %s\n", TAG, outputFileName);

    outputFp = fopen(outputFileName, "wb");
    ASSERT_NE(outputFp, nullptr);
    inputFp = fopen(inputFileName, "rb");
    ASSERT_NE(inputFp, nullptr);

    media_codec_buffer_t inputBuffer;
    memset(&inputBuffer, 0x00, sizeof(media_codec_buffer_t));
    ASSERT_EQ(hb_mm_mc_queue_input_buffer(context, &inputBuffer, -1),
        (int32_t)HB_MEDIA_ERR_OPERATION_NOT_ALLOWED);


    ASSERT_EQ(hb_mm_mc_initialize(context), (int32_t)0);
    ASSERT_EQ(hb_mm_mc_configure(context), (int32_t)0);
    ASSERT_EQ(hb_mm_mc_start(context, NULL), (int32_t)0);

    for (hb_u32 i=0; i<params->frame_buf_count; i++) {
        EXPECT_EQ(hb_mm_mc_dequeue_input_buffer(context, &inputBuffer, 10000),
            (int32_t)0);
        EXPECT_EQ(hb_mm_mc_queue_input_buffer(context, &inputBuffer, 10000),
            (int32_t)0);
    }

    ASSERT_EQ(hb_mm_mc_release(context), (int32_t)0);
    if (inputFp) {
        fclose(inputFp);
    }
    if (outputFp) {
        fclose(outputFp);
    }
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_hb_mm_mc_dequeue_output_buffer) {
    FILE *outputFp;
    FILE *inputFp;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    //AVFormatContext *avFmtCtx = NULL;
    //ASSERT_EQ(avformat_open_input(&avFmtCtx, inputFileName, NULL, NULL), 0);
    //ASSERT_EQ(avformat_find_stream_info(avFmtCtx, NULL), 0);
    //ASSERT_GT(avFmtCtx->nb_streams, 1);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    printf("%s InputFileName = %s\n", TAG, inputFileName);
    printf("%s OutputFileName = %s\n", TAG, outputFileName);

    outputFp = fopen(outputFileName, "wb");
    ASSERT_NE(outputFp, nullptr);
    inputFp = fopen(inputFileName, "rb");
    ASSERT_NE(inputFp, nullptr);

    media_codec_buffer_t inputBuffer;
    memset(&inputBuffer, 0x00, sizeof(media_codec_buffer_t));
    media_codec_buffer_t outputBuffer;
    memset(&outputBuffer, 0x00, sizeof(media_codec_buffer_t));
    ASSERT_EQ(hb_mm_mc_dequeue_output_buffer(context, &outputBuffer, NULL, -1),
        (int32_t)HB_MEDIA_ERR_OPERATION_NOT_ALLOWED);


    ASSERT_EQ(hb_mm_mc_initialize(context), (int32_t)0);
    ASSERT_EQ(hb_mm_mc_configure(context), (int32_t)0);
    ASSERT_EQ(hb_mm_mc_start(context, NULL), (int32_t)0);

    for (hb_u32 i=0; i<params->frame_buf_count; i++) {
        EXPECT_EQ(hb_mm_mc_dequeue_input_buffer(context, &inputBuffer, 10000),
            (int32_t)0);
        if (fread(inputBuffer.vframe_buf.vir_ptr[0], 1,
            inputBuffer.vframe_buf.size, inputFp) <= 0) {
            printf("%s no input data read.\n", TAG);
        }
        EXPECT_EQ(hb_mm_mc_queue_input_buffer(context, &inputBuffer, 10000),
            (int32_t)0);
    }
    EXPECT_EQ(hb_mm_mc_dequeue_output_buffer(context, &outputBuffer, NULL,10000),
        (int32_t)0);

    ASSERT_EQ(hb_mm_mc_release(context), (int32_t)0);
    if (inputFp) {
        fclose(inputFp);
    }
    if (outputFp) {
        fclose(outputFp);
    }
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_hb_mm_mc_queue_output_buffer) {
    FILE *outputFp;
    FILE *inputFp;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    //AVFormatContext *avFmtCtx = NULL;
    //ASSERT_EQ(avformat_open_input(&avFmtCtx, inputFileName, NULL, NULL), 0);
    //ASSERT_EQ(avformat_find_stream_info(avFmtCtx, NULL), 0);
    //ASSERT_GT(avFmtCtx->nb_streams, 1);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = params->frame_buf_count;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    printf("%s InputFileName = %s\n", TAG, inputFileName);
    printf("%s OutputFileName = %s\n", TAG, outputFileName);

    outputFp = fopen(outputFileName, "wb");
    ASSERT_NE(outputFp, nullptr);
    inputFp = fopen(inputFileName, "rb");
    ASSERT_NE(inputFp, nullptr);

    media_codec_buffer_t inputBuffer;
    memset(&inputBuffer, 0x00, sizeof(media_codec_buffer_t));
    media_codec_buffer_t outputBuffer;
    memset(&outputBuffer, 0x00, sizeof(media_codec_buffer_t));
    ASSERT_EQ(hb_mm_mc_dequeue_output_buffer(context, &outputBuffer, NULL, 10000),
        (int32_t)HB_MEDIA_ERR_OPERATION_NOT_ALLOWED);

    ASSERT_EQ(hb_mm_mc_initialize(context), (int32_t)0);
    ASSERT_EQ(hb_mm_mc_configure(context), (int32_t)0);
    ASSERT_EQ(hb_mm_mc_start(context, NULL), (int32_t)0);

    for (hb_u32 i=0; i<params->frame_buf_count; i++) {
        EXPECT_EQ(hb_mm_mc_dequeue_input_buffer(context, &inputBuffer, 10000),
            (int32_t)0);
        if (fread(inputBuffer.vframe_buf.vir_ptr[0], 1,
            inputBuffer.vframe_buf.size, inputFp) <= 0) {
            printf("%s no output data read.\n", TAG);
        }
        EXPECT_EQ(hb_mm_mc_queue_input_buffer(context, &inputBuffer, 100001),
            (int32_t)0);
    }
    for (hb_u32 i=0; i<params->frame_buf_count; i++) {
        EXPECT_EQ(hb_mm_mc_dequeue_output_buffer(context, &outputBuffer,  NULL, 10000),
            (int32_t)0);
        fwrite(outputBuffer.vstream_buf.vir_ptr, 1,
            outputBuffer.vstream_buf.size, outputFp);
        EXPECT_EQ(hb_mm_mc_queue_output_buffer(context, &outputBuffer, 10000),
            (int32_t)0);
    }

    ASSERT_EQ(hb_mm_mc_release(context), (int32_t)0);
    if (inputFp) {
        fclose(inputFp);
    }
    if (outputFp) {
        fclose(outputFp);
    }
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_hb_mm_mc_init_configure_start_stop_configure) {
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    ASSERT_EQ(hb_mm_mc_initialize(context), 0);
    ASSERT_EQ(hb_mm_mc_configure(context), (int32_t)0);
    ASSERT_EQ(hb_mm_mc_start(context, NULL), (int32_t)0);
    ASSERT_EQ(hb_mm_mc_stop(context), (int32_t)0);
    ASSERT_EQ(hb_mm_mc_configure(context), (int32_t)0);
    ASSERT_EQ(hb_mm_mc_release(context), (int32_t)0);
    if (context != NULL) {
        free(context);
    }
}

static int32_t compare_longterm_ref_mode(mc_video_longterm_ref_mode_t *a,
                mc_video_longterm_ref_mode_t *b) {
    EXPECT_EQ(a->use_longterm, b->use_longterm);
    EXPECT_EQ(a->longterm_pic_using_period, b->longterm_pic_using_period);
    EXPECT_EQ(a->longterm_pic_period, b->longterm_pic_period);
    if (a->use_longterm != b->use_longterm ||
        a->longterm_pic_using_period != b->longterm_pic_using_period ||
        a->longterm_pic_period != b->longterm_pic_period) {
        return -1;
    }
    return 0;
}

TEST_F(MediaCodecTest, test_hb_mm_mc_get_longterm_ref_mode) {
    hb_s32 ret = 0;
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    hb_s32 (*getFunc)(media_codec_context_t *context, mc_video_longterm_ref_mode_t *params) = hb_mm_mc_get_longterm_ref_mode;
    hb_s32 (*setFunc)(media_codec_context_t *context, const mc_video_longterm_ref_mode_t *params) = hb_mm_mc_set_longterm_ref_mode;

    // 1. Test the values before initialize
    mc_video_longterm_ref_mode_t test1;
    memset(&test1, 0x00, sizeof(mc_video_longterm_ref_mode_t));
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(test1.use_longterm, (uint32_t)FALSE);
    ASSERT_EQ(test1.longterm_pic_using_period, (uint32_t)0);
    ASSERT_EQ(test1.longterm_pic_period, (uint32_t)0);

    // 2. Set the values before initialize
    mc_video_longterm_ref_mode_t test0;
    memset(&test0, 0x00, sizeof(mc_video_longterm_ref_mode_t));
    ret = setFunc(context, &test0);
    ASSERT_NE(ret, (int32_t)0);

    ret = hb_mm_mc_initialize(context);
    ASSERT_EQ(ret, (int32_t)0);

    mc_video_longterm_ref_mode_t ref_mode;
    memset(&ref_mode, 0x00, sizeof(mc_video_longterm_ref_mode_t));
    ref_mode.use_longterm = TRUE;
    ref_mode.longterm_pic_using_period = 20;
    ref_mode.longterm_pic_period = 30;
    ret = setFunc(context, &ref_mode);
    ASSERT_EQ(ret, (int32_t)0);

    // 3. Test the values before configure
    memset(&test1, 0x00, sizeof(mc_video_longterm_ref_mode_t));
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(compare_longterm_ref_mode(&test1, &ref_mode), (int32_t)0);

    ret = hb_mm_mc_configure(context);
    ASSERT_EQ(ret, (int32_t)0);

    // 4. Test the values after configure
    memset(&test1, 0x00, sizeof(mc_video_longterm_ref_mode_t));
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(compare_longterm_ref_mode(&test1, &ref_mode), (int32_t)0);

    memset(&ref_mode, 0x00, sizeof(mc_video_longterm_ref_mode_t));
    ref_mode.use_longterm = TRUE;
    ref_mode.longterm_pic_using_period = 40;
    ref_mode.longterm_pic_period = 50;
    ret = setFunc(context, &ref_mode);
    ASSERT_EQ(ret, (int32_t)0);

    // 5. Test the values after configure again
    memset(&test1, 0x00, sizeof(mc_video_longterm_ref_mode_t));
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(compare_longterm_ref_mode(&test1, &ref_mode), (int32_t)0);

    memset(&ref_mode, 0x00, sizeof(mc_video_longterm_ref_mode_t));
    ref_mode.use_longterm = TRUE;
    ref_mode.longterm_pic_using_period = 30;
    ref_mode.longterm_pic_period = 60;
    ret = setFunc(context, &ref_mode);
    ASSERT_EQ(ret, (int32_t)0);

    // 6. Test the values after muti-setting
    memset(&test1, 0x00, sizeof(mc_video_longterm_ref_mode_t));
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(compare_longterm_ref_mode(&test1, &ref_mode), (int32_t)0);

    // TODO Add the test after start and pause
    ret = hb_mm_mc_stop(context);
    EXPECT_EQ(ret, (int32_t)0);

    ret = hb_mm_mc_release(context);
    EXPECT_EQ(ret, (int32_t)0);
    if (context != NULL) {
        free(context);
    }
}

static int32_t compare_intra_refresh(mc_video_intra_refresh_params_t *a,
                mc_video_intra_refresh_params_t *b) {
    EXPECT_EQ(a->intra_refresh_mode, b->intra_refresh_mode);
    EXPECT_EQ(a->intra_refresh_arg, b->intra_refresh_arg);
    if (a->intra_refresh_mode != b->intra_refresh_mode ||
        a->intra_refresh_arg != b->intra_refresh_arg) {
        return -1;
    }
    return 0;
}

TEST_F(MediaCodecTest, test_hb_mm_mc_get_intra_refresh_config) {
    hb_s32 ret = 0;
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    hb_s32 (*getFunc)(media_codec_context_t *context, mc_video_intra_refresh_params_t *params) = hb_mm_mc_get_intra_refresh_config;
    hb_s32 (*setFunc)(media_codec_context_t *context, const mc_video_intra_refresh_params_t *params) = hb_mm_mc_set_intra_refresh_config;

    // 1. Test the values before initialize
    mc_video_intra_refresh_params_t test1;
    memset(&test1, 0x00, sizeof(mc_video_intra_refresh_params_t));
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(test1.intra_refresh_mode, (int32_t)FALSE);
    ASSERT_EQ(test1.intra_refresh_arg, (uint32_t)0);

    // 2. Set the values before initialize
    mc_video_intra_refresh_params_t test2;
    memset(&test2, 0x00, sizeof(mc_video_intra_refresh_params_t));
    ret = setFunc(context, &test2);
    ASSERT_NE(ret, (int32_t)0);

    ret = hb_mm_mc_initialize(context);
    ASSERT_EQ(ret, (int32_t)0);

    mc_video_intra_refresh_params_t intra_ref;
    memset(&intra_ref, 0x00, sizeof(mc_video_intra_refresh_params_t));
    intra_ref.intra_refresh_mode = 1;
    intra_ref.intra_refresh_arg = 20;
    ret = setFunc(context, &intra_ref);
    ASSERT_EQ(ret, (int32_t)0);

    // 3. Test the values before configure
    memset(&test1, 0x00, sizeof(mc_video_intra_refresh_params_t));
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(compare_intra_refresh(&test1, &intra_ref), (int32_t)0);

    ret = hb_mm_mc_configure(context);
    ASSERT_EQ(ret, (int32_t)0);

    // 4. Test the values after configure
    memset(&test1, 0x00, sizeof(mc_video_intra_refresh_params_t));
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(compare_intra_refresh(&test1, &intra_ref), (int32_t)0);

    mc_video_intra_refresh_params_t intra_ref1;
    memset(&intra_ref1, 0x00, sizeof(mc_video_intra_refresh_params_t));
    intra_ref1.intra_refresh_mode = 2;
    intra_ref1.intra_refresh_arg = 60;
    ret = setFunc(context, &intra_ref1);
    ASSERT_NE(ret, (int32_t)0);

    // 5. Test the values after configure again
    memset(&test1, 0x00, sizeof(mc_video_intra_refresh_params_t));
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(compare_intra_refresh(&test1, &intra_ref), (int32_t)0);

    // TODO Add the test after start and pause
    ret = hb_mm_mc_stop(context);
    EXPECT_EQ(ret, (int32_t)0);

    ret = hb_mm_mc_release(context);
    EXPECT_EQ(ret, (int32_t)0);
    if (context != NULL) {
        free(context);
    }
}

static int compare_rc_params(mc_rate_control_params_t *a,
            mc_rate_control_params_t *b) {
    EXPECT_EQ(a->mode, b->mode);
    if (a->mode != b->mode) {
        return -1;
    }
    switch (a->mode) {
    case MC_AV_RC_MODE_H264CBR:
        EXPECT_EQ(a->h264_cbr_params.intra_period, b->h264_cbr_params.intra_period);
        EXPECT_EQ(a->h264_cbr_params.intra_qp, b->h264_cbr_params.intra_qp);
        EXPECT_EQ(a->h264_cbr_params.bit_rate, b->h264_cbr_params.bit_rate);
        EXPECT_EQ(a->h264_cbr_params.frame_rate, b->h264_cbr_params.frame_rate);
        EXPECT_EQ(a->h264_cbr_params.initial_rc_qp, b->h264_cbr_params.initial_rc_qp);
        EXPECT_EQ(a->h264_cbr_params.vbv_buffer_size, b->h264_cbr_params.vbv_buffer_size);
        EXPECT_EQ(a->h264_cbr_params.mb_level_rc_enalbe, b->h264_cbr_params.mb_level_rc_enalbe);
        EXPECT_EQ(a->h264_cbr_params.min_qp_I, b->h264_cbr_params.min_qp_I);
        EXPECT_EQ(a->h264_cbr_params.max_qp_I, b->h264_cbr_params.max_qp_I);
        EXPECT_EQ(a->h264_cbr_params.min_qp_P, b->h264_cbr_params.min_qp_P);
        EXPECT_EQ(a->h264_cbr_params.max_qp_P, b->h264_cbr_params.max_qp_P);
        EXPECT_EQ(a->h264_cbr_params.min_qp_B, b->h264_cbr_params.min_qp_B);
        EXPECT_EQ(a->h264_cbr_params.max_qp_B, b->h264_cbr_params.max_qp_B);
        EXPECT_EQ(a->h264_cbr_params.hvs_qp_enable, b->h264_cbr_params.hvs_qp_enable);
        EXPECT_EQ(a->h264_cbr_params.hvs_qp_scale, b->h264_cbr_params.hvs_qp_scale);
        EXPECT_EQ(a->h264_cbr_params.max_delta_qp, b->h264_cbr_params.max_delta_qp);
        EXPECT_EQ(a->h264_cbr_params.qp_map_enable, b->h264_cbr_params.qp_map_enable);
        break;
    case MC_AV_RC_MODE_H264VBR:
        EXPECT_EQ(a->h264_vbr_params.intra_period, b->h264_vbr_params.intra_period);
        EXPECT_EQ(a->h264_vbr_params.intra_qp, b->h264_vbr_params.intra_qp);
        EXPECT_EQ(a->h264_vbr_params.frame_rate, b->h264_vbr_params.frame_rate);
        EXPECT_EQ(a->h264_vbr_params.qp_map_enable, b->h264_vbr_params.qp_map_enable);
        break;
    case MC_AV_RC_MODE_H264AVBR:
        EXPECT_EQ(a->h264_avbr_params.intra_period, b->h264_avbr_params.intra_period);
        EXPECT_EQ(a->h264_avbr_params.intra_qp, b->h264_avbr_params.intra_qp);
        EXPECT_EQ(a->h264_avbr_params.bit_rate, b->h264_avbr_params.bit_rate);
        EXPECT_EQ(a->h264_avbr_params.frame_rate, b->h264_avbr_params.frame_rate);
        EXPECT_EQ(a->h264_avbr_params.initial_rc_qp, b->h264_avbr_params.initial_rc_qp);
        EXPECT_EQ(a->h264_avbr_params.vbv_buffer_size, b->h264_avbr_params.vbv_buffer_size);
        EXPECT_EQ(a->h264_avbr_params.mb_level_rc_enalbe, b->h264_avbr_params.mb_level_rc_enalbe);
        EXPECT_EQ(a->h264_avbr_params.min_qp_I, b->h264_avbr_params.min_qp_I);
        EXPECT_EQ(a->h264_avbr_params.max_qp_I, b->h264_avbr_params.max_qp_I);
        EXPECT_EQ(a->h264_avbr_params.min_qp_P, b->h264_avbr_params.min_qp_P);
        EXPECT_EQ(a->h264_avbr_params.max_qp_P, b->h264_avbr_params.max_qp_P);
        EXPECT_EQ(a->h264_avbr_params.min_qp_B, b->h264_avbr_params.min_qp_B);
        EXPECT_EQ(a->h264_avbr_params.max_qp_B, b->h264_avbr_params.max_qp_B);
        EXPECT_EQ(a->h264_avbr_params.hvs_qp_enable, b->h264_avbr_params.hvs_qp_enable);
        EXPECT_EQ(a->h264_avbr_params.hvs_qp_scale, b->h264_avbr_params.hvs_qp_scale);
        EXPECT_EQ(a->h264_avbr_params.max_delta_qp, b->h264_avbr_params.max_delta_qp);
        EXPECT_EQ(a->h264_avbr_params.qp_map_enable, b->h264_avbr_params.qp_map_enable);
        break;
    case MC_AV_RC_MODE_H264FIXQP:
        EXPECT_EQ(a->h264_fixqp_params.intra_period, b->h264_fixqp_params.intra_period);
        EXPECT_EQ(a->h264_fixqp_params.frame_rate, b->h264_fixqp_params.frame_rate);
        EXPECT_EQ(a->h264_fixqp_params.force_qp_I, b->h264_fixqp_params.force_qp_I);
        EXPECT_EQ(a->h264_fixqp_params.force_qp_P, b->h264_fixqp_params.force_qp_P);
        EXPECT_EQ(a->h264_fixqp_params.force_qp_B, b->h264_fixqp_params.force_qp_B);
        break;
    case MC_AV_RC_MODE_H264QPMAP:
        EXPECT_EQ(a->h264_qpmap_params.intra_period, b->h264_qpmap_params.intra_period);
        EXPECT_EQ(a->h264_qpmap_params.frame_rate, b->h264_qpmap_params.frame_rate);
        EXPECT_EQ(a->h264_qpmap_params.qp_map_array, b->h264_qpmap_params.qp_map_array);
        EXPECT_EQ(a->h264_qpmap_params.qp_map_array_count, b->h264_qpmap_params.qp_map_array_count);
        break;
    case MC_AV_RC_MODE_H265CBR:
        EXPECT_EQ(a->h265_cbr_params.intra_period, b->h265_cbr_params.intra_period);
        EXPECT_EQ(a->h265_cbr_params.intra_qp, b->h265_cbr_params.intra_qp);
        EXPECT_EQ(a->h265_cbr_params.bit_rate, b->h265_cbr_params.bit_rate);
        EXPECT_EQ(a->h265_cbr_params.frame_rate, b->h265_cbr_params.frame_rate);
        EXPECT_EQ(a->h265_cbr_params.initial_rc_qp, b->h265_cbr_params.initial_rc_qp);
        EXPECT_EQ(a->h265_cbr_params.vbv_buffer_size, b->h265_cbr_params.vbv_buffer_size);
        EXPECT_EQ(a->h265_cbr_params.ctu_level_rc_enalbe, b->h265_cbr_params.ctu_level_rc_enalbe);
        EXPECT_EQ(a->h265_cbr_params.min_qp_I, b->h265_cbr_params.min_qp_I);
        EXPECT_EQ(a->h265_cbr_params.max_qp_I, b->h265_cbr_params.max_qp_I);
        EXPECT_EQ(a->h265_cbr_params.min_qp_P, b->h265_cbr_params.min_qp_P);
        EXPECT_EQ(a->h265_cbr_params.max_qp_P, b->h265_cbr_params.max_qp_P);
        EXPECT_EQ(a->h265_cbr_params.min_qp_B, b->h265_cbr_params.min_qp_B);
        EXPECT_EQ(a->h265_cbr_params.max_qp_B, b->h265_cbr_params.max_qp_B);
        EXPECT_EQ(a->h265_cbr_params.hvs_qp_enable, b->h265_cbr_params.hvs_qp_enable);
        EXPECT_EQ(a->h265_cbr_params.hvs_qp_scale, b->h265_cbr_params.hvs_qp_scale);
        EXPECT_EQ(a->h265_cbr_params.max_delta_qp, b->h265_cbr_params.max_delta_qp);
        EXPECT_EQ(a->h265_cbr_params.qp_map_enable, b->h265_cbr_params.qp_map_enable);
        break;
    case MC_AV_RC_MODE_H265VBR:
        EXPECT_EQ(a->h265_vbr_params.intra_period, b->h265_vbr_params.intra_period);
        EXPECT_EQ(a->h265_vbr_params.intra_qp, b->h265_vbr_params.intra_qp);
        EXPECT_EQ(a->h265_vbr_params.frame_rate, b->h265_vbr_params.frame_rate);
        EXPECT_EQ(a->h265_vbr_params.qp_map_enable, b->h265_vbr_params.qp_map_enable);
        break;
    case MC_AV_RC_MODE_H265AVBR:
        EXPECT_EQ(a->h265_avbr_params.intra_period, b->h265_avbr_params.intra_period);
        EXPECT_EQ(a->h265_avbr_params.intra_qp, b->h265_avbr_params.intra_qp);
        EXPECT_EQ(a->h265_avbr_params.bit_rate, b->h265_avbr_params.bit_rate);
        EXPECT_EQ(a->h265_avbr_params.frame_rate, b->h265_avbr_params.frame_rate);
        EXPECT_EQ(a->h265_avbr_params.initial_rc_qp, b->h265_avbr_params.initial_rc_qp);
        EXPECT_EQ(a->h265_avbr_params.vbv_buffer_size, b->h265_avbr_params.vbv_buffer_size);
        EXPECT_EQ(a->h265_avbr_params.ctu_level_rc_enalbe, b->h265_avbr_params.ctu_level_rc_enalbe);
        EXPECT_EQ(a->h265_avbr_params.min_qp_I, b->h265_avbr_params.min_qp_I);
        EXPECT_EQ(a->h265_avbr_params.max_qp_I, b->h265_avbr_params.max_qp_I);
        EXPECT_EQ(a->h265_avbr_params.min_qp_P, b->h265_avbr_params.min_qp_P);
        EXPECT_EQ(a->h265_avbr_params.max_qp_P, b->h265_avbr_params.max_qp_P);
        EXPECT_EQ(a->h265_avbr_params.min_qp_B, b->h265_avbr_params.min_qp_B);
        EXPECT_EQ(a->h265_avbr_params.max_qp_B, b->h265_avbr_params.max_qp_B);
        EXPECT_EQ(a->h265_avbr_params.hvs_qp_enable, b->h265_avbr_params.hvs_qp_enable);
        EXPECT_EQ(a->h265_avbr_params.hvs_qp_scale, b->h265_avbr_params.hvs_qp_scale);
        EXPECT_EQ(a->h265_avbr_params.max_delta_qp, b->h265_avbr_params.max_delta_qp);
        EXPECT_EQ(a->h265_avbr_params.qp_map_enable, b->h265_avbr_params.qp_map_enable);
        break;
    case MC_AV_RC_MODE_H265FIXQP:
        EXPECT_EQ(a->h265_fixqp_params.intra_period, b->h265_fixqp_params.intra_period);
        EXPECT_EQ(a->h265_fixqp_params.frame_rate, b->h265_fixqp_params.frame_rate);
        EXPECT_EQ(a->h265_fixqp_params.force_qp_I, b->h265_fixqp_params.force_qp_I);
        EXPECT_EQ(a->h265_fixqp_params.force_qp_P, b->h265_fixqp_params.force_qp_P);
        EXPECT_EQ(a->h265_fixqp_params.force_qp_B, b->h265_fixqp_params.force_qp_B);
        break;
    case MC_AV_RC_MODE_H265QPMAP:
        EXPECT_EQ(a->h265_qpmap_params.intra_period, b->h265_qpmap_params.intra_period);
        EXPECT_EQ(a->h265_qpmap_params.frame_rate, b->h265_qpmap_params.frame_rate);
        EXPECT_EQ(a->h265_qpmap_params.qp_map_array, b->h265_qpmap_params.qp_map_array);
        EXPECT_EQ(a->h265_qpmap_params.qp_map_array_count, b->h265_qpmap_params.qp_map_array_count);
        break;
    default:
        break;
    }
    return 0;
}

TEST_F(MediaCodecTest, test_hb_mm_mc_get_rate_control_config) {
    hb_s32 ret = 0;
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;

    hb_s32 (*getFunc)(media_codec_context_t *context, mc_rate_control_params_t *params) = hb_mm_mc_get_rate_control_config;
    hb_s32 (*setFunc)(media_codec_context_t *context, const mc_rate_control_params_t *params) = hb_mm_mc_set_rate_control_config;

    // 1. Test the values before initialize
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    // 2. Set the values before initialize
    mc_rate_control_params_t rc_params;
    rc_params = params->rc_params;
    ret = setFunc(context, &rc_params);
    ASSERT_NE(ret, (int32_t)0);

    ret = hb_mm_mc_initialize(context);
    ASSERT_EQ(ret, (int32_t)0);

    ret = setFunc(context, &rc_params);
    ASSERT_EQ(ret, (int32_t)0);

    // 3. Test the values before configure
    mc_rate_control_params_t test1;
    memset(&test1, 0x00, sizeof(mc_rate_control_params_t));
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(compare_rc_params(&test1, &rc_params), (int32_t)0);

    // 4. Set the values before configure
    memset(&rc_params, 0x00, sizeof(mc_rate_control_params_t));
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        rc_params.mode = MC_AV_RC_MODE_H264FIXQP;
        rc_params.h264_fixqp_params.force_qp_I = 20;
        rc_params.h264_fixqp_params.force_qp_P = 20;
        rc_params.h264_fixqp_params.force_qp_B = 20;
        rc_params.h264_fixqp_params.intra_period = 20;
        rc_params.h264_fixqp_params.frame_rate = 25;
    } else {
        rc_params.mode = MC_AV_RC_MODE_H265FIXQP;
        rc_params.h265_fixqp_params.force_qp_I = 20;
        rc_params.h265_fixqp_params.force_qp_P = 20;
        rc_params.h265_fixqp_params.force_qp_B = 20;
        rc_params.h265_fixqp_params.intra_period = 20;
        rc_params.h265_fixqp_params.frame_rate = 25;
    }
    ASSERT_EQ(ret, (int32_t)0);
    ret = setFunc(context, &rc_params);
    ASSERT_EQ(ret, (int32_t)0);

    // 5. Test the values before configure
    memset(&test1, 0x00, sizeof(mc_rate_control_params_t));
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(test1.mode, rc_params.mode);
    ASSERT_EQ(compare_rc_params(&test1, &rc_params), (int32_t)0);

    ret = hb_mm_mc_configure(context);
    ASSERT_EQ(ret, (int32_t)0);

    // 6. Test the values after configure
    memset(&test1, 0x00, sizeof(mc_rate_control_params_t));
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(compare_rc_params(&test1, &rc_params), (int32_t)0);

    // 7. Set the values after configure
    memset(&rc_params, 0x00, sizeof(mc_rate_control_params_t));
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        rc_params.mode = MC_AV_RC_MODE_H264VBR;
        rc_params.h264_vbr_params.intra_qp = 20;
        rc_params.h264_vbr_params.intra_period = 30;
        rc_params.h264_vbr_params.frame_rate = 35;
    } else {
        rc_params.mode = MC_AV_RC_MODE_H265VBR;
        rc_params.h265_vbr_params.intra_qp = 20;
        rc_params.h265_vbr_params.intra_period = 30;
        rc_params.h265_vbr_params.frame_rate = 35;
    }
    ASSERT_EQ(ret, (int32_t)0);
    ret = setFunc(context, &rc_params);
    ASSERT_NE(ret, (int32_t)0);

    // 8. Test the values after configure
    memset(&test1, 0x00, sizeof(mc_rate_control_params_t));
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_NE(test1.mode, rc_params.mode);

    // 9. Set the values again after configure
    memset(&rc_params, 0x00, sizeof(mc_rate_control_params_t));
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        rc_params.mode = MC_AV_RC_MODE_H264FIXQP;
        rc_params.h264_fixqp_params.force_qp_I = 23;
        rc_params.h264_fixqp_params.force_qp_P = 23;
        rc_params.h264_fixqp_params.force_qp_B = 23;
        rc_params.h264_fixqp_params.intra_period = 23;
        rc_params.h264_fixqp_params.frame_rate = 27;
    } else {
        rc_params.mode = MC_AV_RC_MODE_H265FIXQP;
        rc_params.h265_fixqp_params.force_qp_I = 23;
        rc_params.h265_fixqp_params.force_qp_P = 23;
        rc_params.h265_fixqp_params.force_qp_B = 23;
        rc_params.h265_fixqp_params.intra_period = 23;
        rc_params.h265_fixqp_params.frame_rate = 27;
    }
    ret = setFunc(context, &rc_params);
    ASSERT_EQ(ret, (int32_t)0);

    // 10. Test the values after configure
    mc_rate_control_params_t test6;
    memset(&test6, 0x00, sizeof(mc_rate_control_params_t));
    ret = getFunc(context, &test6);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(test6.mode, rc_params.mode);
    //ASSERT_EQ(test3.h264_fixqp_params.frame_rate, rc_params.h264_fixqp_params.frame_rate);
    ASSERT_EQ(compare_rc_params(&test6, &rc_params), (int32_t)0);
    // TODO Add the test after start and pause
    ret = hb_mm_mc_stop(context);
    EXPECT_EQ(ret, (int32_t)0);

    ret = hb_mm_mc_release(context);
    EXPECT_EQ(ret, (int32_t)0);
    if (context != NULL) {
        free(context);
    }
}

#ifdef J5
TEST_F(MediaCodecTest, test_hb_mm_mc_get_max_bit_rate_config) {
    hb_s32 ret = 0;
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;

    hb_s32 (*getFunc)(media_codec_context_t *context, hb_u32 *params) = hb_mm_mc_get_max_bit_rate_config;
    hb_s32 (*setFunc)(media_codec_context_t *context, hb_u32 params) = hb_mm_mc_set_max_bit_rate_config;

    // 1. Test the values before initialize
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264AVBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265AVBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    // 2. Set the values before initialize
    hb_u32 max_bitrate_params = 5000;
    ret = setFunc(context, max_bitrate_params);
    ASSERT_NE(ret, (int32_t)0);

    ret = hb_mm_mc_initialize(context);
    ASSERT_EQ(ret, (int32_t)0);

    ret = setFunc(context, max_bitrate_params);
    ASSERT_EQ(ret, (int32_t)0);

    // 3. Test the values before configure
    hb_u32 test1 = 0;
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(test1, max_bitrate_params);

    // 4. Set the values before configure
    max_bitrate_params = 4000;
    ret = setFunc(context, max_bitrate_params);
    ASSERT_EQ(ret, (int32_t)0);

    // 5. Test the values before configure
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(test1, max_bitrate_params);

    ret = hb_mm_mc_configure(context);
    ASSERT_EQ(ret, (int32_t)0);

    // 6. Test the values after configure
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(test1, max_bitrate_params);

    // 7. Set the values after configure
    max_bitrate_params = 3000;
    ret = setFunc(context, max_bitrate_params);
    ASSERT_EQ(ret, (int32_t)0);

    // 8. Test the values after configure
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(test1, max_bitrate_params);

    // 9. Set the values again after configure
    max_bitrate_params = 3000;
    ret = setFunc(context, max_bitrate_params);
    ASSERT_EQ(ret, (int32_t)0);

    // 10. Test the values after configure
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(test1, max_bitrate_params);
    // TODO Add the test after start and pause
    ret = hb_mm_mc_stop(context);
    EXPECT_EQ(ret, (int32_t)0);

    ret = hb_mm_mc_release(context);
    EXPECT_EQ(ret, (int32_t)0);
    if (context != NULL) {
        free(context);
    }
}
#endif

static int32_t compare_deblk_filter(media_codec_id_t codec_id,
                mc_video_deblk_filter_params_t *a,
                mc_video_deblk_filter_params_t *b) {
    if (codec_id == MEDIA_CODEC_ID_H264) {
        EXPECT_EQ(a->h264_deblk.disable_deblocking_filter_idc, b->h264_deblk.disable_deblocking_filter_idc);
        EXPECT_EQ(a->h264_deblk.slice_alpha_c0_offset_div2, b->h264_deblk.slice_alpha_c0_offset_div2);
        EXPECT_EQ(a->h264_deblk.slice_beta_offset_div2, b->h264_deblk.slice_beta_offset_div2);
        if (a->h264_deblk.disable_deblocking_filter_idc != b->h264_deblk.disable_deblocking_filter_idc ||
            a->h264_deblk.slice_alpha_c0_offset_div2 != b->h264_deblk.slice_alpha_c0_offset_div2 ||
            a->h264_deblk.slice_beta_offset_div2 != b->h264_deblk.slice_beta_offset_div2) {
            return -1;
        }
    } else {
        EXPECT_EQ(a->h265_deblk.slice_deblocking_filter_disabled_flag, b->h265_deblk.slice_deblocking_filter_disabled_flag);
        EXPECT_EQ(a->h265_deblk.slice_beta_offset_div2, b->h265_deblk.slice_beta_offset_div2);
        EXPECT_EQ(a->h265_deblk.slice_tc_offset_div2, b->h265_deblk.slice_tc_offset_div2);
        EXPECT_EQ(a->h265_deblk.slice_loop_filter_across_slices_enabled_flag, b->h265_deblk.slice_loop_filter_across_slices_enabled_flag);
        if (a->h265_deblk.slice_deblocking_filter_disabled_flag != b->h265_deblk.slice_deblocking_filter_disabled_flag ||
            a->h265_deblk.slice_tc_offset_div2 != b->h265_deblk.slice_tc_offset_div2 ||
            a->h265_deblk.slice_loop_filter_across_slices_enabled_flag != 
            b->h265_deblk.slice_loop_filter_across_slices_enabled_flag) {
            return -1;
        }
    }
    return 0;
}

TEST_F(MediaCodecTest, test_hb_mm_mc_get_deblk_filter_config) {
    hb_s32 ret = 0;
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    hb_s32 (*getFunc)(media_codec_context_t *context, mc_video_deblk_filter_params_t *params) = hb_mm_mc_get_deblk_filter_config;
    hb_s32 (*setFunc)(media_codec_context_t *context, const mc_video_deblk_filter_params_t *params) = hb_mm_mc_set_deblk_filter_config;

    // 1. Test the values before initialize
    mc_video_deblk_filter_params_t test1;
    memset(&test1, 0x00, sizeof(mc_video_deblk_filter_params_t));
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        ASSERT_EQ(test1.h264_deblk.disable_deblocking_filter_idc, (uint32_t)0);
        ASSERT_EQ(test1.h264_deblk.slice_alpha_c0_offset_div2, (int32_t)0);
        ASSERT_EQ(test1.h264_deblk.slice_beta_offset_div2, (int32_t)0);
    } else {
        ASSERT_EQ(test1.h265_deblk.slice_deblocking_filter_disabled_flag, (uint32_t)0);
        ASSERT_EQ(test1.h265_deblk.slice_beta_offset_div2, (int32_t)0);
        ASSERT_EQ(test1.h265_deblk.slice_tc_offset_div2, (int32_t)0);
        ASSERT_EQ(test1.h265_deblk.slice_loop_filter_across_slices_enabled_flag, (uint32_t)1);
    }

    // 2. Set the values before initialize
    mc_video_deblk_filter_params_t deblk_flt;
    memset(&deblk_flt, 0x00, sizeof(mc_video_deblk_filter_params_t));
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        deblk_flt.h264_deblk.disable_deblocking_filter_idc = 1;
        deblk_flt.h264_deblk.slice_alpha_c0_offset_div2 = 6;
        deblk_flt.h264_deblk.slice_beta_offset_div2 = -6;
    } else {
        deblk_flt.h265_deblk.slice_deblocking_filter_disabled_flag = 1;
        deblk_flt.h265_deblk.slice_beta_offset_div2 = -6;
        deblk_flt.h265_deblk.slice_tc_offset_div2 = 6;
        deblk_flt.h265_deblk.slice_loop_filter_across_slices_enabled_flag = 0;
    }
    ret = setFunc(context, &deblk_flt);
    ASSERT_NE(ret, (int32_t)0);

    ret = hb_mm_mc_initialize(context);
    ASSERT_EQ(ret, (int32_t)0);

    memset(&deblk_flt, 0x00, sizeof(mc_video_deblk_filter_params_t));
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        deblk_flt.h264_deblk.disable_deblocking_filter_idc = 1;
        deblk_flt.h264_deblk.slice_alpha_c0_offset_div2 = 6;
        deblk_flt.h264_deblk.slice_beta_offset_div2 = -6;
    } else {
        deblk_flt.h265_deblk.slice_deblocking_filter_disabled_flag = 1;
        deblk_flt.h265_deblk.slice_beta_offset_div2 = -6;
        deblk_flt.h265_deblk.slice_tc_offset_div2 = 6;
        deblk_flt.h265_deblk.slice_loop_filter_across_slices_enabled_flag = 0;
    }
    ret = setFunc(context, &deblk_flt);
    ASSERT_EQ(ret, (int32_t)0);

    // 3. Test the values before configure
    memset(&test1, 0x00, sizeof(mc_video_deblk_filter_params_t));
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(compare_deblk_filter(context->codec_id, &test1, &deblk_flt), (int32_t)0);
    ret = hb_mm_mc_configure(context);
    ASSERT_EQ(ret, (int32_t)0);

    // 4. Test the values after configure
    memset(&test1, 0x00, sizeof(mc_video_deblk_filter_params_t));
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(compare_deblk_filter(context->codec_id, &test1, &deblk_flt), (int32_t)0);

    memset(&deblk_flt, 0x00, sizeof(mc_video_deblk_filter_params_t));
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        deblk_flt.h264_deblk.disable_deblocking_filter_idc = 0;
        deblk_flt.h264_deblk.slice_alpha_c0_offset_div2 = 3;
        deblk_flt.h264_deblk.slice_beta_offset_div2 = 4;
    } else {
        deblk_flt.h265_deblk.slice_deblocking_filter_disabled_flag = 0;
        deblk_flt.h265_deblk.slice_beta_offset_div2 = -4;
        deblk_flt.h265_deblk.slice_tc_offset_div2 = 3;
        deblk_flt.h265_deblk.slice_loop_filter_across_slices_enabled_flag = 1;
    }
    ret = setFunc(context, &deblk_flt);
    ASSERT_EQ(ret, (int32_t)0);

    // 5. Test the values after configure again
    memset(&test1, 0x00, sizeof(mc_video_deblk_filter_params_t));
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(compare_deblk_filter(context->codec_id, &test1, &deblk_flt), (int32_t)0);

    memset(&deblk_flt, 0x00, sizeof(mc_video_deblk_filter_params_t));
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        deblk_flt.h264_deblk.disable_deblocking_filter_idc = 1;
        deblk_flt.h264_deblk.slice_alpha_c0_offset_div2 = 2;
        deblk_flt.h264_deblk.slice_beta_offset_div2 = -5;
    } else {
        deblk_flt.h265_deblk.slice_deblocking_filter_disabled_flag = 1;
        deblk_flt.h265_deblk.slice_beta_offset_div2 = 2;
        deblk_flt.h265_deblk.slice_tc_offset_div2 = 5;
        deblk_flt.h265_deblk.slice_loop_filter_across_slices_enabled_flag = 0;
    }
    ret = setFunc(context, &deblk_flt);
    ASSERT_EQ(ret, (int32_t)0);

    // 6. Test the values after muti-setting
    memset(&test1, 0x00, sizeof(mc_video_deblk_filter_params_t));
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(compare_deblk_filter(context->codec_id, &test1, &deblk_flt), (int32_t)0);

    // TODO Add the test after start and pause
    ret = hb_mm_mc_stop(context);
    EXPECT_EQ(ret, (int32_t)0);

    ret = hb_mm_mc_release(context);
    EXPECT_EQ(ret, (int32_t)0);
    if (context != NULL) {
        free(context);
    }
}

static int32_t compare_sao_params(mc_h265_sao_params_t *a,
                mc_h265_sao_params_t *b) {
    EXPECT_EQ(a->sample_adaptive_offset_enabled_flag, b->sample_adaptive_offset_enabled_flag);
    if (a->sample_adaptive_offset_enabled_flag != b->sample_adaptive_offset_enabled_flag) {
        return -1;
    }
    return 0;
}

TEST_F(MediaCodecTest, test_hb_mm_mc_get_sao_config) {
    hb_s32 ret = 0;
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    mTestCodec = TEST_CODEC_ID_H265;
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    hb_s32 (*getFunc)(media_codec_context_t *context, mc_h265_sao_params_t *params) = hb_mm_mc_get_sao_config;
    hb_s32 (*setFunc)(media_codec_context_t *context, const mc_h265_sao_params_t *params) = hb_mm_mc_set_sao_config;

    // 1. Test the values before initialize
    mc_h265_sao_params_t test1;
    memset(&test1, 0x00, sizeof(mc_h265_sao_params_t));
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);

    // 2. Test the values before initialize
    context->codec_id = get_codec_id(mTestCodec);
    memset(&test1, 0x00, sizeof(mc_h265_sao_params_t));
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(test1.sample_adaptive_offset_enabled_flag, (uint32_t)0);

    // 3. Set the values before initialize
    memset(&test1, 0x00, sizeof(mc_h265_sao_params_t));
    ret = setFunc(context, &test1);
    ASSERT_NE(ret, (int32_t)0);

    ret = hb_mm_mc_initialize(context);
    ASSERT_EQ(ret, (int32_t)0);

    mc_h265_sao_params_t sao_params;
    memset(&sao_params, 0x00, sizeof(mc_h265_sao_params_t));
    sao_params.sample_adaptive_offset_enabled_flag = 1;
    ret = setFunc(context, &sao_params);
    ASSERT_EQ(ret, (int32_t)0);

    // 4. Test the values before configure
    memset(&test1, 0x00, sizeof(mc_h265_sao_params_t));
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(compare_sao_params(&test1, &sao_params), (int32_t)0);

    ret = hb_mm_mc_configure(context);
    ASSERT_EQ(ret, (int32_t)0);

    // 5. Test the values after configure
    memset(&test1, 0x00, sizeof(mc_h265_sao_params_t));
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(compare_sao_params(&test1, &sao_params), (int32_t)0);

    mc_h265_sao_params_t sao_params1;
    memset(&sao_params1, 0x00, sizeof(mc_h265_sao_params_t));
    sao_params1.sample_adaptive_offset_enabled_flag = 0;
    ret = setFunc(context, &sao_params1);
    ASSERT_NE(ret, (int32_t)0);

    // 6. Test the values after configure again
    memset(&test1, 0x00, sizeof(mc_h265_sao_params_t));
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(compare_sao_params(&test1, &sao_params), (int32_t)0);

    // TODO Add the test after start and pause
    ret = hb_mm_mc_stop(context);
    EXPECT_EQ(ret, (int32_t)0);

    ret = hb_mm_mc_release(context);
    EXPECT_EQ(ret, (int32_t)0);
    if (context != NULL) {
        free(context);
    }
}

#ifndef J5
static int32_t compare_entropy_params(mc_h264_entropy_params_t *a,
                mc_h264_entropy_params_t *b) {
    EXPECT_EQ(a->entropy_coding_mode, b->entropy_coding_mode);
    if (a->entropy_coding_mode != b->entropy_coding_mode) {
        return -1;
    }
    return 0;
}

TEST_F(MediaCodecTest, test_hb_mm_mc_get_entropy_config) {
    hb_s32 ret = 0;
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    mTestCodec = TEST_CODEC_ID_H264;
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    hb_s32 (*getFunc)(media_codec_context_t *context, mc_h264_entropy_params_t *params) = hb_mm_mc_get_entropy_config;
    hb_s32 (*setFunc)(media_codec_context_t *context, const mc_h264_entropy_params_t *params) = hb_mm_mc_set_entropy_config;

    // 1. Test the values before initialize
    context->codec_id = MEDIA_CODEC_ID_H265;
    mc_h264_entropy_params_t test1;
    memset(&test1, 0x00, sizeof(test1));
    ret = getFunc(context, &test1);
    ASSERT_NE(ret, (int32_t)0);

    // 2. Test the values before initialize
    context->codec_id = get_codec_id(mTestCodec);
    memset(&test1, 0x00, sizeof(test1));
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(test1.entropy_coding_mode, (uint32_t)1);

    // 3. Set the values before initialize
    mc_h264_entropy_params_t entropy_params;
    memset(&entropy_params, 0x00, sizeof(entropy_params));
    entropy_params.entropy_coding_mode = 0;
    ret = setFunc(context, &entropy_params);
    ASSERT_NE(ret, (int32_t)0);

    ret = hb_mm_mc_initialize(context);
    ASSERT_EQ(ret, (int32_t)0);

    memset(&entropy_params, 0x00, sizeof(entropy_params));
    entropy_params.entropy_coding_mode = 0;
    ret = setFunc(context, &entropy_params);
    ASSERT_EQ(ret, (int32_t)0);

    // 4. Test the values before configure
    memset(&test1, 0x00, sizeof(test1));
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(compare_entropy_params(&test1, &entropy_params), (int32_t)0);

    ret = hb_mm_mc_configure(context);
    ASSERT_EQ(ret, (int32_t)0);

    // 5. Test the values after configure
    memset(&test1, 0x00, sizeof(test1));
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(compare_entropy_params(&test1, &entropy_params), (int32_t)0);

    memset(&entropy_params, 0x00, sizeof(entropy_params));
    entropy_params.entropy_coding_mode = 1;
    ret = setFunc(context, &entropy_params);
    ASSERT_EQ(ret, (int32_t)0);

    // 6. Test the values after configure again
    memset(&test1, 0x00, sizeof(test1));
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(compare_entropy_params(&test1, &entropy_params), (int32_t)0);

    memset(&entropy_params, 0x00, sizeof(entropy_params));
    entropy_params.entropy_coding_mode = 0;
    ret = setFunc(context, &entropy_params);
    ASSERT_EQ(ret, (int32_t)0);

    // 6. Test the values after muti-setting
    memset(&test1, 0x00, sizeof(test1));
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(compare_entropy_params(&test1, &entropy_params), (int32_t)0);

    // TODO Add the test after start and pause
    ret = hb_mm_mc_stop(context);
    EXPECT_EQ(ret, (int32_t)0);

    ret = hb_mm_mc_release(context);
    EXPECT_EQ(ret, (int32_t)0);
    if (context != NULL) {
        free(context);
    }
}
#endif

static int32_t compare_vui_config(media_codec_id_t codec_id,
                mc_video_vui_params_t *a,
                mc_video_vui_params_t *b) {
    if (codec_id == MEDIA_CODEC_ID_H264) {
        EXPECT_EQ(a->h264_vui.aspect_ratio_info_present_flag, b->h264_vui.aspect_ratio_info_present_flag);
        EXPECT_EQ(a->h264_vui.aspect_ratio_idc, b->h264_vui.aspect_ratio_idc);
        EXPECT_EQ(a->h264_vui.sar_width, b->h264_vui.sar_width);
        EXPECT_EQ(a->h264_vui.sar_height, b->h264_vui.sar_height);
        EXPECT_EQ(a->h264_vui.overscan_info_present_flag, b->h264_vui.overscan_info_present_flag);
        EXPECT_EQ(a->h264_vui.overscan_appropriate_flag, b->h264_vui.overscan_appropriate_flag);
        EXPECT_EQ(a->h264_vui.video_signal_type_present_flag, b->h264_vui.video_signal_type_present_flag);
        EXPECT_EQ(a->h264_vui.video_format, b->h264_vui.video_format);
        EXPECT_EQ(a->h264_vui.video_full_range_flag, b->h264_vui.video_full_range_flag);
        EXPECT_EQ(a->h264_vui.colour_description_present_flag, b->h264_vui.colour_description_present_flag);
        EXPECT_EQ(a->h264_vui.colour_primaries, b->h264_vui.colour_primaries);
        EXPECT_EQ(a->h264_vui.transfer_characteristics, b->h264_vui.transfer_characteristics);
        EXPECT_EQ(a->h264_vui.matrix_coefficients, b->h264_vui.matrix_coefficients);
        EXPECT_EQ(a->h264_vui.vui_timing_info_present_flag, b->h264_vui.vui_timing_info_present_flag);
        EXPECT_EQ(a->h264_vui.vui_num_units_in_tick, b->h264_vui.vui_num_units_in_tick);
        EXPECT_EQ(a->h264_vui.vui_time_scale, b->h264_vui.vui_time_scale);
        EXPECT_EQ(a->h264_vui.vui_fixed_frame_rate_flag, b->h264_vui.vui_fixed_frame_rate_flag);
        EXPECT_EQ(a->h264_vui.bitstream_restriction_flag, b->h264_vui.bitstream_restriction_flag);
    } else {
        EXPECT_EQ(a->h265_vui.aspect_ratio_info_present_flag, b->h265_vui.aspect_ratio_info_present_flag);
        EXPECT_EQ(a->h265_vui.aspect_ratio_idc, b->h265_vui.aspect_ratio_idc);
        EXPECT_EQ(a->h265_vui.sar_width, b->h265_vui.sar_width);
        EXPECT_EQ(a->h265_vui.sar_height, b->h265_vui.sar_height);
        EXPECT_EQ(a->h265_vui.overscan_info_present_flag, b->h265_vui.overscan_info_present_flag);
        EXPECT_EQ(a->h265_vui.overscan_appropriate_flag, b->h265_vui.overscan_appropriate_flag);
        EXPECT_EQ(a->h265_vui.video_signal_type_present_flag, b->h265_vui.video_signal_type_present_flag);
        EXPECT_EQ(a->h265_vui.video_format, b->h265_vui.video_format);
        EXPECT_EQ(a->h265_vui.video_full_range_flag, b->h265_vui.video_full_range_flag);
        EXPECT_EQ(a->h265_vui.colour_description_present_flag, b->h265_vui.colour_description_present_flag);
        EXPECT_EQ(a->h265_vui.colour_primaries, b->h265_vui.colour_primaries);
        EXPECT_EQ(a->h265_vui.transfer_characteristics, b->h265_vui.transfer_characteristics);
        EXPECT_EQ(a->h265_vui.matrix_coefficients, b->h265_vui.matrix_coefficients);
        EXPECT_EQ(a->h265_vui.vui_timing_info_present_flag, b->h265_vui.vui_timing_info_present_flag);
        EXPECT_EQ(a->h265_vui.vui_num_units_in_tick, b->h265_vui.vui_num_units_in_tick);
        EXPECT_EQ(a->h265_vui.vui_time_scale, b->h265_vui.vui_time_scale);
        EXPECT_EQ(a->h265_vui.vui_poc_proportional_to_timing_flag, b->h265_vui.vui_poc_proportional_to_timing_flag);
        EXPECT_EQ(a->h265_vui.vui_num_ticks_poc_diff_one_minus1, b->h265_vui.vui_num_ticks_poc_diff_one_minus1);
        EXPECT_EQ(a->h265_vui.bitstream_restriction_flag, b->h265_vui.bitstream_restriction_flag);
    }
    return 0;
}

TEST_F(MediaCodecTest, test_hb_mm_mc_get_vui_config) {
    hb_s32 ret = 0;
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    hb_s32 (*getFunc)(media_codec_context_t *context, mc_video_vui_params_t *params) = hb_mm_mc_get_vui_config;
    hb_s32 (*setFunc)(media_codec_context_t *context, const mc_video_vui_params_t *params) = hb_mm_mc_set_vui_config;

    // 1. Test the values before initialize
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.h264_cbr_params.frame_rate = 0;
    } else {
        params->rc_params.h265_cbr_params.frame_rate = 0;
    }
    mc_video_vui_params_t test1;
    memset(&test1, 0x00, sizeof(mc_video_vui_params_t));
    ret = getFunc(context, &test1);
    ASSERT_NE(ret, (int32_t)0);

    // 2. Test the values before initialize
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.h264_cbr_params.frame_rate = 30;
    } else {
        params->rc_params.h265_cbr_params.frame_rate = 20;
    }
    memset(&test1, 0x00, sizeof(mc_video_vui_params_t));
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        ASSERT_EQ(test1.h264_vui.vui_num_units_in_tick, (uint32_t)1000);
        ASSERT_EQ(test1.h264_vui.vui_time_scale, (uint32_t)params->rc_params.h264_cbr_params.frame_rate * 1000);
    } else {
        ASSERT_EQ(test1.h265_vui.vui_num_units_in_tick, (uint32_t)1000);
        ASSERT_EQ(test1.h265_vui.vui_time_scale, (uint32_t)params->rc_params.h265_cbr_params.frame_rate * 1000);
    }

    // 3. Set the values before initialize
    mc_video_vui_params_t vui_timing;
    ret = getFunc(context, &vui_timing);
    ASSERT_EQ(ret, (int32_t)0);
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        vui_timing.h264_vui.vui_timing_info_present_flag = 1;
        vui_timing.h264_vui.vui_num_units_in_tick = 2000;
        vui_timing.h264_vui.vui_time_scale = 50000;
    } else {
        vui_timing.h265_vui.vui_timing_info_present_flag = 1;
        vui_timing.h265_vui.vui_num_units_in_tick = 2000;
        vui_timing.h265_vui.vui_time_scale = 50000;
    }
    ret = setFunc(context, &vui_timing);
    ASSERT_NE(ret, (int32_t)0);

    ret = hb_mm_mc_initialize(context);
    ASSERT_EQ(ret, (int32_t)0);

    ret = getFunc(context, &vui_timing);
    ASSERT_EQ(ret, (int32_t)0);
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        vui_timing.h264_vui.vui_timing_info_present_flag = 1;
        vui_timing.h264_vui.vui_num_units_in_tick = 2000;
        vui_timing.h264_vui.vui_time_scale = 50000;
    } else {
        vui_timing.h265_vui.vui_timing_info_present_flag = 1;
        vui_timing.h265_vui.vui_num_units_in_tick = 2000;
        vui_timing.h265_vui.vui_time_scale = 50000;
    }
    ret = setFunc(context, &vui_timing);
    ASSERT_EQ(ret, (int32_t)0);

    // 4. Test the values before configure
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(compare_vui_config(context->codec_id, &test1, &vui_timing), (int32_t)0);

    ret = hb_mm_mc_configure(context);
    ASSERT_EQ(ret, (int32_t)0);

    // 5. Test the values after configure
    memset(&test1, 0x00, sizeof(mc_video_vui_params_t));
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(compare_vui_config(context->codec_id, &test1, &vui_timing), (int32_t)0);

    mc_video_vui_params_t vui_timing1;
    ret = getFunc(context, &vui_timing1);
    ASSERT_EQ(ret, (int32_t)0);
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        vui_timing1.h264_vui.vui_num_units_in_tick = 3000;
        vui_timing1.h264_vui.vui_time_scale = 70000;
    } else {
        vui_timing1.h265_vui.vui_num_units_in_tick = 2000;
        vui_timing1.h265_vui.vui_time_scale = 50000;
    }
    ret = setFunc(context, &vui_timing1);
#ifdef J5
    ASSERT_EQ(ret, (int32_t)HB_MEDIA_ERR_UNSUPPORTED_FEATURE);
#else
    ASSERT_EQ(ret, (int32_t)0);

    // 6. Test the values after configure again
    memset(&test1, 0x00, sizeof(mc_video_vui_params_t));
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(compare_vui_config(context->codec_id, &test1, &vui_timing1), (int32_t)0);
#endif

    // TODO Add the test after start and pause
    ret = hb_mm_mc_stop(context);
    EXPECT_EQ(ret, (int32_t)0);

    ret = hb_mm_mc_release(context);
    EXPECT_EQ(ret, (int32_t)0);
    if (context != NULL) {
        free(context);
    }
}

static int32_t compare_vui_timing(media_codec_id_t codec_id,
                mc_video_vui_timing_params_t *a,
                mc_video_vui_timing_params_t *b) {
    if (codec_id == MEDIA_CODEC_ID_H264) {
        EXPECT_EQ(a->h264_timing.vui_num_units_in_tick, b->h264_timing.vui_num_units_in_tick);
        EXPECT_EQ(a->h264_timing.vui_time_scale, b->h264_timing.vui_time_scale);
        EXPECT_EQ(a->h264_timing.fixed_frame_rate_flag, b->h264_timing.fixed_frame_rate_flag);
        if (a->h264_timing.vui_num_units_in_tick != b->h264_timing.vui_num_units_in_tick ||
            a->h264_timing.vui_time_scale != b->h264_timing.vui_time_scale ||
            a->h264_timing.fixed_frame_rate_flag != b->h264_timing.fixed_frame_rate_flag) {
            return -1;
        }
    } else {
        EXPECT_EQ(a->h265_timing.vui_num_units_in_tick, b->h265_timing.vui_num_units_in_tick);
        EXPECT_EQ(a->h265_timing.vui_time_scale, b->h265_timing.vui_time_scale);
        EXPECT_EQ(a->h265_timing.vui_num_ticks_poc_diff_one_minus1, b->h265_timing.vui_num_ticks_poc_diff_one_minus1);
        if (a->h265_timing.vui_num_units_in_tick != b->h265_timing.vui_num_units_in_tick ||
            a->h265_timing.vui_time_scale != b->h265_timing.vui_time_scale ||
            a->h265_timing.vui_num_ticks_poc_diff_one_minus1 != b->h265_timing.vui_num_ticks_poc_diff_one_minus1) {
            return -1;
        }
    }
    return 0;
}

TEST_F(MediaCodecTest, test_hb_mm_mc_get_vui_timing_config) {
    hb_s32 ret = 0;
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    hb_s32 (*getFunc)(media_codec_context_t *context, mc_video_vui_timing_params_t *params) = hb_mm_mc_get_vui_timing_config;
    hb_s32 (*setFunc)(media_codec_context_t *context, const mc_video_vui_timing_params_t *params) = hb_mm_mc_set_vui_timing_config;

    // 1. Test the values before initialize
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.h264_cbr_params.frame_rate = 0;
    } else {
        params->rc_params.h265_cbr_params.frame_rate = 0;
    }
    mc_video_vui_timing_params_t test1;
    memset(&test1, 0x00, sizeof(mc_video_vui_timing_params_t));
    ret = getFunc(context, &test1);
    ASSERT_NE(ret, (int32_t)0);

    // 2. Test the values before initialize
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.h264_cbr_params.frame_rate = 30;
    } else {
        params->rc_params.h265_cbr_params.frame_rate = 20;
    }
    memset(&test1, 0x00, sizeof(mc_video_vui_timing_params_t));
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        ASSERT_EQ(test1.h264_timing.vui_num_units_in_tick, (uint32_t)1000);
        ASSERT_EQ(test1.h264_timing.vui_time_scale, (uint32_t)params->rc_params.h264_cbr_params.frame_rate * 1000);
    } else {
        ASSERT_EQ(test1.h265_timing.vui_num_units_in_tick, (uint32_t)1000);
        ASSERT_EQ(test1.h265_timing.vui_time_scale, (uint32_t)params->rc_params.h265_cbr_params.frame_rate * 1000);
    }

    // 3. Set the values before initialize
    mc_video_vui_timing_params_t vui_timing;
    memset(&vui_timing, 0x00, sizeof(mc_video_vui_timing_params_t));
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        vui_timing.h264_timing.vui_num_units_in_tick = 2000;
        vui_timing.h264_timing.vui_time_scale = 50000;
    } else {
        vui_timing.h265_timing.vui_num_units_in_tick = 3000;
        vui_timing.h265_timing.vui_time_scale = 60000;
    }
    ret = setFunc(context, &vui_timing);
    ASSERT_NE(ret, (int32_t)0);

    ret = hb_mm_mc_initialize(context);
    ASSERT_EQ(ret, (int32_t)0);

    memset(&vui_timing, 0x00, sizeof(mc_video_vui_timing_params_t));
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        vui_timing.h264_timing.vui_num_units_in_tick = 2000;
        vui_timing.h264_timing.vui_time_scale = 50000;
    } else {
        vui_timing.h265_timing.vui_num_units_in_tick = 3000;
        vui_timing.h265_timing.vui_time_scale = 60000;
    }
    ret = setFunc(context, &vui_timing);
    ASSERT_EQ(ret, (int32_t)0);

    // 4. Test the values before configure
    memset(&test1, 0x00, sizeof(mc_video_vui_timing_params_t));
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(compare_vui_timing(context->codec_id, &test1, &vui_timing), (int32_t)0);

    ret = hb_mm_mc_configure(context);
    ASSERT_EQ(ret, (int32_t)0);

    // 5. Test the values after configure
    memset(&test1, 0x00, sizeof(mc_video_vui_timing_params_t));
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(compare_vui_timing(context->codec_id, &test1, &vui_timing), (int32_t)0);

    mc_video_vui_timing_params_t vui_timing1;
    memset(&vui_timing1, 0x00, sizeof(mc_video_vui_timing_params_t));
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        vui_timing1.h264_timing.vui_num_units_in_tick = 3000;
        vui_timing1.h264_timing.vui_time_scale = 70000;
    } else {
        vui_timing1.h264_timing.vui_num_units_in_tick = 4000;
        vui_timing1.h264_timing.vui_time_scale = 80000;
    }
    ret = setFunc(context, &vui_timing1);
    ASSERT_NE(ret, (int32_t)0);

    // 6. Test the values after configure again
    memset(&test1, 0x00, sizeof(mc_video_vui_timing_params_t));
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(compare_vui_timing(context->codec_id, &test1, &vui_timing), (int32_t)0);

    ret = hb_mm_mc_start(context, NULL);
    ASSERT_EQ(ret, (int32_t)0);

    memset(&vui_timing1, 0x00, sizeof(mc_video_vui_timing_params_t));
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        vui_timing1.h264_timing.vui_num_units_in_tick = 4000;
        vui_timing1.h264_timing.vui_time_scale = 80000;
    } else {
        vui_timing1.h264_timing.vui_num_units_in_tick = 5000;
        vui_timing1.h264_timing.vui_time_scale = 90000;
    }
    ret = setFunc(context, &vui_timing1);
    ASSERT_NE(ret, (int32_t)0);

    // 6. Test the values after configure again
    memset(&test1, 0x00, sizeof(mc_video_vui_timing_params_t));
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(compare_vui_timing(context->codec_id, &test1, &vui_timing), (int32_t)0);

    ret = hb_mm_mc_pause(context);
    ASSERT_EQ(ret, (int32_t)0);

    memset(&vui_timing1, 0x00, sizeof(mc_video_vui_timing_params_t));
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        vui_timing1.h264_timing.vui_num_units_in_tick = 2147483648;
        vui_timing1.h264_timing.vui_time_scale = 90000;
    } else {
        vui_timing1.h264_timing.vui_num_units_in_tick = 2147483648;
        vui_timing1.h264_timing.vui_time_scale = 90000;
    }
    ret = setFunc(context, &vui_timing1);
    ASSERT_EQ(ret, (int32_t)HB_MEDIA_ERR_INVALID_PARAMS);

    // 6. Test the values after configure again
    memset(&test1, 0x00, sizeof(mc_video_vui_timing_params_t));
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(compare_vui_timing(context->codec_id, &test1, &vui_timing), (int32_t)0);

    // TODO Add the test after start and pause
    ret = hb_mm_mc_stop(context);
    EXPECT_EQ(ret, (int32_t)0);

    ret = hb_mm_mc_release(context);
    EXPECT_EQ(ret, (int32_t)0);
    if (context != NULL) {
        free(context);
    }
}

static int32_t compare_slice_config(media_codec_id_t codec_id,
                mc_video_slice_params_t *a,
                mc_video_slice_params_t *b) {
    if (codec_id == MEDIA_CODEC_ID_H264) {
        EXPECT_EQ(a->h264_slice.h264_slice_mode, b->h264_slice.h264_slice_mode);
        EXPECT_EQ(a->h264_slice.h264_slice_arg, b->h264_slice.h264_slice_arg);
        if (a->h264_slice.h264_slice_mode != b->h264_slice.h264_slice_mode ||
            a->h264_slice.h264_slice_arg != b->h264_slice.h264_slice_arg) {
            return -1;
        }
    } else {
        EXPECT_EQ(a->h265_slice.h265_independent_slice_mode, b->h265_slice.h265_independent_slice_mode);
        EXPECT_EQ(a->h265_slice.h265_independent_slice_arg, b->h265_slice.h265_independent_slice_arg);
        EXPECT_EQ(a->h265_slice.h265_dependent_slice_mode, b->h265_slice.h265_dependent_slice_mode);
        EXPECT_EQ(a->h265_slice.h265_dependent_slice_arg, b->h265_slice.h265_dependent_slice_arg);
        if (a->h265_slice.h265_independent_slice_mode != b->h265_slice.h265_independent_slice_mode ||
            a->h265_slice.h265_independent_slice_arg != b->h265_slice.h265_independent_slice_arg ||
            a->h265_slice.h265_dependent_slice_mode != b->h265_slice.h265_dependent_slice_mode ||
            a->h265_slice.h265_dependent_slice_arg != b->h265_slice.h265_dependent_slice_arg) {
            return -1;
        }
    }
    return 0;
}

TEST_F(MediaCodecTest, test_hb_mm_mc_get_slice_config) {
    hb_s32 ret = 0;
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    hb_s32 (*getFunc)(media_codec_context_t *context, mc_video_slice_params_t *params) = hb_mm_mc_get_slice_config;
    hb_s32 (*setFunc)(media_codec_context_t *context, const mc_video_slice_params_t *params) = hb_mm_mc_set_slice_config;

    // 1. Test the values before initialize
    mc_video_slice_params_t test1;
    memset(&test1, 0x00, sizeof(mc_video_slice_params_t));
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        ASSERT_EQ(test1.h264_slice.h264_slice_mode, (int32_t)0);
        ASSERT_EQ(test1.h264_slice.h264_slice_arg, (int32_t)0);
    } else {
        ASSERT_EQ(test1.h265_slice.h265_independent_slice_mode, (int32_t)0);
        ASSERT_EQ(test1.h265_slice.h265_independent_slice_arg, (int32_t)0);
        ASSERT_EQ(test1.h265_slice.h265_dependent_slice_mode, (int32_t)0);
        ASSERT_EQ(test1.h265_slice.h265_dependent_slice_arg, (int32_t)0);
    }

    // 2. Set the values before initialize
    mc_video_slice_params_t slice_params;
    memset(&slice_params, 0x00, sizeof(mc_video_slice_params_t));
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        slice_params.h264_slice.h264_slice_mode = 1;
        slice_params.h264_slice.h264_slice_arg = 60;
    } else {
        slice_params.h265_slice.h265_independent_slice_mode = 1;
        slice_params.h265_slice.h265_independent_slice_arg = 20;
        slice_params.h265_slice.h265_dependent_slice_mode = 1;
        slice_params.h265_slice.h265_dependent_slice_arg = 30;
    }
    ret = setFunc(context, &slice_params);
    ASSERT_NE(ret, (int32_t)0);

    ret = hb_mm_mc_initialize(context);
    ASSERT_EQ(ret, (int32_t)0);

    memset(&slice_params, 0x00, sizeof(mc_video_slice_params_t));
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        slice_params.h264_slice.h264_slice_mode = 1;
        slice_params.h264_slice.h264_slice_arg = 60;
    } else {
        slice_params.h265_slice.h265_independent_slice_mode = 1;
        slice_params.h265_slice.h265_independent_slice_arg = 20;
        slice_params.h265_slice.h265_dependent_slice_mode = 1;
        slice_params.h265_slice.h265_dependent_slice_arg = 30;
    }
    ret = setFunc(context, &slice_params);
    ASSERT_EQ(ret, (int32_t)0);

    // 3. Test the values before configure
    memset(&test1, 0x00, sizeof(mc_video_slice_params_t));
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(compare_slice_config(context->codec_id, &test1, &slice_params), (int32_t)0);

    ret = hb_mm_mc_configure(context);
    ASSERT_EQ(ret, (int32_t)0);

    // 4. Test the values after configure
    memset(&test1, 0x00, sizeof(mc_video_slice_params_t));
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(compare_slice_config(context->codec_id, &test1, &slice_params), (int32_t)0);

    memset(&slice_params, 0x00, sizeof(mc_video_slice_params_t));
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        slice_params.h264_slice.h264_slice_mode = 1;
        slice_params.h264_slice.h264_slice_arg = 80;
    } else {
        slice_params.h265_slice.h265_independent_slice_mode = 1;
        slice_params.h265_slice.h265_independent_slice_arg = 10;
        slice_params.h265_slice.h265_dependent_slice_mode = 1;
        slice_params.h265_slice.h265_dependent_slice_arg = 40;
    }
    ret = setFunc(context, &slice_params);
    ASSERT_EQ(ret, (int32_t)0);

    // 5. Test the values after configure again
    memset(&test1, 0x00, sizeof(mc_video_slice_params_t));
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(compare_slice_config(context->codec_id, &test1, &slice_params), (int32_t)0);

    memset(&slice_params, 0x00, sizeof(mc_video_slice_params_t));
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        slice_params.h264_slice.h264_slice_mode = 1;
        slice_params.h264_slice.h264_slice_arg = 100;
    } else {
        slice_params.h265_slice.h265_independent_slice_mode = 1;
        slice_params.h265_slice.h265_independent_slice_arg = 30;
        slice_params.h265_slice.h265_dependent_slice_mode = 2;
        slice_params.h265_slice.h265_dependent_slice_arg = 40;
    }
    ret = setFunc(context, &slice_params);
    ASSERT_EQ(ret, (int32_t)0);

    // 6. Test the values after muti-setting
    memset(&test1, 0x00, sizeof(mc_video_slice_params_t));
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(compare_slice_config(context->codec_id, &test1, &slice_params), (int32_t)0);

    // TODO Add the test after start and pause
    ret = hb_mm_mc_stop(context);
    EXPECT_EQ(ret, (int32_t)0);

    ret = hb_mm_mc_release(context);
    EXPECT_EQ(ret, (int32_t)0);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_hb_mm_mc_insert_user_data) {
    hb_s32 ret = 0;
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    hb_s32 (*reqFunc)(media_codec_context_t *context,
        hb_u8 *data, hb_u32 length) = hb_mm_mc_insert_user_data;

    uint8_t uuid[] = "dc45e9bde6d948b7962cd820d923eeef+HorizonAI";
    hb_u32 length = sizeof(uuid)/sizeof(uuid[0]);
    // 1. Request the values before initialize
    ret = reqFunc(context, uuid, length);
    ASSERT_NE(ret, (int32_t)0);

    ret = hb_mm_mc_initialize(context);
    ASSERT_EQ(ret, (int32_t)0);

    // 2. Request the values after initialize
    ret = reqFunc(context, uuid, length);
    ASSERT_EQ(ret, (int32_t)0);

    ret = hb_mm_mc_configure(context);
    ASSERT_EQ(ret, (int32_t)0);

    // 3. Request the values after configure
    ret = reqFunc(context, uuid, length);
    ASSERT_EQ(ret, (int32_t)0);

    // 4. Request the values again after configure
    ret = reqFunc(context, uuid, length);
    ASSERT_EQ(ret, (int32_t)0);

    // TODO Add the test after start and pause
    ret = hb_mm_mc_stop(context);
    EXPECT_EQ(ret, (int32_t)0);

    ret = hb_mm_mc_release(context);
    EXPECT_EQ(ret, (int32_t)0);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_hb_mm_mc_request_idr_frame) {
    hb_s32 ret = 0;
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    hb_s32 (*reqFunc)(media_codec_context_t *context) = hb_mm_mc_request_idr_frame;

    // 1. Request the values before initialize
    ret = reqFunc(context);
    ASSERT_NE(ret, (int32_t)0);

    ret = hb_mm_mc_initialize(context);
    ASSERT_EQ(ret, (int32_t)0);

    // 2. Request the values after initialize
    ret = reqFunc(context);
    ASSERT_EQ(ret, (int32_t)0);

    ret = hb_mm_mc_configure(context);
    ASSERT_EQ(ret, (int32_t)0);

    // 3. Request the values after configure
    ret = reqFunc(context);
    ASSERT_EQ(ret, (int32_t)0);

    // 4. Request the values again after configure 
    ret = reqFunc(context);
    ASSERT_EQ(ret, (int32_t)0);

    // TODO Add the test after start and pause
    ret = hb_mm_mc_stop(context);
    EXPECT_EQ(ret, (int32_t)0);

    ret = hb_mm_mc_release(context);
    EXPECT_EQ(ret, (int32_t)0);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_hb_mm_mc_request_idr_header) {
    hb_s32 ret = 0;
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    hb_s32 (*reqFunc)(media_codec_context_t *context, hb_u32 force_header) =
        hb_mm_mc_request_idr_header;

    // 1. Request the values before initialize
    ret = reqFunc(context, 0);
    ASSERT_NE(ret, (int32_t)0);

    ret = hb_mm_mc_initialize(context);
    ASSERT_EQ(ret, (int32_t)0);

    // 2. Request the values after initialize
    ret = reqFunc(context, 1);
    ASSERT_EQ(ret, (int32_t)0);

    ret = hb_mm_mc_configure(context);
    ASSERT_EQ(ret, (int32_t)0);

    // 3. Request the values after configure
    ret = reqFunc(context, 1);
#ifdef J5
    ASSERT_EQ(ret, (int32_t)HB_MEDIA_ERR_UNSUPPORTED_FEATURE);
#else
    ASSERT_EQ(ret, (int32_t)0);

    // 4. Request the values again after configure
    ret = reqFunc(context, 2);
    ASSERT_EQ(ret, (int32_t)0);
#endif
    // TODO Add the test after start and pause
    ret = hb_mm_mc_stop(context);
    EXPECT_EQ(ret, (int32_t)0);

    ret = hb_mm_mc_release(context);
    EXPECT_EQ(ret, (int32_t)0);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_hb_mm_mc_enable_idr) {
    hb_s32 ret = 0;
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    hb_s32 (*reqFunc)(media_codec_context_t *context, hb_bool enable) =
        hb_mm_mc_enable_idr_frame;

    // 1. Request the values before initialize
    ret = reqFunc(context, 0);
    ASSERT_NE(ret, (int32_t)0);

    ret = hb_mm_mc_initialize(context);
    ASSERT_EQ(ret, (int32_t)0);

    // 2. Request the values after initialize
    ret = reqFunc(context, 1);
    ASSERT_EQ(ret, (int32_t)0);

    ret = hb_mm_mc_configure(context);
    ASSERT_EQ(ret, (int32_t)0);

    // 3. Request the values after configure
    ret = reqFunc(context, 0);
    ASSERT_EQ(ret, (int32_t)0);

    // 4. Request the values again after configure
    ret = reqFunc(context, 1);
    ASSERT_EQ(ret, (int32_t)0);

    // TODO Add the test after start and pause
    ret = hb_mm_mc_stop(context);
    EXPECT_EQ(ret, (int32_t)0);

    ret = hb_mm_mc_release(context);
    EXPECT_EQ(ret, (int32_t)0);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_hb_mm_mc_skip_pic) {
    hb_s32 ret = 0;
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    hb_s32 (*reqFunc)(media_codec_context_t *context, hb_s32 index) = hb_mm_mc_skip_pic;

    // 1. Request the values before initialize
    ret = reqFunc(context, 1);
    ASSERT_NE(ret, (int32_t)0);

    ret = hb_mm_mc_initialize(context);
    ASSERT_EQ(ret, (int32_t)0);

    // 2. Request the values after initialize
    ret = reqFunc(context, 1);
    ASSERT_EQ(ret, (int32_t)0);

    ret = hb_mm_mc_configure(context);
    ASSERT_EQ(ret, (int32_t)0);

    // 3. Request the values after configure
    ret = reqFunc(context, 1);
    ASSERT_EQ(ret, (int32_t)0);

    // 4. Request the values again after configure 
    ret = reqFunc(context, 1);
    ASSERT_EQ(ret, (int32_t)0);

    // TODO Add the test after start and pause
    ret = hb_mm_mc_stop(context);
    EXPECT_EQ(ret, (int32_t)0);

    ret = hb_mm_mc_release(context);
    EXPECT_EQ(ret, (int32_t)0);
    if (context != NULL) {
        free(context);
    }
}

#ifndef J5
static int32_t compare_3dnr_config(mc_video_3dnr_enc_params_t *a,
                mc_video_3dnr_enc_params_t *b) {
    EXPECT_EQ(a->nr_y_enable, b->nr_y_enable);
    EXPECT_EQ(a->nr_cb_enable, b->nr_cb_enable);
    EXPECT_EQ(a->nr_cr_enable, b->nr_cr_enable);
    EXPECT_EQ(a->nr_est_enable, b->nr_est_enable);
    EXPECT_EQ(a->nr_intra_weightY, b->nr_intra_weightY);
    EXPECT_EQ(a->nr_intra_weightCb, b->nr_intra_weightCb);
    EXPECT_EQ(a->nr_intra_weightCr, b->nr_intra_weightCr);
    EXPECT_EQ(a->nr_inter_weightY, b->nr_inter_weightY);
    EXPECT_EQ(a->nr_inter_weightCb, b->nr_inter_weightCb);
    EXPECT_EQ(a->nr_inter_weightCr, b->nr_inter_weightCr);
    EXPECT_EQ(a->nr_noise_sigmaY, b->nr_noise_sigmaY);
    EXPECT_EQ(a->nr_noise_sigmaCb, b->nr_noise_sigmaCb);
    EXPECT_EQ(a->nr_noise_sigmaCr, b->nr_noise_sigmaCr);
    if (a->nr_y_enable != b->nr_y_enable ||
        a->nr_cb_enable != b->nr_cb_enable ||
        a->nr_cr_enable != b->nr_cr_enable ||
        a->nr_est_enable != b->nr_est_enable ||
        a->nr_intra_weightY != b->nr_intra_weightY ||
        a->nr_intra_weightCb != b->nr_intra_weightCb ||
        a->nr_intra_weightCr != b->nr_intra_weightCr ||
        a->nr_inter_weightY != b->nr_inter_weightY ||
        a->nr_inter_weightCb != b->nr_inter_weightCb ||
        a->nr_inter_weightCr != b->nr_inter_weightCr ||
        a->nr_noise_sigmaY != b->nr_noise_sigmaY ||
        a->nr_noise_sigmaCb != b->nr_noise_sigmaCb ||
        a->nr_noise_sigmaCr!= b->nr_noise_sigmaCr) {
        return -1;
    }
    return 0;
}
#endif

TEST_F(MediaCodecTest, test_hb_mm_mc_get_3dnr_config) {
    hb_s32 ret = 0;
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    hb_s32 (*getFunc)(media_codec_context_t *context, mc_video_3dnr_enc_params_t *params) = hb_mm_mc_get_3dnr_enc_config;
    hb_s32 (*setFunc)(media_codec_context_t *context, const mc_video_3dnr_enc_params_t *params) = hb_mm_mc_set_3dnr_enc_config;

    // 1. Test the values before initialize
    mc_video_3dnr_enc_params_t test1;
    memset(&test1, 0x00, sizeof(mc_video_3dnr_enc_params_t));
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);

    // 2. Set the values before initialize
    mc_video_3dnr_enc_params_t noise_reduction;
    memset(&noise_reduction, 0x00, sizeof(mc_video_3dnr_enc_params_t));
    noise_reduction.nr_y_enable = 1;
    noise_reduction.nr_est_enable = 1;
    noise_reduction.nr_intra_weightY = 2;
    noise_reduction.nr_inter_weightY = 3;
    noise_reduction.nr_noise_sigmaY = 4;
    ret = setFunc(context, &noise_reduction);
    ASSERT_NE(ret, (int32_t)0);

    ret = hb_mm_mc_initialize(context);
    ASSERT_EQ(ret, (int32_t)0);

#ifndef J5
    memset(&noise_reduction, 0x00, sizeof(mc_video_3dnr_enc_params_t));
    noise_reduction.nr_y_enable = 1;
    noise_reduction.nr_est_enable = 1;
    noise_reduction.nr_intra_weightY = 2;
    noise_reduction.nr_inter_weightY = 3;
    noise_reduction.nr_noise_sigmaY = 4;
    ret = setFunc(context, &noise_reduction);
    ASSERT_EQ(ret, (int32_t)0);

    // 3. Test the values before configure
    memset(&test1, 0x00, sizeof(mc_video_3dnr_enc_params_t));
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(compare_3dnr_config(&test1, &noise_reduction), (int32_t)0);

    ret = hb_mm_mc_configure(context);
    ASSERT_EQ(ret, (int32_t)0);

    // 4. Test the values after configure
    memset(&test1, 0x00, sizeof(mc_video_3dnr_enc_params_t));
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(compare_3dnr_config(&test1, &noise_reduction), (int32_t)0);

    memset(&noise_reduction, 0x00, sizeof(mc_video_3dnr_enc_params_t));
    noise_reduction.nr_y_enable = 1;
    noise_reduction.nr_est_enable = 0;
    noise_reduction.nr_intra_weightY = 7;
    noise_reduction.nr_inter_weightY = 8;
    noise_reduction.nr_noise_sigmaY = 9;
    ret = setFunc(context, &noise_reduction);
    ASSERT_EQ(ret, (int32_t)0);

    // 5. Test the values after configure again
    memset(&test1, 0x00, sizeof(mc_video_3dnr_enc_params_t));
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(compare_3dnr_config(&test1, &noise_reduction), (int32_t)0);

    memset(&noise_reduction, 0x00, sizeof(mc_video_3dnr_enc_params_t));
    noise_reduction.nr_y_enable = 1;
    noise_reduction.nr_est_enable = 0;
    noise_reduction.nr_intra_weightY = 9;
    noise_reduction.nr_inter_weightY = 10;
    noise_reduction.nr_noise_sigmaY = 4;
    ret = setFunc(context, &noise_reduction);
    ASSERT_EQ(ret, (int32_t)0);

    // 6. Test the values after muti-setting
    memset(&test1, 0x00, sizeof(mc_video_3dnr_enc_params_t));
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(compare_3dnr_config(&test1, &noise_reduction), (int32_t)0);

    // TODO Add the test after start and pause
    ret = hb_mm_mc_stop(context);
    EXPECT_EQ(ret, (int32_t)0);
#endif

    ret = hb_mm_mc_release(context);
    EXPECT_EQ(ret, (int32_t)0);
    if (context != NULL) {
        free(context);
    }
}

#ifndef J5
static int32_t compare_smart_bg(mc_video_smart_bg_enc_params_t *a,
                mc_video_smart_bg_enc_params_t *b) {
    EXPECT_EQ(a->bg_detect_enable, b->bg_detect_enable);
    EXPECT_EQ(a->bg_threshold_diff, b->bg_threshold_diff);
    EXPECT_EQ(a->bg_threshold_mean_diff, b->bg_threshold_mean_diff);
    EXPECT_EQ(a->bg_lambda_qp, b->bg_lambda_qp);
    EXPECT_EQ(a->bg_delta_qp, b->bg_delta_qp);
    EXPECT_EQ(a->s2fme_disable, b->s2fme_disable);
    if (a->bg_detect_enable != b->bg_detect_enable ||
        a->bg_threshold_diff != b->bg_threshold_diff ||
        a->bg_threshold_mean_diff != b->bg_threshold_mean_diff ||
        a->bg_lambda_qp != b->bg_lambda_qp ||
        a->bg_delta_qp != b->bg_delta_qp ||
        a->s2fme_disable != b->s2fme_disable) {
        return -1;
    }
    return 0;
}
#endif

TEST_F(MediaCodecTest, test_hb_mm_mc_get_smart_bg_enc_config) {
    hb_s32 ret = 0;
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    mTestCodec = TEST_CODEC_ID_H265;
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    hb_s32 (*getFunc)(media_codec_context_t *context, mc_video_smart_bg_enc_params_t *params) = hb_mm_mc_get_smart_bg_enc_config;
    hb_s32 (*setFunc)(media_codec_context_t *context, const mc_video_smart_bg_enc_params_t *params) = hb_mm_mc_set_smart_bg_enc_config;

    // 1. Test the values before initialize
    mc_video_smart_bg_enc_params_t test1;
    memset(&test1, 0x00, sizeof(mc_video_smart_bg_enc_params_t));
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(test1.bg_detect_enable, (uint32_t)0);
    ASSERT_EQ(test1.bg_lambda_qp, (int32_t)0);

    // 2. Set the values before initialize
    mc_video_smart_bg_enc_params_t smart_bg;
    memset(&smart_bg, 0x00, sizeof(mc_video_smart_bg_enc_params_t));
    smart_bg.bg_detect_enable = 0;
    ret = setFunc(context, &smart_bg);
    ASSERT_NE(ret, (int32_t)0);

    ret = hb_mm_mc_initialize(context);
    ASSERT_EQ(ret, (int32_t)0);

#ifndef J5
    memset(&smart_bg, 0x00, sizeof(mc_video_smart_bg_enc_params_t));
    smart_bg.bg_detect_enable = 0;
    ret = setFunc(context, &smart_bg);
    ASSERT_EQ(ret, (int32_t)0);

    memset(&smart_bg, 0x00, sizeof(mc_video_smart_bg_enc_params_t));
    smart_bg.bg_detect_enable = 1;
    smart_bg.bg_threshold_diff = 200;
    smart_bg.bg_threshold_mean_diff = 100;
    smart_bg.bg_lambda_qp = 30;
    smart_bg.bg_delta_qp = 10;
    smart_bg.s2fme_disable = 1;
    ret = setFunc(context, &smart_bg);
    ASSERT_EQ(ret, (int32_t)0);

    // 3. Test the values before configure
    memset(&test1, 0x00, sizeof(mc_video_smart_bg_enc_params_t));
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(compare_smart_bg(&test1, &smart_bg), (int32_t)0);

    ret = hb_mm_mc_configure(context);
    ASSERT_EQ(ret, (int32_t)0);

    // 4. Test the values after configure
    memset(&test1, 0x00, sizeof(mc_video_smart_bg_enc_params_t));
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(compare_smart_bg(&test1, &smart_bg), (int32_t)0);

    memset(&smart_bg, 0x00, sizeof(mc_video_smart_bg_enc_params_t));
    smart_bg.bg_detect_enable = 0;
    ret = setFunc(context, &smart_bg);
    ASSERT_NE(ret, (int32_t)0);

    memset(&smart_bg, 0x00, sizeof(mc_video_smart_bg_enc_params_t));
    smart_bg.bg_detect_enable = 1;
    smart_bg.bg_threshold_diff = 100;
    smart_bg.bg_threshold_mean_diff = 200;
    smart_bg.bg_lambda_qp = 40;
    smart_bg.bg_delta_qp = 5;
    smart_bg.s2fme_disable = 0;
    ret = setFunc(context, &smart_bg);
    ASSERT_EQ(ret, (int32_t)0);

    // 5. Test the values after configure again
    memset(&test1, 0x00, sizeof(mc_video_smart_bg_enc_params_t));
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(compare_smart_bg(&test1, &smart_bg), (int32_t)0);

    memset(&smart_bg, 0x00, sizeof(mc_video_smart_bg_enc_params_t));
    smart_bg.bg_detect_enable = 1;
    smart_bg.bg_threshold_diff = 50;
    smart_bg.bg_threshold_mean_diff = 100;
    smart_bg.bg_lambda_qp = 41;
    smart_bg.bg_delta_qp = 8;
    smart_bg.s2fme_disable = 1;
    ret = setFunc(context, &smart_bg);
    ASSERT_EQ(ret, (int32_t)0);

    // 6. Test the values after muti-setting
    memset(&test1, 0x00, sizeof(mc_video_smart_bg_enc_params_t));
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(compare_smart_bg(&test1, &smart_bg), (int32_t)0);

    // TODO Add the test after start and pause
    ret = hb_mm_mc_stop(context);
    EXPECT_EQ(ret, (int32_t)0);
#endif

    ret = hb_mm_mc_release(context);
    EXPECT_EQ(ret, (int32_t)0);
    if (context != NULL) {
        free(context);
    }
}

static int32_t compare_pred_unit(media_codec_id_t codec_id,
                mc_video_pred_unit_params_t *a,
                mc_video_pred_unit_params_t *b) {
    if (codec_id == MEDIA_CODEC_ID_H264) {
        EXPECT_EQ(a->h264_intra_pred.constrained_intra_pred_flag, b->h264_intra_pred.constrained_intra_pred_flag);
        if (a->h264_intra_pred.constrained_intra_pred_flag != b->h264_intra_pred.constrained_intra_pred_flag) {
            return -1;
        }
    } else {
        EXPECT_EQ(a->h265_pred_unit.intra_nxn_enable, b->h265_pred_unit.intra_nxn_enable);
        EXPECT_EQ(a->h265_pred_unit.constrained_intra_pred_flag, b->h265_pred_unit.constrained_intra_pred_flag);
        EXPECT_EQ(a->h265_pred_unit.strong_intra_smoothing_enabled_flag, b->h265_pred_unit.strong_intra_smoothing_enabled_flag);
        EXPECT_EQ(a->h265_pred_unit.max_num_merge, b->h265_pred_unit.max_num_merge);
        if (a->h265_pred_unit.intra_nxn_enable != b->h265_pred_unit.intra_nxn_enable ||
            a->h265_pred_unit.constrained_intra_pred_flag != b->h265_pred_unit.constrained_intra_pred_flag ||
            a->h265_pred_unit.strong_intra_smoothing_enabled_flag != 
            b->h265_pred_unit.strong_intra_smoothing_enabled_flag ||
            a->h265_pred_unit.max_num_merge != b->h265_pred_unit.max_num_merge) {
            return -1;
        }
    }
    return 0;
}

TEST_F(MediaCodecTest, test_hb_mm_mc_get_pred_unit_config) {
    hb_s32 ret = 0;
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    hb_s32 (*getFunc)(media_codec_context_t *context, mc_video_pred_unit_params_t *params) = hb_mm_mc_get_pred_unit_config;
    hb_s32 (*setFunc)(media_codec_context_t *context, const mc_video_pred_unit_params_t *params) = hb_mm_mc_set_pred_unit_config;

    // 1. Test the values before initialize
    mc_video_pred_unit_params_t test1;
    memset(&test1, 0x00, sizeof(mc_video_pred_unit_params_t));
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        ASSERT_EQ(test1.h264_intra_pred.constrained_intra_pred_flag, (uint32_t)0);
    } else {
        ASSERT_EQ(test1.h265_pred_unit.intra_nxn_enable, (uint32_t)TRUE);
        ASSERT_EQ(test1.h265_pred_unit.constrained_intra_pred_flag, (uint32_t)0);
        ASSERT_EQ(test1.h265_pred_unit.strong_intra_smoothing_enabled_flag, (uint32_t)0);
        ASSERT_EQ(test1.h265_pred_unit.max_num_merge, (uint32_t)0);
    }

    // 2. Set the values before initialize
    mc_video_pred_unit_params_t pred_unit;
    memset(&pred_unit, 0x00, sizeof(mc_video_pred_unit_params_t));
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        pred_unit.h264_intra_pred.constrained_intra_pred_flag = 0;
    } else {
        pred_unit.h265_pred_unit.intra_nxn_enable = 0;
        pred_unit.h265_pred_unit.constrained_intra_pred_flag = 1;
        pred_unit.h265_pred_unit.strong_intra_smoothing_enabled_flag = 1;
        pred_unit.h265_pred_unit.max_num_merge = 1;
    }
    ret = setFunc(context, &pred_unit);
    ASSERT_NE(ret, (int32_t)0);

    ret = hb_mm_mc_initialize(context);
    ASSERT_EQ(ret, (int32_t)0);

    memset(&pred_unit, 0x00, sizeof(mc_video_pred_unit_params_t));
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        pred_unit.h264_intra_pred.constrained_intra_pred_flag = 0;
    } else {
        pred_unit.h265_pred_unit.intra_nxn_enable = 0;
        pred_unit.h265_pred_unit.constrained_intra_pred_flag = 1;
#ifdef J5
        pred_unit.h265_pred_unit.strong_intra_smoothing_enabled_flag = 0;
#else
        pred_unit.h265_pred_unit.strong_intra_smoothing_enabled_flag = 1;
#endif
        pred_unit.h265_pred_unit.max_num_merge = 1;
    }
    ret = setFunc(context, &pred_unit);
    ASSERT_EQ(ret, (int32_t)0);

    // 3. Test the values before configure
    memset(&test1, 0x00, sizeof(mc_video_pred_unit_params_t));
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(compare_pred_unit(context->codec_id, &test1, &pred_unit), (int32_t)0);

    ret = hb_mm_mc_configure(context);
    ASSERT_EQ(ret, (int32_t)0);

    // 4. Test the values after configure
    memset(&test1, 0x00, sizeof(mc_video_pred_unit_params_t));
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(compare_pred_unit(context->codec_id, &test1, &pred_unit), (int32_t)0);

    memset(&pred_unit, 0x00, sizeof(mc_video_pred_unit_params_t));
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        pred_unit.h264_intra_pred.constrained_intra_pred_flag = 0;
    } else {
        pred_unit.h265_pred_unit.intra_nxn_enable = 0;
        pred_unit.h265_pred_unit.constrained_intra_pred_flag = 1;
#ifdef J5
        pred_unit.h265_pred_unit.strong_intra_smoothing_enabled_flag = 0;
#else
        pred_unit.h265_pred_unit.strong_intra_smoothing_enabled_flag = 1;
#endif
        pred_unit.h265_pred_unit.max_num_merge = 1;
    }
    ret = setFunc(context, &pred_unit);
    ASSERT_EQ(ret, (int32_t)0);

    // 5. Test the values after configure again
    memset(&test1, 0x00, sizeof(mc_video_pred_unit_params_t));
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(compare_pred_unit(context->codec_id, &test1, &pred_unit), (int32_t)0);

    memset(&pred_unit, 0x00, sizeof(mc_video_pred_unit_params_t));
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        pred_unit.h264_intra_pred.constrained_intra_pred_flag = 1;
    } else {
        pred_unit.h265_pred_unit.intra_nxn_enable = 0;
        pred_unit.h265_pred_unit.constrained_intra_pred_flag = 0;
#ifdef J5
        pred_unit.h265_pred_unit.strong_intra_smoothing_enabled_flag = 0;
#else
        pred_unit.h265_pred_unit.strong_intra_smoothing_enabled_flag = 1;
#endif
        pred_unit.h265_pred_unit.max_num_merge = 2;
    }
    ret = setFunc(context, &pred_unit);
    ASSERT_EQ(ret, (int32_t)0);

    // 6. Test the values after muti-setting
    memset(&test1, 0x00, sizeof(mc_video_pred_unit_params_t));
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(compare_pred_unit(context->codec_id, &test1, &pred_unit), (int32_t)0);

    // TODO Add the test after start and pause
    ret = hb_mm_mc_stop(context);
    EXPECT_EQ(ret, (int32_t)0);

    ret = hb_mm_mc_release(context);
    EXPECT_EQ(ret, (int32_t)0);
    if (context != NULL) {
        free(context);
    }
}

static int32_t compare_transform_config(media_codec_id_t codec_id,
                mc_video_transform_params_t *a,
                mc_video_transform_params_t *b) {
    if (codec_id == MEDIA_CODEC_ID_H264) {
        EXPECT_EQ(a->h264_transform.transform_8x8_enable, b->h264_transform.transform_8x8_enable);
        EXPECT_EQ(a->h264_transform.chroma_cb_qp_offset, b->h264_transform.chroma_cb_qp_offset);
        EXPECT_EQ(a->h264_transform.chroma_cr_qp_offset, b->h264_transform.chroma_cr_qp_offset);
        EXPECT_EQ(a->h264_transform.user_scaling_list_enable, b->h264_transform.user_scaling_list_enable);
        if (a->h264_transform.transform_8x8_enable != b->h264_transform.transform_8x8_enable ||
            a->h264_transform.chroma_cb_qp_offset != b->h264_transform.chroma_cb_qp_offset ||
            a->h264_transform.chroma_cr_qp_offset != b->h264_transform.chroma_cr_qp_offset ||
            a->h264_transform.user_scaling_list_enable != b->h264_transform.user_scaling_list_enable) {
            return -1;
        }
    } else {
        EXPECT_EQ(a->h265_transform.chroma_cb_qp_offset, b->h265_transform.chroma_cb_qp_offset);
        EXPECT_EQ(a->h265_transform.chroma_cr_qp_offset, b->h265_transform.chroma_cr_qp_offset);
        EXPECT_EQ(a->h265_transform.user_scaling_list_enable, b->h265_transform.user_scaling_list_enable);
        if (a->h265_transform.chroma_cb_qp_offset != b->h265_transform.chroma_cb_qp_offset ||
            a->h265_transform.chroma_cr_qp_offset != b->h265_transform.chroma_cr_qp_offset ||
            a->h265_transform.user_scaling_list_enable !=
            b->h265_transform.user_scaling_list_enable) {
            return -1;
        }
    }
    return 0;
}

TEST_F(MediaCodecTest, test_hb_mm_mc_get_transform_config) {
    hb_s32 ret = 0;
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    hb_s32 (*getFunc)(media_codec_context_t *context, mc_video_transform_params_t *params) = hb_mm_mc_get_transform_config;
    hb_s32 (*setFunc)(media_codec_context_t *context, const mc_video_transform_params_t *params) = hb_mm_mc_set_transform_config;

    // 1. Test the values before initialize
    mc_video_transform_params_t test1;
    memset(&test1, 0x00, sizeof(mc_video_transform_params_t));
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        ASSERT_EQ(test1.h264_transform.transform_8x8_enable, (uint32_t)FALSE);
        ASSERT_EQ(test1.h264_transform.chroma_cb_qp_offset, (int32_t)0);
        ASSERT_EQ(test1.h264_transform.chroma_cr_qp_offset, (int32_t)0);
        ASSERT_EQ(test1.h264_transform.user_scaling_list_enable, (uint32_t)0);
    } else {
        ASSERT_EQ(test1.h265_transform.chroma_cb_qp_offset, (int32_t)0);
        ASSERT_EQ(test1.h265_transform.chroma_cr_qp_offset, (int32_t)0);
        ASSERT_EQ(test1.h265_transform.user_scaling_list_enable, (uint32_t)0);
    }

    // 2. Set the values before initialize
    mc_video_transform_params_t trans_params;
    memset(&trans_params, 0x00, sizeof(mc_video_transform_params_t));
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        trans_params.h264_transform.transform_8x8_enable = 1;
        trans_params.h264_transform.chroma_cb_qp_offset = 2;
        trans_params.h264_transform.chroma_cr_qp_offset = 3;
        trans_params.h264_transform.user_scaling_list_enable = 0;
    } else {
        trans_params.h265_transform.chroma_cb_qp_offset = 2;
        trans_params.h265_transform.chroma_cr_qp_offset = 3;
        trans_params.h265_transform.user_scaling_list_enable = 0;
    }
    ret = setFunc(context, &trans_params);
    ASSERT_NE(ret, (int32_t)0);

    ret = hb_mm_mc_initialize(context);
    ASSERT_EQ(ret, (int32_t)0);

    memset(&trans_params, 0x00, sizeof(mc_video_transform_params_t));
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        trans_params.h264_transform.transform_8x8_enable = 1;
        trans_params.h264_transform.chroma_cb_qp_offset = 2;
        trans_params.h264_transform.chroma_cr_qp_offset = 3;
        trans_params.h264_transform.user_scaling_list_enable = 0;
    } else {
#ifndef J5
        trans_params.h265_transform.chroma_cb_qp_offset = 2;
        trans_params.h265_transform.chroma_cr_qp_offset = 3;
#endif
        trans_params.h265_transform.user_scaling_list_enable = 0;
    }
    ret = setFunc(context, &trans_params);
    ASSERT_EQ(ret, (int32_t)0);

    // 3. Test the values before configure
    memset(&test1, 0x00, sizeof(mc_video_transform_params_t));
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(compare_transform_config(context->codec_id, &test1, &trans_params), (int32_t)0);

    ret = hb_mm_mc_configure(context);
    ASSERT_EQ(ret, (int32_t)0);

    // 4. Test the values after configure
    memset(&test1, 0x00, sizeof(mc_video_transform_params_t));
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(compare_transform_config(context->codec_id, &test1, &trans_params), (int32_t)0);

    memset(&trans_params, 0x00, sizeof(mc_video_transform_params_t));
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        trans_params.h264_transform.transform_8x8_enable = 1;
        trans_params.h264_transform.chroma_cb_qp_offset = 5;
        trans_params.h264_transform.chroma_cr_qp_offset = 4;
        trans_params.h264_transform.user_scaling_list_enable = 0;
    } else {
#ifndef J5
        trans_params.h265_transform.chroma_cb_qp_offset = 5;
        trans_params.h265_transform.chroma_cr_qp_offset = 4;
#endif
        trans_params.h265_transform.user_scaling_list_enable = 0;
    }
    ret = setFunc(context, &trans_params);
    ASSERT_EQ(ret, (int32_t)0);

    // 5. Test the values after configure again
    memset(&test1, 0x00, sizeof(mc_video_transform_params_t));
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(compare_transform_config(context->codec_id, &test1, &trans_params), (int32_t)0);

    memset(&trans_params, 0x00, sizeof(mc_video_transform_params_t));
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        trans_params.h264_transform.transform_8x8_enable = 1;
        trans_params.h264_transform.chroma_cb_qp_offset = 6;
        trans_params.h264_transform.chroma_cr_qp_offset = 6;
        trans_params.h264_transform.user_scaling_list_enable = 0;
    } else {
#ifndef J5
        trans_params.h265_transform.chroma_cb_qp_offset = 6;
        trans_params.h265_transform.chroma_cr_qp_offset = 6;
#endif
        trans_params.h265_transform.user_scaling_list_enable = 0;
    }
    ret = setFunc(context, &trans_params);
    ASSERT_EQ(ret, (int32_t)0);

    // 6. Test the values after muti-setting
    memset(&test1, 0x00, sizeof(mc_video_transform_params_t));
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(compare_transform_config(context->codec_id, &test1, &trans_params), (int32_t)0);

    // TODO Add the test after start and pause
    ret = hb_mm_mc_stop(context);
    EXPECT_EQ(ret, (int32_t)0);

    ret = hb_mm_mc_release(context);
    EXPECT_EQ(ret, (int32_t)0);
    if (context != NULL) {
        free(context);
    }
}

static int32_t compare_roi_params(mc_video_roi_params_t *a,
                mc_video_roi_params_t *b) {
    EXPECT_EQ(a->roi_enable, b->roi_enable);
    EXPECT_EQ(a->roi_map_array, b->roi_map_array);
    EXPECT_EQ(a->roi_map_array_count, b->roi_map_array_count);
    if (a->roi_enable != b->roi_enable ||
        a->roi_map_array != b->roi_map_array ||
        a->roi_map_array_count != b->roi_map_array_count) {
        return -1;
    }
    return 0;
}

TEST_F(MediaCodecTest, test_hb_mm_mc_get_roi_config) {
    hb_s32 ret = 0;
    mc_video_codec_enc_params_t *params;
    hb_u32 array_count = 0;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        array_count = (((params->width)+0x0f)&~0x0f)/16 *
            (((params->height)+0x0f)&~0x0f)/16;
    } else {
#ifdef J5
        array_count = (((params->width)+0x3f)&~0x3f)/64 *
            (((params->height)+0x3f)&~0x3f)/64;
#else
        array_count = (((params->width)+0x3f)&~0x3f)/32 *
            (((params->height)+0x3f)&~0x3f)/32;
#endif
    }

    hb_s32 (*getFunc)(media_codec_context_t *context, mc_video_roi_params_t *params) = hb_mm_mc_get_roi_config;
    hb_s32 (*setFunc)(media_codec_context_t *context, const mc_video_roi_params_t *params) = hb_mm_mc_set_roi_config;

    // 1. Test the values before initialize
    mc_video_roi_params_t test1;
    memset(&test1, 0x00, sizeof(mc_video_roi_params_t));
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(test1.roi_enable, (uint32_t)FALSE);
    ASSERT_EQ(test1.roi_map_array, nullptr);
    ASSERT_EQ(test1.roi_map_array_count, (uint32_t)0);

    // 2. Set the values before initialize
    mc_video_roi_params_t roi_params;
    memset(&roi_params, 0x00, sizeof(mc_video_roi_params_t));
    roi_params.roi_enable = 1;
    unsigned char roiMap[MC_VIDEO_MAX_MB_NUM] = {30,};
    roi_params.roi_map_array = roiMap;
    roi_params.roi_map_array_count = array_count;
    ret = setFunc(context, &roi_params);
    ASSERT_NE(ret, (int32_t)0);

    ret = hb_mm_mc_initialize(context);
    ASSERT_EQ(ret, (int32_t)0);

    memset(&roi_params, 0x00, sizeof(mc_video_roi_params_t));
    roi_params.roi_enable = 1;
    unsigned char roiMap2[MC_VIDEO_MAX_MB_NUM] = {30,};
    roi_params.roi_map_array = roiMap2;
    roi_params.roi_map_array_count = array_count;
    ret = setFunc(context, &roi_params);
    ASSERT_EQ(ret, (int32_t)0);

    // 3. Test the values before configure
    memset(&test1, 0x00, sizeof(mc_video_roi_params_t));
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(compare_roi_params(&test1, &roi_params), (int32_t)0);

    ret = hb_mm_mc_configure(context);
    ASSERT_EQ(ret, (int32_t)0);

    // 4. Test the values after configure
    memset(&test1, 0x00, sizeof(mc_video_roi_params_t));
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(compare_roi_params(&test1, &roi_params), (int32_t)0);

    memset(&roi_params, 0x00, sizeof(mc_video_roi_params_t));
    roi_params.roi_enable = 1;
    unsigned char roiMap3[MC_VIDEO_MAX_MB_NUM] = {50,};
    roi_params.roi_map_array = roiMap3;
    roi_params.roi_map_array_count = array_count;
    ret = setFunc(context, &roi_params);
    ASSERT_EQ(ret, (int32_t)0);

    mc_video_roi_params_t roi_params2;
    memset(&roi_params2, 0x00, sizeof(mc_video_roi_params_t));
    roi_params2.roi_enable = 0;
    roi_params2.roi_map_array = NULL;
    roi_params2.roi_map_array_count = 0;
    ret = setFunc(context, &roi_params2);
    ASSERT_NE(ret, (int32_t)0);

    // 5. Test the values after configure again
    memset(&test1, 0x00, sizeof(mc_video_roi_params_t));
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(compare_roi_params(&test1, &roi_params), (int32_t)0);

    memset(&roi_params, 0x00, sizeof(mc_video_roi_params_t));
    roi_params.roi_enable = 1;
    unsigned char roiMap4[MC_VIDEO_MAX_MB_NUM] = {50,};
    roi_params.roi_map_array = roiMap4;
    roi_params.roi_map_array_count = array_count;
    ret = setFunc(context, &roi_params);
    ASSERT_EQ(ret, (int32_t)0);

    // 6. Test the values after muti-setting
    memset(&test1, 0x00, sizeof(mc_video_roi_params_t));
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(compare_roi_params(&test1, &roi_params), (int32_t)0);

    // TODO Add the test after start and pause
    ret = hb_mm_mc_stop(context);
    EXPECT_EQ(ret, (int32_t)0);

    ret = hb_mm_mc_release(context);
    EXPECT_EQ(ret, (int32_t)0);
    if (context != NULL) {
        free(context);
    }
}

#ifdef J5
static int32_t compare_roi_params_ex(mc_video_roi_params_ex_t *a,
                mc_video_roi_params_ex_t *b) {
    EXPECT_EQ(a->roi_mode, b->roi_mode);
    EXPECT_EQ(a->roi_idx, b->roi_idx);
    EXPECT_EQ(a->roi_enable, b->roi_enable);
    EXPECT_EQ(a->roi_val, b->roi_val);
    EXPECT_EQ(a->roi_delta_qp, b->roi_delta_qp);
    EXPECT_EQ(a->crop_rect.x_pos, b->crop_rect.x_pos);
    EXPECT_EQ(a->crop_rect.y_pos, b->crop_rect.y_pos);
    EXPECT_EQ(a->crop_rect.width, b->crop_rect.width);
    EXPECT_EQ(a->crop_rect.height, b->crop_rect.height);
    if (a->roi_enable != b->roi_enable ||
        a->roi_idx != b->roi_idx ||
        a->roi_enable != b->roi_enable ||
        a->roi_val != b->roi_val ||
        a->roi_delta_qp != b->roi_delta_qp ||
        a->crop_rect.x_pos != b->crop_rect.x_pos ||
        a->crop_rect.y_pos != b->crop_rect.y_pos ||
        a->crop_rect.width != b->crop_rect.width ||
        a->crop_rect.height != b->crop_rect.height) {
        return -1;
    }

    return 0;
}

TEST_F(MediaCodecTest, test_hb_mm_mc_get_roi_config_ex) {
    hb_s32 ret = 0;
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    hb_s32 (*getFunc)(media_codec_context_t *context, hb_u32 roi_idx, mc_video_roi_params_ex_t *params) = hb_mm_mc_get_roi_config_ex;
    hb_s32 (*setFunc)(media_codec_context_t *context, const mc_video_roi_params_ex_t *params) = hb_mm_mc_set_roi_config_ex;

    // 1. Test the values before initialize
    mc_video_roi_params_ex_t test1;
    mc_video_roi_params_ex_t roi_params = {0,};
    roi_params.roi_delta_qp = 3;
    memset(&test1, 0x00, sizeof(mc_video_roi_params_ex_t));
    ret = getFunc(context, test1.roi_idx, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(compare_roi_params_ex(&test1, &roi_params), (int32_t)0);

    // 2. Set the values before initialize
    memset(&roi_params, 0x00, sizeof(mc_video_roi_params_ex_t));
    roi_params.roi_mode  = 1;
    roi_params.roi_idx = 0;
    roi_params.roi_enable = 1;
    roi_params.roi_val = 6;
    roi_params.roi_delta_qp = 3;
    roi_params.crop_rect.x_pos = 0;
    roi_params.crop_rect.y_pos = 0;
    roi_params.crop_rect.width = (params->width + 63)/64 -1;
    roi_params.crop_rect.height = (params->height + 63)/64 -1;
    ret = setFunc(context, &roi_params);
    ASSERT_NE(ret, (int32_t)0);

    ret = hb_mm_mc_initialize(context);
    ASSERT_EQ(ret, (int32_t)0);

    ret = setFunc(context, &roi_params);
    ASSERT_EQ(ret, (int32_t)0);

    // 3. Test the values before configure
    memset(&test1, 0x00, sizeof(mc_video_roi_params_t));
    ret = getFunc(context, test1.roi_idx, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(compare_roi_params_ex(&test1, &roi_params), (int32_t)0);

    ret = hb_mm_mc_configure(context);
    ASSERT_EQ(ret, (int32_t)0);

    // 4. Test the values after configure
    memset(&test1, 0x00, sizeof(mc_video_roi_params_t));
    ret = getFunc(context, test1.roi_idx, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(compare_roi_params_ex(&test1, &roi_params), (int32_t)0);

    memset(&roi_params, 0x00, sizeof(mc_video_roi_params_ex_t));
    roi_params.roi_mode  = 1;
    roi_params.roi_idx = 1;
    roi_params.roi_enable = 1;
    roi_params.roi_val = 6;
    roi_params.roi_delta_qp = 3;
    roi_params.crop_rect.x_pos = 0;
    roi_params.crop_rect.y_pos = 0;
    roi_params.crop_rect.width = (params->width + 63)/64 -1;
    roi_params.crop_rect.height = (params->height + 63)/64 -1;
    ret = setFunc(context, &roi_params);
    ASSERT_EQ(ret, (int32_t)0);

    mc_video_roi_params_ex_t roi_params2;
    memset(&roi_params2, 0x00, sizeof(mc_video_roi_params_t));
    roi_params2.roi_mode  = 0;
    roi_params2.roi_idx = 1;
    roi_params2.roi_enable = 1;
    roi_params2.roi_val = 6;
    roi_params2.roi_delta_qp = 3;
    roi_params2.crop_rect.x_pos = 0;
    roi_params2.crop_rect.y_pos = 0;
    roi_params2.crop_rect.width = (params->width + 63)/64 -1;
    roi_params2.crop_rect.height = (params->height + 63)/64 -1;
    ret = setFunc(context, &roi_params2);
    ASSERT_NE(ret, (int32_t)0);

    // 5. Test the values after configure again
    memset(&test1, 0x00, sizeof(mc_video_roi_params_ex_t));
    test1.roi_idx = roi_params.roi_idx;
    ret = getFunc(context, test1.roi_idx, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(compare_roi_params_ex(&test1, &roi_params), (int32_t)0);

    memset(&roi_params, 0x00, sizeof(mc_video_roi_params_ex_t));
    roi_params.roi_mode  = 1;
    roi_params.roi_idx = 1;
    roi_params.roi_enable = 1;
    roi_params.roi_val = 8;
    roi_params.roi_delta_qp = 6;
    roi_params.crop_rect.x_pos = 0;
    roi_params.crop_rect.y_pos = 0;
    roi_params.crop_rect.width = (params->width + 63)/64 -2;
    roi_params.crop_rect.height = (params->height + 63)/64 -2;
    ret = setFunc(context, &roi_params);
    ASSERT_EQ(ret, (int32_t)0);

    // 6. Test the values after muti-setting
    memset(&test1, 0x00, sizeof(mc_video_roi_params_ex_t));
    test1.roi_idx = roi_params.roi_idx;
    ret = getFunc(context, test1.roi_idx, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(compare_roi_params_ex(&test1, &roi_params), (int32_t)0);

    // TODO Add the test after start and pause
    ret = hb_mm_mc_stop(context);
    EXPECT_EQ(ret, (int32_t)0);

    ret = hb_mm_mc_release(context);
    EXPECT_EQ(ret, (int32_t)0);
    if (context != NULL) {
        free(context);
    }
}
#endif

TEST_F(MediaCodecTest, test_hb_mm_mc_get_roi_avgqp_config) {
    hb_s32 ret = 0;
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    hb_s32 (*getFunc)(media_codec_context_t *context, hb_u32 *params) = hb_mm_mc_get_roi_avg_qp;
    hb_s32 (*setFunc)(media_codec_context_t *context, hb_u32 params) = hb_mm_mc_set_roi_avg_qp;

    // 1. Test the values before initialize
    hb_u32 test1 = 0;
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(test1, (uint32_t)0);

    // 2. Set the values before initialize
    hb_u32 roi_avg_qp_params = 30;
    ret = setFunc(context, roi_avg_qp_params);
    ASSERT_NE(ret, (int32_t)0);

    ret = hb_mm_mc_initialize(context);
    ASSERT_EQ(ret, (int32_t)0);

    roi_avg_qp_params = 8;
    ret = setFunc(context, roi_avg_qp_params);
    ASSERT_EQ(ret, (int32_t)0);

    // 3. Test the values before configure
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(test1, roi_avg_qp_params);

    ret = hb_mm_mc_configure(context);
    ASSERT_EQ(ret, (int32_t)0);

    // 4. Test the values after configure
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(test1, roi_avg_qp_params);

    roi_avg_qp_params = 40;
    ret = setFunc(context, roi_avg_qp_params);
    ASSERT_EQ(ret, (int32_t)0);

    roi_avg_qp_params = 45;
    ret = setFunc(context, roi_avg_qp_params);
    ASSERT_EQ(ret, (int32_t)0);

    // 5. Test the values after configure again
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(test1, roi_avg_qp_params);

    roi_avg_qp_params = 25;
    ret = setFunc(context, roi_avg_qp_params);
    ASSERT_EQ(ret, (int32_t)0);

    // 6. Test the values after muti-setting
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(test1, roi_avg_qp_params);

    context->codec_id = MEDIA_CODEC_ID_JPEG;
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)HB_MEDIA_ERR_OPERATION_NOT_ALLOWED);
    context->codec_id = MEDIA_CODEC_ID_H265;

    // TODO Add the test after start and pause
    ret = hb_mm_mc_stop(context);
    EXPECT_EQ(ret, (int32_t)0);

    ret = hb_mm_mc_release(context);
    EXPECT_EQ(ret, (int32_t)0);
    if (context != NULL) {
        free(context);
    }
}

#ifndef J5
static int32_t compare_mode_decision(mc_video_mode_decision_params_t *a,
                mc_video_mode_decision_params_t *b) {
    EXPECT_EQ(a->mode_decision_enable, b->mode_decision_enable);
    EXPECT_EQ(a->pu04_delta_rate, b->pu04_delta_rate);
    EXPECT_EQ(a->pu08_delta_rate, b->pu08_delta_rate);
    EXPECT_EQ(a->pu16_delta_rate, b->pu16_delta_rate);
    EXPECT_EQ(a->pu32_delta_rate, b->pu32_delta_rate);
    EXPECT_EQ(a->pu04_intra_planar_delta_rate, b->pu04_intra_planar_delta_rate);
    EXPECT_EQ(a->pu04_intra_dc_delta_rate, b->pu04_intra_dc_delta_rate);
    EXPECT_EQ(a->pu04_intra_angle_delta_rate, b->pu04_intra_angle_delta_rate);
    EXPECT_EQ(a->pu08_intra_planar_delta_rate, b->pu08_intra_planar_delta_rate);
    EXPECT_EQ(a->pu08_intra_dc_delta_rate, b->pu08_intra_dc_delta_rate);
    EXPECT_EQ(a->pu08_intra_angle_delta_rate, b->pu08_intra_angle_delta_rate);
    EXPECT_EQ(a->pu16_intra_planar_delta_rate, b->pu16_intra_planar_delta_rate);
    EXPECT_EQ(a->pu16_intra_dc_delta_rate, b->pu16_intra_dc_delta_rate);
    EXPECT_EQ(a->pu16_intra_angle_delta_rate, b->pu16_intra_angle_delta_rate);
    EXPECT_EQ(a->pu32_intra_planar_delta_rate, b->pu32_intra_planar_delta_rate);
    EXPECT_EQ(a->pu32_intra_dc_delta_rate, b->pu32_intra_dc_delta_rate);
    EXPECT_EQ(a->pu32_intra_angle_delta_rate, b->pu32_intra_angle_delta_rate);
    EXPECT_EQ(a->cu08_intra_delta_rate, b->cu08_intra_delta_rate);
    EXPECT_EQ(a->cu08_inter_delta_rate, b->cu08_inter_delta_rate);
    EXPECT_EQ(a->cu08_merge_delta_rate, b->cu08_merge_delta_rate);
    EXPECT_EQ(a->cu16_intra_delta_rate, b->cu16_intra_delta_rate);
    EXPECT_EQ(a->cu16_inter_delta_rate, b->cu16_inter_delta_rate);
    EXPECT_EQ(a->cu16_merge_delta_rate, b->cu16_merge_delta_rate);
    EXPECT_EQ(a->cu32_intra_delta_rate, b->cu32_intra_delta_rate);
    EXPECT_EQ(a->cu32_inter_delta_rate, b->cu32_inter_delta_rate);
    EXPECT_EQ(a->cu32_merge_delta_rate, b->cu32_merge_delta_rate);
    if (a->mode_decision_enable != b->mode_decision_enable ||
        a->pu04_delta_rate != b->pu04_delta_rate ||
        a->pu08_delta_rate != b->pu08_delta_rate ||
        a->pu16_delta_rate != b->pu16_delta_rate ||
        a->pu32_delta_rate != b->pu32_delta_rate ||
        a->pu04_intra_planar_delta_rate != b->pu04_intra_planar_delta_rate ||
        a->pu04_intra_dc_delta_rate != b->pu04_intra_dc_delta_rate ||
        a->pu04_intra_angle_delta_rate != b->pu04_intra_angle_delta_rate ||
        a->pu08_intra_planar_delta_rate != b->pu08_intra_planar_delta_rate ||
        a->pu08_intra_dc_delta_rate != b->pu08_intra_dc_delta_rate ||
        a->pu08_intra_angle_delta_rate != b->pu08_intra_angle_delta_rate ||
        a->pu16_intra_planar_delta_rate != b->pu16_intra_planar_delta_rate ||
        a->pu16_intra_dc_delta_rate != b->pu16_intra_dc_delta_rate ||
        a->pu16_intra_angle_delta_rate != b->pu16_intra_angle_delta_rate ||
        a->pu32_intra_planar_delta_rate != b->pu32_intra_planar_delta_rate ||
        a->pu32_intra_dc_delta_rate != b->pu32_intra_dc_delta_rate ||
        a->pu32_intra_angle_delta_rate != b->pu32_intra_angle_delta_rate ||
        a->cu08_intra_delta_rate != b->cu08_intra_delta_rate ||
        a->cu08_inter_delta_rate != b->cu08_inter_delta_rate ||
        a->cu08_merge_delta_rate != b->cu08_merge_delta_rate ||
        a->cu16_intra_delta_rate != b->cu16_intra_delta_rate ||
        a->cu16_inter_delta_rate != b->cu16_inter_delta_rate ||
        a->cu16_merge_delta_rate != b->cu16_merge_delta_rate ||
        a->cu32_intra_delta_rate != b->cu32_intra_delta_rate ||
        a->cu32_inter_delta_rate != b->cu32_inter_delta_rate ||
        a->cu32_merge_delta_rate!= b->cu32_merge_delta_rate) {
        return -1;
    }
    return 0;
}
#endif

TEST_F(MediaCodecTest, test_hb_mm_mc_get_mode_decision_config) {
    hb_s32 ret = 0;
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    mTestCodec = TEST_CODEC_ID_H265;
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    hb_s32 (*getFunc)(media_codec_context_t *context, mc_video_mode_decision_params_t *params) = hb_mm_mc_get_mode_decision_config;
    hb_s32 (*setFunc)(media_codec_context_t *context, const mc_video_mode_decision_params_t *params) = hb_mm_mc_set_mode_decision_config;

    // 1. Test the values before initialize
    mc_video_mode_decision_params_t test1;
    memset(&test1, 0x00, sizeof(mc_video_mode_decision_params_t));
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(test1.mode_decision_enable, (uint32_t)0);
    ASSERT_EQ(test1.pu04_delta_rate, (int32_t)0);
    ASSERT_EQ(test1.pu08_delta_rate, (int32_t)0);
    ASSERT_EQ(test1.pu16_delta_rate, (int32_t)0);
    ASSERT_EQ(test1.pu32_delta_rate, (int32_t)0);
    ASSERT_EQ(test1.pu04_intra_planar_delta_rate, (int32_t)0);
    ASSERT_EQ(test1.pu04_intra_dc_delta_rate, (int32_t)0);
    ASSERT_EQ(test1.pu04_intra_angle_delta_rate, (int32_t)0);
    ASSERT_EQ(test1.pu08_intra_planar_delta_rate, (int32_t)0);
    ASSERT_EQ(test1.pu08_intra_dc_delta_rate, (int32_t)0);
    ASSERT_EQ(test1.pu08_intra_angle_delta_rate, (int32_t)0);
    ASSERT_EQ(test1.pu16_intra_planar_delta_rate, (int32_t)0);
    ASSERT_EQ(test1.pu16_intra_dc_delta_rate, (int32_t)0);
    ASSERT_EQ(test1.pu16_intra_angle_delta_rate, (int32_t)0);
    ASSERT_EQ(test1.pu32_intra_planar_delta_rate, (int32_t)0);
    ASSERT_EQ(test1.pu32_intra_dc_delta_rate, (int32_t)0);
    ASSERT_EQ(test1.pu32_intra_angle_delta_rate, (int32_t)0);
    ASSERT_EQ(test1.cu08_intra_delta_rate, (int32_t)0);
    ASSERT_EQ(test1.cu08_inter_delta_rate, (int32_t)0);
    ASSERT_EQ(test1.cu08_merge_delta_rate, (int32_t)0);
    ASSERT_EQ(test1.cu16_intra_delta_rate, (int32_t)0);
    ASSERT_EQ(test1.cu16_inter_delta_rate, (int32_t)0);
    ASSERT_EQ(test1.cu16_merge_delta_rate, (int32_t)0);
    ASSERT_EQ(test1.cu32_intra_delta_rate, (int32_t)0);
    ASSERT_EQ(test1.cu32_inter_delta_rate, (int32_t)0);
    ASSERT_EQ(test1.cu32_merge_delta_rate, (int32_t)0);

    // 2. Set the values before initialize
    mc_video_mode_decision_params_t mode_dec;
    memset(&mode_dec, 0x00, sizeof(mc_video_mode_decision_params_t));
    mode_dec.mode_decision_enable = 1;
    mode_dec.pu04_delta_rate = 200;
    mode_dec.pu04_intra_dc_delta_rate = 100;
    mode_dec.cu08_intra_delta_rate = 100;
    mode_dec.cu32_inter_delta_rate = 200;
    ret = setFunc(context, &mode_dec);
    ASSERT_NE(ret, (int32_t)0);

    ret = hb_mm_mc_initialize(context);
    ASSERT_EQ(ret, (int32_t)0);

#ifndef J5
    memset(&mode_dec, 0x00, sizeof(mc_video_mode_decision_params_t));
    mode_dec.mode_decision_enable = 1;
    mode_dec.pu04_delta_rate = 200;
    mode_dec.pu04_intra_dc_delta_rate = 100;
    mode_dec.cu08_intra_delta_rate = 100;
    mode_dec.cu32_inter_delta_rate = 200;
    ret = setFunc(context, &mode_dec);
    ASSERT_EQ(ret, (int32_t)0);

    // 3. Test the values before configure
    memset(&test1, 0x00, sizeof(mc_video_mode_decision_params_t));
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(compare_mode_decision(&test1, &mode_dec), (int32_t)0);

    ret = hb_mm_mc_configure(context);
    ASSERT_EQ(ret, (int32_t)0);

    // 4. Test the values after configure
    memset(&test1, 0x00, sizeof(mc_video_mode_decision_params_t));
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(compare_mode_decision(&test1, &mode_dec), (int32_t)0);

    memset(&mode_dec, 0x00, sizeof(mc_video_mode_decision_params_t));
    mode_dec.mode_decision_enable = 1;
    mode_dec.pu04_delta_rate = 100;
    mode_dec.pu04_intra_dc_delta_rate = 200;
    mode_dec.cu08_intra_delta_rate = 200;
    mode_dec.cu32_inter_delta_rate = 100;
    ret = setFunc(context, &mode_dec);
    ASSERT_EQ(ret, (int32_t)0);

    // 5. Test the values after configure again
    memset(&test1, 0x00, sizeof(mc_video_mode_decision_params_t));
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(compare_mode_decision(&test1, &mode_dec), (int32_t)0);

    memset(&mode_dec, 0x00, sizeof(mc_video_mode_decision_params_t));
    mode_dec.mode_decision_enable = 1;
    mode_dec.pu04_delta_rate = 50;
    mode_dec.pu04_intra_dc_delta_rate = 50;
    mode_dec.cu08_intra_delta_rate = 50;
    mode_dec.cu32_inter_delta_rate = 50;
    ret = setFunc(context, &mode_dec);
    ASSERT_EQ(ret, (int32_t)0);

    // 6. Test the values after muti-setting
    memset(&test1, 0x00, sizeof(mc_video_mode_decision_params_t));
    ret = getFunc(context, &test1);
    ASSERT_EQ(ret, (int32_t)0);
    ASSERT_EQ(compare_mode_decision(&test1, &mode_dec), (int32_t)0);

    // TODO Add the test after start and pause
    ret = hb_mm_mc_stop(context);
    EXPECT_EQ(ret, (int32_t)0);
#endif

    ret = hb_mm_mc_release(context);
    EXPECT_EQ(ret, (int32_t)0);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_hb_mm_mc_get_fd) {
    mc_video_codec_enc_params_t *params;
    hb_s32 selectFd, selectFd2;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    // Test before initialization
    ASSERT_EQ(hb_mm_mc_get_fd(context, &selectFd),
        (int32_t)HB_MEDIA_ERR_OPERATION_NOT_ALLOWED);

    ASSERT_EQ(hb_mm_mc_initialize(context), 0);
    ASSERT_EQ(hb_mm_mc_get_fd(context, &selectFd), (int32_t)0);
    ASSERT_GT(selectFd, 0);
    ASSERT_EQ(hb_mm_mc_close_fd(context, selectFd), (int32_t)0);

    ASSERT_EQ(hb_mm_mc_configure(context), (int32_t)0);
    ASSERT_EQ(hb_mm_mc_get_fd(context, &selectFd), (int32_t)0);
    ASSERT_GT(selectFd, 0);
    ASSERT_EQ(hb_mm_mc_close_fd(context, selectFd), (int32_t)0);

    ASSERT_EQ(hb_mm_mc_start(context, NULL), (int32_t)0);
    ASSERT_EQ(hb_mm_mc_get_fd(context, &selectFd), (int32_t)0);
    ASSERT_GT(selectFd, 0);
    ASSERT_EQ(hb_mm_mc_close_fd(context, selectFd), (int32_t)0);

    // Test invalid parameters
    ASSERT_EQ(hb_mm_mc_get_fd(NULL, &selectFd),
        (int32_t)HB_MEDIA_ERR_INVALID_PARAMS);
    ASSERT_EQ(hb_mm_mc_get_fd(context, NULL),
        (int32_t)HB_MEDIA_ERR_INVALID_PARAMS);
    int32_t tmp = context->instance_index;
    context->instance_index = -1;
    ASSERT_EQ(hb_mm_mc_get_fd(context, &selectFd),
        (int32_t)HB_MEDIA_ERR_INVALID_INSTANCE);
    context->instance_index = tmp;

    ASSERT_EQ(hb_mm_mc_get_fd(context, &selectFd), (int32_t)0);
    ASSERT_GT(selectFd, 0);
    ASSERT_EQ(hb_mm_mc_get_fd(context, &selectFd2), (int32_t)0);
    ASSERT_GT(selectFd2, 0);
    ASSERT_EQ(hb_mm_mc_close_fd(context, selectFd), (int32_t)0);
    ASSERT_NE(hb_mm_mc_close_fd(context, selectFd2), (int32_t)0);

    ASSERT_EQ(hb_mm_mc_release(context), (int32_t)0);
    ASSERT_EQ(hb_mm_mc_get_fd(context, &selectFd),
        (int32_t)HB_MEDIA_ERR_OPERATION_NOT_ALLOWED);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_hb_mm_mc_close_fd) {
    mc_video_codec_enc_params_t *params;
    hb_s32 selectFd;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    // Test before initialization
    selectFd = 2;
    ASSERT_EQ(hb_mm_mc_close_fd(context, selectFd),
        (int32_t)HB_MEDIA_ERR_OPERATION_NOT_ALLOWED);

    ASSERT_EQ(hb_mm_mc_initialize(context), 0);
    ASSERT_EQ(hb_mm_mc_get_fd(context, &selectFd), (int32_t)0);
    ASSERT_GT(selectFd, 0);
    ASSERT_EQ(hb_mm_mc_close_fd(context, selectFd), (int32_t)0);

    ASSERT_EQ(hb_mm_mc_configure(context), (int32_t)0);
    ASSERT_EQ(hb_mm_mc_get_fd(context, &selectFd), (int32_t)0);
    ASSERT_GT(selectFd, 0);
    ASSERT_EQ(hb_mm_mc_close_fd(context, selectFd), (int32_t)0);

    ASSERT_EQ(hb_mm_mc_start(context, NULL), (int32_t)0);
    ASSERT_EQ(hb_mm_mc_get_fd(context, &selectFd), (int32_t)0);
    ASSERT_GT(selectFd, 0);
    ASSERT_EQ(hb_mm_mc_close_fd(context, selectFd), (int32_t)0);

    // Test invalid parameters
    ASSERT_EQ(hb_mm_mc_get_fd(context, &selectFd), (int32_t)0);
    ASSERT_GT(selectFd, 0);
    ASSERT_EQ(hb_mm_mc_close_fd(NULL, selectFd),
        (int32_t)HB_MEDIA_ERR_INVALID_PARAMS);
    ASSERT_EQ(hb_mm_mc_close_fd(NULL, -1),
        (int32_t)HB_MEDIA_ERR_INVALID_PARAMS);

    int32_t tmp = context->instance_index;
    context->instance_index = -1;
    ASSERT_EQ(hb_mm_mc_close_fd(context, selectFd),
        (int32_t)HB_MEDIA_ERR_INVALID_INSTANCE);
    context->instance_index = tmp;
    ASSERT_EQ(hb_mm_mc_close_fd(context, selectFd), (int32_t)0);

    ASSERT_EQ(hb_mm_mc_get_fd(context, &selectFd), (int32_t)0);
    ASSERT_GT(selectFd, 0);
    ASSERT_EQ(hb_mm_mc_close_fd(context, selectFd), (int32_t)0);
    ASSERT_NE(hb_mm_mc_close_fd(context, selectFd),
        (int32_t)0);

    ASSERT_EQ(hb_mm_mc_release(context), (int32_t)0);
    ASSERT_EQ(hb_mm_mc_close_fd(context, selectFd),
        (int32_t)HB_MEDIA_ERR_OPERATION_NOT_ALLOWED);
    if (context != NULL) {
        free(context);
    }
}

#ifdef J5
TEST_F(MediaCodecTest, test_hb_mm_mc_H264_enc) {
    mc_video_codec_enc_params_t* params;
    media_codec_context_t context;
    memset(&context, 0x00, sizeof(media_codec_context_t));
    context.codec_id = MEDIA_CODEC_ID_H264;
    context.encoder = TRUE;
    params = &context.video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    hb_mm_mc_get_rate_control_config(&context, &params->rc_params);
    EXPECT_EQ(hb_mm_mc_initialize(&context), int32_t(HB_MEDIA_ERR_INVALID_PARAMS));
}
#endif

TEST_F(MediaCodecTest, test_hb_mm_mc_use_enc_interface_when_dec) {
    mc_video_codec_dec_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = FALSE;
    params = &context->video_dec_params;
    params->feed_mode = mTestFeedMode;
    params->pix_fmt = mTestPixFmt;
    params->bitstream_buf_size = mTestWidth * mTestHeight * 3 / 2;
    params->bitstream_buf_count = 6;
    params->frame_buf_count = 6;
    params->h265_dec_config.bandwidth_Opt = TRUE;
    params->h265_dec_config.reorder_enable = TRUE;
    params->h265_dec_config.skip_mode = 0;
    params->h265_dec_config.cra_as_bla = FALSE;
    params->h265_dec_config.dec_temporal_id_mode = 0;
    params->h265_dec_config.target_dec_temporal_id_plus1 = 0;

    EXPECT_EQ(hb_mm_mc_initialize(context), (int32_t)0);

    printf("Test set&get_pred_unit_config when decoding ......\n");
    mc_video_pred_unit_params_t pred_set;
    mc_video_pred_unit_params_t pred_get;
    memset(&pred_set, 0x00, sizeof(mc_video_pred_unit_params_t));
    memset(&pred_get, 0x00, sizeof(mc_video_pred_unit_params_t));
    pred_set.h265_pred_unit.intra_nxn_enable = 0;
    pred_set.h265_pred_unit.constrained_intra_pred_flag = 1;
    pred_set.h265_pred_unit.strong_intra_smoothing_enabled_flag = 1;
    pred_set.h265_pred_unit.max_num_merge = 1;
    EXPECT_EQ(hb_mm_mc_set_pred_unit_config(context, &pred_set), (int32_t)HB_MEDIA_ERR_OPERATION_NOT_ALLOWED);
    EXPECT_EQ(hb_mm_mc_get_pred_unit_config(context, &pred_get), (int32_t)HB_MEDIA_ERR_OPERATION_NOT_ALLOWED);

    printf("Test set&get_longterm when decoding ......\n");
    mc_video_longterm_ref_mode_t ref_set;
    memset(&ref_set, 0x00, sizeof(mc_video_longterm_ref_mode_t));
    mc_video_longterm_ref_mode_t ref_get;
    memset(&ref_get, 0x00, sizeof(mc_video_longterm_ref_mode_t));
    ref_set.use_longterm = 1;
    ref_set.longterm_pic_using_period = 20;
    ref_set.longterm_pic_period = 30;
    EXPECT_EQ(hb_mm_mc_set_longterm_ref_mode(context, &ref_set), (int32_t)HB_MEDIA_ERR_OPERATION_NOT_ALLOWED);
    EXPECT_EQ(hb_mm_mc_get_longterm_ref_mode(context, &ref_get), (int32_t)HB_MEDIA_ERR_OPERATION_NOT_ALLOWED);

    printf("Test set&get_intra_refresh_config when decoding ......\n");
    mc_video_intra_refresh_params_t intra_set;
    memset(&intra_set, 0x00, sizeof(mc_video_intra_refresh_params_t));
    mc_video_intra_refresh_params_t intra_get;
    memset(&intra_get, 0x00, sizeof(mc_video_intra_refresh_params_t));
    intra_set.intra_refresh_mode = 1;
    intra_set.intra_refresh_arg = 20;
    EXPECT_EQ(hb_mm_mc_set_intra_refresh_config(context, &intra_set), (int32_t)HB_MEDIA_ERR_OPERATION_NOT_ALLOWED);
    EXPECT_EQ(hb_mm_mc_get_intra_refresh_config(context, &intra_get), (int32_t)HB_MEDIA_ERR_OPERATION_NOT_ALLOWED);

    printf("Test set&get_rate_control_config when decoding ......\n");
    mc_rate_control_params_t rate_set;
    mc_rate_control_params_t rate_get;
    memset(&rate_set, 0x00, sizeof(mc_rate_control_params_t));
    memset(&rate_get, 0x00, sizeof(mc_rate_control_params_t));
    rate_set.mode = MC_AV_RC_MODE_H265CBR;
    rate_set.h265_cbr_params.bit_rate = 5000;
    rate_set.h265_cbr_params.frame_rate = 30;
    rate_set.h265_cbr_params.intra_period = 20;
    rate_set.h265_cbr_params.intra_qp = 20;
    rate_set.h265_cbr_params.initial_rc_qp = 50;
    rate_set.h265_cbr_params.vbv_buffer_size = 2000;
    rate_set.h265_cbr_params.ctu_level_rc_enalbe = 1;
    EXPECT_EQ(hb_mm_mc_set_rate_control_config(context, &rate_set), (int32_t)HB_MEDIA_ERR_OPERATION_NOT_ALLOWED);
    EXPECT_EQ(hb_mm_mc_get_rate_control_config(context, &rate_get), (int32_t)HB_MEDIA_ERR_OPERATION_NOT_ALLOWED);

    printf("Test set&get_deblk_filter_config when decoding ......\n");
    mc_video_deblk_filter_params_t deblk_set;
    mc_video_deblk_filter_params_t deblk_get;
    memset(&deblk_set, 0x00, sizeof(mc_video_deblk_filter_params_t));
    memset(&deblk_get, 0x00, sizeof(mc_video_deblk_filter_params_t));
    //Set Values
    deblk_set.h265_deblk.slice_deblocking_filter_disabled_flag = 1;
    deblk_set.h265_deblk.slice_beta_offset_div2 = 6;
    deblk_set.h265_deblk.slice_tc_offset_div2 = -6;
    deblk_set.h265_deblk.slice_loop_filter_across_slices_enabled_flag = 1;
    EXPECT_EQ(hb_mm_mc_set_deblk_filter_config(context, &deblk_set), (int32_t)HB_MEDIA_ERR_OPERATION_NOT_ALLOWED);
    EXPECT_EQ(hb_mm_mc_get_deblk_filter_config(context, &deblk_get), (int32_t)HB_MEDIA_ERR_OPERATION_NOT_ALLOWED);

    printf("Test set&get_sao_config when decoding ......\n");
    mc_h265_sao_params_t sao_set;
    mc_h265_sao_params_t sao_get;
    memset(&sao_set, 0x00, sizeof(mc_h265_sao_params_t));
    memset(&sao_get, 0x00, sizeof(mc_h265_sao_params_t));
    sao_set.sample_adaptive_offset_enabled_flag = 1;
    EXPECT_EQ(hb_mm_mc_set_sao_config(context, &sao_set), (int32_t)HB_MEDIA_ERR_OPERATION_NOT_ALLOWED);
    EXPECT_EQ(hb_mm_mc_get_sao_config(context, &sao_get), (int32_t)HB_MEDIA_ERR_OPERATION_NOT_ALLOWED);

    printf("Test set&get_vui_timing_config when decoding ......\n");
    mc_video_vui_timing_params_t vui_set;
    mc_video_vui_timing_params_t vui_get;
    memset(&vui_set, 0x00, sizeof(mc_video_vui_timing_params_t));
    memset(&vui_get, 0x00, sizeof(mc_video_vui_timing_params_t));
    vui_set.h265_timing.vui_num_units_in_tick = 1000;
    vui_set.h265_timing.vui_time_scale = 30000;
    vui_set.h265_timing.vui_num_ticks_poc_diff_one_minus1 = 2000;
    EXPECT_EQ(hb_mm_mc_set_vui_timing_config(context, &vui_set), (int32_t)HB_MEDIA_ERR_OPERATION_NOT_ALLOWED);
    EXPECT_EQ(hb_mm_mc_get_vui_timing_config(context, &vui_set), (int32_t)HB_MEDIA_ERR_OPERATION_NOT_ALLOWED);

    mc_video_slice_params_t slice_set;
    mc_video_slice_params_t slice_get;
    memset(&slice_set, 0x00, sizeof(mc_video_slice_params_t));
    memset(&slice_get, 0x00, sizeof(mc_video_slice_params_t));
    slice_set.h265_slice.h265_independent_slice_mode = 1;
    slice_set.h265_slice.h265_independent_slice_arg = 30;
    slice_set.h265_slice.h265_dependent_slice_mode = 0;
    slice_set.h265_slice.h265_dependent_slice_arg = 60;
    EXPECT_EQ(hb_mm_mc_set_slice_config(context, &slice_set), (int32_t)HB_MEDIA_ERR_OPERATION_NOT_ALLOWED);
    EXPECT_EQ(hb_mm_mc_get_slice_config(context, &slice_set), (int32_t)HB_MEDIA_ERR_OPERATION_NOT_ALLOWED);

    mc_video_roi_params_t roi_set;
    mc_video_roi_params_t roi_get;
    memset(&roi_set, 0x00, sizeof(mc_video_roi_params_t));
    memset(&roi_get, 0x00, sizeof(mc_video_roi_params_t));
    unsigned char roiMap1[MC_VIDEO_MAX_MB_NUM] = { 30, };
    hb_u32 array_count = ((mTestWidth + 0x3f) & ~0x3f) / 64 *
        (((mTestHeight) + 0x3f) & ~0x3f) / 64;
    roi_set.roi_enable = 1;
    roi_set.roi_map_array = roiMap1;
    roi_set.roi_map_array_count = array_count;
    EXPECT_EQ(hb_mm_mc_set_roi_config(context, &roi_set), (int32_t)HB_MEDIA_ERR_OPERATION_NOT_ALLOWED);
    EXPECT_EQ(hb_mm_mc_get_roi_config(context, &roi_get), (int32_t)HB_MEDIA_ERR_OPERATION_NOT_ALLOWED);

    printf("Test set&get_transform_config when decoding ......\n");
    mc_video_transform_params_t trans_set;
    mc_video_transform_params_t trans_get;
    memset(&trans_set, 0x00, sizeof(mc_video_transform_params_t));
    memset(&trans_get, 0x00, sizeof(mc_video_transform_params_t));
    trans_set.h265_transform.chroma_cb_qp_offset = 0;
    trans_set.h265_transform.chroma_cr_qp_offset = 0;
    trans_set.h265_transform.user_scaling_list_enable = 1;
    EXPECT_EQ(hb_mm_mc_set_transform_config(context, &trans_set), (int32_t)HB_MEDIA_ERR_OPERATION_NOT_ALLOWED);
    EXPECT_EQ(hb_mm_mc_get_transform_config(context, &trans_get), (int32_t)HB_MEDIA_ERR_OPERATION_NOT_ALLOWED);

    EXPECT_EQ(hb_mm_mc_release(context), (int32_t)0);

    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h265_configure_min_param) {
    mTestCodec = TEST_CODEC_ID_H265;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;

    ASSERT_EQ(hb_mm_mc_get_default_context(context->codec_id,
        context->encoder, context), 0);
    context->video_enc_params.width = mTestWidth;
    context->video_enc_params.height = mTestHeight;

    ASSERT_EQ(hb_mm_mc_initialize(context), 0);
    ASSERT_EQ(hb_mm_mc_get_default_context(context->codec_id,
        context->encoder, context), 0);
    context->video_enc_params.width = mTestWidth;
    context->video_enc_params.height = mTestHeight;

    ASSERT_EQ(hb_mm_mc_configure(context), (int32_t)0);
    ASSERT_EQ(hb_mm_mc_start(context, NULL), (int32_t)0);

    EXPECT_EQ(hb_mm_mc_release(context), (int32_t)0);

    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_decoding_case_h265_configure_min_param) {
    mTestCodec = TEST_CODEC_ID_H265;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = FALSE;

    ASSERT_EQ(hb_mm_mc_get_default_context(context->codec_id,
        context->encoder, context), 0);
    context->video_dec_params.feed_mode = mTestFeedMode;


    ASSERT_EQ(hb_mm_mc_initialize(context), 0);
    ASSERT_EQ(hb_mm_mc_get_default_context(context->codec_id,
        context->encoder, context), 0);
    context->video_dec_params.feed_mode = mTestFeedMode;

    ASSERT_EQ(hb_mm_mc_configure(context), (int32_t)0);
    ASSERT_EQ(hb_mm_mc_start(context, NULL), (int32_t)0);

    EXPECT_EQ(hb_mm_mc_release(context), (int32_t)0);

    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h264_320x240_420p) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestWidth = 320;
    mTestHeight = 240;
    mTestPixFmt = MC_PIXEL_FORMAT_YUV420P;
    mTestCodec = TEST_CODEC_ID_H264;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h264_352x288_420p) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestWidth = 352;
    mTestHeight = 288;
    mTestPixFmt = MC_PIXEL_FORMAT_YUV420P;
    mTestCodec = TEST_CODEC_ID_H264;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rc_params.mode = MC_AV_RC_MODE_H264VBR;
    ret = hb_mm_mc_get_rate_control_config(context, &params->rc_params);
    ASSERT_EQ(ret, (int32_t)0);
    params->rc_params.h264_vbr_params.intra_period = 14;
    params->rc_params.h264_vbr_params.intra_qp = 30;
    params->rc_params.h264_vbr_params.frame_rate = 30;
    params->rc_params.h264_vbr_params.qp_map_enable = 0;
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 4;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h264_640x368_420p) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestWidth = 640;
    mTestHeight = 368;
    mTestPixFmt = MC_PIXEL_FORMAT_YUV420P;
    mTestCodec = TEST_CODEC_ID_H264;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->pix_fmt = MC_PIXEL_FORMAT_YUV420P;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h264_640x480_420p) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestWidth = 640;
    mTestHeight = 480;
    mTestPixFmt = MC_PIXEL_FORMAT_YUV420P;
    mTestCodec = TEST_CODEC_ID_H264;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h264_1280x720_420p) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestWidth = 1280;
    mTestHeight = 720;
    mTestPixFmt = MC_PIXEL_FORMAT_YUV420P;
    mTestCodec = TEST_CODEC_ID_H264;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h264_1920x1080_420p) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestWidth = 1920;
    mTestHeight = 1080;
    mTestPixFmt = MC_PIXEL_FORMAT_YUV420P;
    mTestCodec = TEST_CODEC_ID_H264;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rc_params.mode = MC_AV_RC_MODE_H264VBR;
    ret = hb_mm_mc_get_rate_control_config(context, &params->rc_params);
    ASSERT_EQ(ret, (int32_t)0);
    params->rc_params.h264_vbr_params.intra_period = 14;
    params->rc_params.h264_vbr_params.intra_qp = 30;
    params->rc_params.h264_vbr_params.frame_rate = 30;
    params->rc_params.h264_vbr_params.qp_map_enable = 0;
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 4;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    mc_video_transform_params_t *transform = &ctx.transform;
    ret = hb_mm_mc_get_transform_config(context, transform);
    transform->h264_transform.transform_8x8_enable = 1;
    transform->h264_transform.chroma_cb_qp_offset = 4;
    transform->h264_transform.chroma_cr_qp_offset = 3;
    transform->h264_transform.user_scaling_list_enable = 1;
    uint8_t intra4x4_luma[16] = {6,13,20,28,13,20,28,32,
        20,28,32,37,28,32,37,42};
    uint8_t intra4x4_chromau[16] =  {6,13,20,28,13,20,28,32,
        20,28,32,37,28,32,37,42};
    uint8_t intra4x4_chromav[16] =  {6,13,20,28,13,20,28,32,
        20,28,32,37,28,32,37,42};
    uint8_t inter4x4_luma[16] =  {10,14,20,24,14,20,24,27,
        20,24,27,30,24,27,30,34};
    uint8_t inter4x4_chromau[16] =  {10,14,20,24,14,20,24,27,
        20,24,27,30,24,27,30,34};
    uint8_t inter4x4_chromav[16] =  {10,14,20,24,14,20,24,27,
        20,24,27,30,24,27,30,34};
    uint8_t intra8x8_luma[64] = {6,10,13,16,18,23,25,27,
        10,11,16,18,23,25,27,29,
        13,16,18,23,25,27,29,31,
        16,18,23,25,27,29,31,33,
        18,23,25,27,29,31,33,36,
        23,25,27,29,31,33,36,38,
        25,27,29,31,33,36,38,40,
        27,29,31,33,36,38,40,42
    };
    uint8_t inter8x8_luma[64] = {9,13,15,17,19,21,22,24,
        13,13,17,19,21,22,24,25,
        15,17,19,21,22,24,25,27,
        17,19,21,22,24,25,27,28,
        19,21,22,24,25,27,28,30,
        21,22,24,25,27,28,30,32,
        22,24,25,27,28,30,32,33,
        24,25,27,28,30,32,33,35
    };
    int i = 0;
    for (i=0; i<16;i++){
        transform->h264_transform.scaling_list_4x4[0][i] =
            intra4x4_luma[i];
    }
    for (i=0; i<16;i++){
        transform->h264_transform.scaling_list_4x4[1][i] =
            intra4x4_chromau[i];
        transform->h264_transform.scaling_list_4x4[2][i] =
            intra4x4_chromav[i];
        transform->h264_transform.scaling_list_4x4[3][i] =
            inter4x4_luma[i];
        transform->h264_transform.scaling_list_4x4[4][i] =
            inter4x4_chromau[i];
        transform->h264_transform.scaling_list_4x4[5][i] =
            inter4x4_chromav[i];
    }
    for (i=0; i<64;i++){
        transform->h264_transform.scaling_list_8x8[0][i] =
            intra8x8_luma[i];
        transform->h264_transform.scaling_list_8x8[1][i] =
            inter8x8_luma[i];
    }
    ctx.message = ENC_CONFIG_TRANSFORM;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h264_1920x1088_420p) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestWidth = 1920;
    mTestHeight = 1088;
    mTestPixFmt = MC_PIXEL_FORMAT_YUV420P;
    mTestCodec = TEST_CODEC_ID_H264;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rc_params.mode = MC_AV_RC_MODE_H264VBR;
    ret = hb_mm_mc_get_rate_control_config(context, &params->rc_params);
    ASSERT_EQ(ret, (int32_t)0);
    params->rc_params.h264_vbr_params.intra_period = 14;
    params->rc_params.h264_vbr_params.intra_qp = 30;
    params->rc_params.h264_vbr_params.frame_rate = 30;
    params->rc_params.h264_vbr_params.qp_map_enable = 0;
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 4;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    mc_video_transform_params_t *transform = &ctx.transform;
    ret = hb_mm_mc_get_transform_config(context, transform);
    transform->h264_transform.transform_8x8_enable = 1;
    transform->h264_transform.chroma_cb_qp_offset = 4;
    transform->h264_transform.chroma_cr_qp_offset = 3;
    transform->h264_transform.user_scaling_list_enable = 1;
    uint8_t intra4x4_luma[16] = {6,13,20,28,13,20,28,32,
        20,28,32,37,28,32,37,42};
    uint8_t intra4x4_chromau[16] =  {6,13,20,28,13,20,28,32,
        20,28,32,37,28,32,37,42};
    uint8_t intra4x4_chromav[16] =  {6,13,20,28,13,20,28,32,
        20,28,32,37,28,32,37,42};
    uint8_t inter4x4_luma[16] =  {10,14,20,24,14,20,24,27,
        20,24,27,30,24,27,30,34};
    uint8_t inter4x4_chromau[16] =  {10,14,20,24,14,20,24,27,
        20,24,27,30,24,27,30,34};
    uint8_t inter4x4_chromav[16] =  {10,14,20,24,14,20,24,27,
        20,24,27,30,24,27,30,34};
    uint8_t intra8x8_luma[64] = {6,10,13,16,18,23,25,27,
        10,11,16,18,23,25,27,29,
        13,16,18,23,25,27,29,31,
        16,18,23,25,27,29,31,33,
        18,23,25,27,29,31,33,36,
        23,25,27,29,31,33,36,38,
        25,27,29,31,33,36,38,40,
        27,29,31,33,36,38,40,42
    };
    uint8_t inter8x8_luma[64] = {9,13,15,17,19,21,22,24,
        13,13,17,19,21,22,24,25,
        15,17,19,21,22,24,25,27,
        17,19,21,22,24,25,27,28,
        19,21,22,24,25,27,28,30,
        21,22,24,25,27,28,30,32,
        22,24,25,27,28,30,32,33,
        24,25,27,28,30,32,33,35
    };
    int i = 0;
    for (i=0; i<16;i++){
        transform->h264_transform.scaling_list_4x4[0][i] =
            intra4x4_luma[i];
    }
    for (i=0; i<16;i++){
        transform->h264_transform.scaling_list_4x4[1][i] =
            intra4x4_chromau[i];
        transform->h264_transform.scaling_list_4x4[2][i] =
            intra4x4_chromav[i];
        transform->h264_transform.scaling_list_4x4[3][i] =
            inter4x4_luma[i];
        transform->h264_transform.scaling_list_4x4[4][i] =
            inter4x4_chromau[i];
        transform->h264_transform.scaling_list_4x4[5][i] =
            inter4x4_chromav[i];
    }
    for (i=0; i<64;i++){
        transform->h264_transform.scaling_list_8x8[0][i] =
            intra8x8_luma[i];
        transform->h264_transform.scaling_list_8x8[1][i] =
            inter8x8_luma[i];
    }
    ctx.message = ENC_CONFIG_TRANSFORM;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h264_3840x2160_420p) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestWidth = 3840;
    mTestHeight = 2160;
    mTestPixFmt = MC_PIXEL_FORMAT_YUV420P;
    mTestCodec = TEST_CODEC_ID_H264;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h264_3840x2160_420p_vlc_buf) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestWidth = 3840;
    mTestHeight = 2160;
    mTestPixFmt = MC_PIXEL_FORMAT_YUV420P;
    mTestCodec = TEST_CODEC_ID_H264;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.vlc_buf_size = 10000000;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h265_320x240_420p) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestWidth = 320;
    mTestHeight = 240;
    mTestPixFmt = MC_PIXEL_FORMAT_YUV420P;
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h265_352x288_420p) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestWidth = 352;
    mTestHeight = 288;
    mTestPixFmt = MC_PIXEL_FORMAT_YUV420P;
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rc_params.mode = MC_AV_RC_MODE_H265VBR;
    ret = hb_mm_mc_get_rate_control_config(context, &params->rc_params);
    ASSERT_EQ(ret, (int32_t)0);
    params->rc_params.h265_vbr_params.intra_period = 14;
    params->rc_params.h265_vbr_params.intra_qp = 30;
    params->rc_params.h265_vbr_params.frame_rate = 30;
    params->rc_params.h265_vbr_params.qp_map_enable = 0;
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h265_640x368_420p) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestWidth = 640;
    mTestHeight = 368;
    mTestPixFmt = MC_PIXEL_FORMAT_YUV420P;
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h265_640x480_420p) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestWidth = 640;
    mTestHeight = 480;
    mTestPixFmt = MC_PIXEL_FORMAT_YUV420P;
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h265_1280x720_420p) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestWidth = 1280;
    mTestHeight = 720;
    mTestPixFmt = MC_PIXEL_FORMAT_YUV420P;
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h265_1920x1080_420p) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestWidth = 1920;
    mTestHeight = 1080;
    mTestPixFmt = MC_PIXEL_FORMAT_YUV420P;
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h265_3840x2160_420p) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestWidth = 3840;
    mTestHeight = 2160;
    mTestPixFmt = MC_PIXEL_FORMAT_YUV420P;
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h265_4096x2160_420p) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestWidth = 4096;
    mTestHeight = 2160;
    mTestPixFmt = MC_PIXEL_FORMAT_YUV420P;
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h264_NV12) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestPixFmt = MC_PIXEL_FORMAT_NV12;
    mTestCodec = TEST_CODEC_ID_H264;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h264_NV21) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestPixFmt = MC_PIXEL_FORMAT_NV21;
    mTestCodec = TEST_CODEC_ID_H264;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h265_NV12) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestPixFmt = MC_PIXEL_FORMAT_NV12;
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h265_NV21) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestPixFmt = MC_PIXEL_FORMAT_NV21;
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_frame_buf_max) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "frame_buf_max";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 31;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_frame_buf_min) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "frame_buf_min";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 1;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_bs_buf_max) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "bs_buf_max";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 200;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_bs_buf_min) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "bs_buf_min";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 1;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_bs_buf_full) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "bs_buf_full";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->bitstream_buf_size = 65536;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    ctx.bitfullTest = 1;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h264_external_frame) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H264;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "external_frame";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = TRUE;
    params->bitstream_buf_count = 5;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h265_external_frame) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "external_frame";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = TRUE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    ret = hb_mm_mc_get_rate_control_config(context, &params->rc_params);
    ASSERT_EQ(ret, (int32_t)0);
    params->rc_params.h265_cbr_params.intra_period = 20;
    params->rc_params.h265_cbr_params.intra_qp = 20;
    params->rc_params.h265_cbr_params.bit_rate = 1000;
    params->rc_params.h265_cbr_params.frame_rate = 30;
    params->rc_params.h265_cbr_params.initial_rc_qp = 20;
    params->rc_params.h265_cbr_params.vbv_buffer_size = 20;
    params->rc_params.h265_cbr_params.ctu_level_rc_enalbe = 0;
    params->rc_params.h265_cbr_params.min_qp_I = 8;
    params->rc_params.h265_cbr_params.max_qp_I = 50;
    params->rc_params.h265_cbr_params.min_qp_P = 8;
    params->rc_params.h265_cbr_params.max_qp_P = 50;
    params->rc_params.h265_cbr_params.min_qp_B = 8;
    params->rc_params.h265_cbr_params.max_qp_B = 50;
    params->rc_params.h265_cbr_params.hvs_qp_enable = 1;
    params->rc_params.h265_cbr_params.hvs_qp_scale = 2;
    params->rc_params.h265_cbr_params.max_delta_qp = 10;
    params->rc_params.h265_cbr_params.qp_map_enable = 0;
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_rot_90) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "rot90";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_90;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_rot_180) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "rot180";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_180;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_rot_270) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "rot270";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_270;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_mir_hor) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "mir_hor";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_HORIZONTAL;
    params->frame_cropping_flag = FALSE;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_mir_ver) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "mir_ver";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_VERTICAL;
    params->frame_cropping_flag = FALSE;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_mir_hor_ver) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "mir_hor_ver";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_HOR_VER;
    params->frame_cropping_flag = FALSE;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_rot_270_mir_ver) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "rot270_mir_ver";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_270;
    params->mir_direction = MC_VERTICAL;
    params->frame_cropping_flag = FALSE;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_crop) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "crop";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = TRUE;
    params->crop_rect.x_pos = 30;
    params->crop_rect.y_pos = 50;
    params->crop_rect.width = 300;
    params->crop_rect.height = 200;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h264_cbr) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H264;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "cbr";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    ret = hb_mm_mc_get_rate_control_config(context, &params->rc_params);
    ASSERT_EQ(ret, (int32_t)0);
    params->rc_params.h264_cbr_params.intra_period = 20;
    params->rc_params.h264_cbr_params.intra_qp = 20;
    params->rc_params.h264_cbr_params.bit_rate = 1000;
    params->rc_params.h264_cbr_params.frame_rate = 30;
    params->rc_params.h264_cbr_params.initial_rc_qp = 20;
    params->rc_params.h264_cbr_params.vbv_buffer_size = 20;
    params->rc_params.h264_cbr_params.mb_level_rc_enalbe = 0;
    params->rc_params.h264_cbr_params.min_qp_I = 8;
    params->rc_params.h264_cbr_params.max_qp_I = 50;
    params->rc_params.h264_cbr_params.min_qp_P = 8;
    params->rc_params.h264_cbr_params.max_qp_P = 50;
    params->rc_params.h264_cbr_params.min_qp_B = 8;
    params->rc_params.h264_cbr_params.max_qp_B = 50;
    params->rc_params.h264_cbr_params.hvs_qp_enable = 1;
    params->rc_params.h264_cbr_params.hvs_qp_scale = 2;
    params->rc_params.h264_cbr_params.max_delta_qp = 10;
    params->rc_params.h264_cbr_params.qp_map_enable = 0;
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h264_cbr_2) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H264;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "cbr2";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    ret = hb_mm_mc_get_rate_control_config(context, &params->rc_params);
    ASSERT_EQ(ret, (int32_t)0);
    params->rc_params.h264_cbr_params.intra_period = 20;
    params->rc_params.h264_cbr_params.intra_qp = 15;
    params->rc_params.h264_cbr_params.bit_rate = 2000;
    params->rc_params.h264_cbr_params.frame_rate = 25;
    params->rc_params.h264_cbr_params.initial_rc_qp = 15;
    params->rc_params.h264_cbr_params.vbv_buffer_size = 10;
    params->rc_params.h264_cbr_params.mb_level_rc_enalbe = 1;
    params->rc_params.h264_cbr_params.min_qp_I = 15;
    params->rc_params.h264_cbr_params.max_qp_I = 50;
    params->rc_params.h264_cbr_params.min_qp_P = 15;
    params->rc_params.h264_cbr_params.max_qp_P = 45;
    params->rc_params.h264_cbr_params.min_qp_B = 15;
    params->rc_params.h264_cbr_params.max_qp_B = 48;
    params->rc_params.h264_cbr_params.hvs_qp_enable = 0;
    params->rc_params.h264_cbr_params.hvs_qp_scale = 2;
    params->rc_params.h264_cbr_params.max_delta_qp = 5;
    params->rc_params.h264_cbr_params.qp_map_enable = 0;
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h264_avbr) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H264;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "avbr";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    params->rc_params.mode = MC_AV_RC_MODE_H264AVBR;
    ret = hb_mm_mc_get_rate_control_config(context, &params->rc_params);
    ASSERT_EQ(ret, (int32_t)0);
    params->rc_params.h264_avbr_params.intra_period = 20;
    params->rc_params.h264_avbr_params.intra_qp = 8;
    params->rc_params.h264_avbr_params.bit_rate = 500;
    params->rc_params.h264_avbr_params.frame_rate = 15;
    params->rc_params.h264_avbr_params.initial_rc_qp = 20;
    params->rc_params.h264_avbr_params.vbv_buffer_size = 3000;
    params->rc_params.h264_avbr_params.mb_level_rc_enalbe = 1;
    params->rc_params.h264_avbr_params.min_qp_I = 8;
    params->rc_params.h264_avbr_params.max_qp_I = 51;
    params->rc_params.h264_avbr_params.min_qp_P = 8;
    params->rc_params.h264_avbr_params.max_qp_P = 51;
    params->rc_params.h264_avbr_params.min_qp_B = 8;
    params->rc_params.h264_avbr_params.max_qp_B = 51;
    params->rc_params.h264_avbr_params.hvs_qp_enable = 1;
    params->rc_params.h264_avbr_params.hvs_qp_scale = 2;
    params->rc_params.h264_avbr_params.max_delta_qp = 10;
    params->rc_params.h264_avbr_params.qp_map_enable = 0;
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h264_avbr_2) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H264;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "avbr2";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    params->rc_params.mode = MC_AV_RC_MODE_H264AVBR;
    ret = hb_mm_mc_get_rate_control_config(context, &params->rc_params);
    ASSERT_EQ(ret, (int32_t)0);
    params->rc_params.h264_avbr_params.intra_period = 15;
    params->rc_params.h264_avbr_params.intra_qp = 25;
    params->rc_params.h264_avbr_params.bit_rate = 2000;
    params->rc_params.h264_avbr_params.frame_rate = 25;
    params->rc_params.h264_avbr_params.initial_rc_qp = 15;
    params->rc_params.h264_avbr_params.vbv_buffer_size = 3000;
    params->rc_params.h264_avbr_params.mb_level_rc_enalbe = 0;
    params->rc_params.h264_avbr_params.min_qp_I = 15;
    params->rc_params.h264_avbr_params.max_qp_I = 50;
    params->rc_params.h264_avbr_params.min_qp_P = 15;
    params->rc_params.h264_avbr_params.max_qp_P = 45;
    params->rc_params.h264_avbr_params.min_qp_B = 15;
    params->rc_params.h264_avbr_params.max_qp_B = 48;
    params->rc_params.h264_avbr_params.hvs_qp_enable = 0;
    params->rc_params.h264_avbr_params.hvs_qp_scale = 2;
    params->rc_params.h264_avbr_params.max_delta_qp = 5;
    params->rc_params.h264_avbr_params.qp_map_enable = 0;
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h264_vbr) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H264;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "vbr";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    params->rc_params.mode = MC_AV_RC_MODE_H264VBR;
    ret = hb_mm_mc_get_rate_control_config(context, &params->rc_params);
    ASSERT_EQ(ret, (int32_t)0);
    params->rc_params.h264_vbr_params.intra_period = 30;
    params->rc_params.h264_vbr_params.intra_qp = 30;
    params->rc_params.h264_vbr_params.frame_rate = 25;
    params->rc_params.h264_vbr_params.qp_map_enable = 0;
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h264_vbr_2) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H264;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "vbr2";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    params->rc_params.mode = MC_AV_RC_MODE_H264VBR;
    ret = hb_mm_mc_get_rate_control_config(context, &params->rc_params);
    ASSERT_EQ(ret, (int32_t)0);
    params->rc_params.h264_vbr_params.intra_period = 20;
    params->rc_params.h264_vbr_params.intra_qp = 20;
    params->rc_params.h264_vbr_params.frame_rate = 30;
    params->rc_params.h264_vbr_params.qp_map_enable = 0;
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h264_fixqp) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H264;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "fixqp";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    params->rc_params.mode = MC_AV_RC_MODE_H264FIXQP;
    ret = hb_mm_mc_get_rate_control_config(context, &params->rc_params);
    ASSERT_EQ(ret, (int32_t)0);
    params->rc_params.h264_fixqp_params.intra_period = 30;
    params->rc_params.h264_fixqp_params.frame_rate = 25;
    params->rc_params.h264_fixqp_params.force_qp_I = 15;
    params->rc_params.h264_fixqp_params.force_qp_P = 20;
    params->rc_params.h264_fixqp_params.force_qp_B = 30;
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h264_fixqp_2) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H264;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "fixqp2";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    params->rc_params.mode = MC_AV_RC_MODE_H264FIXQP;
    ret = hb_mm_mc_get_rate_control_config(context, &params->rc_params);
    ASSERT_EQ(ret, (int32_t)0);
    params->rc_params.h264_fixqp_params.intra_period = 20;
    params->rc_params.h264_fixqp_params.frame_rate = 15;
    params->rc_params.h264_fixqp_params.force_qp_I = 20;
    params->rc_params.h264_fixqp_params.force_qp_P = 30;
    params->rc_params.h264_fixqp_params.force_qp_B = 40;
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h264_qpmap) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H264;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "qpmap";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    params->rc_params.mode = MC_AV_RC_MODE_H264QPMAP;
    ret = hb_mm_mc_get_rate_control_config(context, &params->rc_params);
    ASSERT_EQ(ret, (int32_t)0);
    int qp_count = (((params->width+0x0f)&~0x0f) >> 4)
        *(((params->height+0x0f)&~0x0f) >> 4);
    params->rc_params.h264_qpmap_params.intra_period = 20;
    params->rc_params.h264_qpmap_params.frame_rate = 15;
    params->rc_params.h264_qpmap_params.qp_map_array =
        (unsigned char*)malloc(qp_count*sizeof(unsigned char));
    params->rc_params.h264_qpmap_params.qp_map_array_count = qp_count;
    for (int i=0; i<qp_count; i++) {
        params->rc_params.h264_qpmap_params.qp_map_array[i] = 30;
    }
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (params->rc_params.h264_qpmap_params.qp_map_array)
        free(params->rc_params.h264_qpmap_params.qp_map_array);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h264_qpmap_2) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H264;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "qpmap2";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    params->rc_params.mode = MC_AV_RC_MODE_H264QPMAP;
    ret = hb_mm_mc_get_rate_control_config(context, &params->rc_params);
    ASSERT_EQ(ret, (int32_t)0);
    int qp_count = (((params->width+0x0f)&~0x0f) >> 4)
        *(((params->height+0x0f)&~0x0f) >> 4);
    params->rc_params.h264_qpmap_params.intra_period = 15;
    params->rc_params.h264_qpmap_params.frame_rate = 25;
    params->rc_params.h264_qpmap_params.qp_map_array =
        (unsigned char*)malloc(qp_count*sizeof(unsigned char));
    params->rc_params.h264_qpmap_params.qp_map_array_count = qp_count;
    for (int i=0; i<qp_count; i++) {
        params->rc_params.h264_qpmap_params.qp_map_array[i] = 20;
    }
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (params->rc_params.h264_qpmap_params.qp_map_array)
        free(params->rc_params.h264_qpmap_params.qp_map_array);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h265_cbr) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "cbr";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    ret = hb_mm_mc_get_rate_control_config(context, &params->rc_params);
    ASSERT_EQ(ret, (int32_t)0);
    params->rc_params.h265_cbr_params.intra_period = 20;
    params->rc_params.h265_cbr_params.intra_qp = 20;
    params->rc_params.h265_cbr_params.bit_rate = 1000;
    params->rc_params.h265_cbr_params.frame_rate = 30;
    params->rc_params.h265_cbr_params.initial_rc_qp = 20;
    params->rc_params.h265_cbr_params.vbv_buffer_size = 20;
    params->rc_params.h265_cbr_params.ctu_level_rc_enalbe = 0;
    params->rc_params.h265_cbr_params.min_qp_I = 8;
    params->rc_params.h265_cbr_params.max_qp_I = 50;
    params->rc_params.h265_cbr_params.min_qp_P = 8;
    params->rc_params.h265_cbr_params.max_qp_P = 50;
    params->rc_params.h265_cbr_params.min_qp_B = 8;
    params->rc_params.h265_cbr_params.max_qp_B = 50;
    params->rc_params.h265_cbr_params.hvs_qp_enable = 1;
    params->rc_params.h265_cbr_params.hvs_qp_scale = 2;
    params->rc_params.h265_cbr_params.max_delta_qp = 10;
    params->rc_params.h265_cbr_params.qp_map_enable = 0;
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h265_cbr_2) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "cbr2";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    ret = hb_mm_mc_get_rate_control_config(context, &params->rc_params);
    ASSERT_EQ(ret, (int32_t)0);
    params->rc_params.h265_cbr_params.intra_period = 20;
    params->rc_params.h265_cbr_params.intra_qp = 15;
    params->rc_params.h265_cbr_params.bit_rate = 2000;
    params->rc_params.h265_cbr_params.frame_rate = 25;
    params->rc_params.h265_cbr_params.initial_rc_qp = 15;
    params->rc_params.h265_cbr_params.vbv_buffer_size = 2000;
    params->rc_params.h265_cbr_params.ctu_level_rc_enalbe = 1;
    params->rc_params.h265_cbr_params.min_qp_I = 15;
    params->rc_params.h265_cbr_params.max_qp_I = 50;
    params->rc_params.h265_cbr_params.min_qp_P = 15;
    params->rc_params.h265_cbr_params.max_qp_P = 45;
    params->rc_params.h265_cbr_params.min_qp_B = 15;
    params->rc_params.h265_cbr_params.max_qp_B = 48;
    params->rc_params.h265_cbr_params.hvs_qp_enable = 0;
    params->rc_params.h265_cbr_params.hvs_qp_scale = 2;
    params->rc_params.h265_cbr_params.max_delta_qp = 5;
    params->rc_params.h265_cbr_params.qp_map_enable = 0;
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h265_cbr_dynamic_off) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "cbr_dynamic_off";
    char inputSuffix[MAX_FILE_PATH] = "_long.yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    ret = hb_mm_mc_get_rate_control_config(context, &params->rc_params);
    ASSERT_EQ(ret, (int32_t)0);
    params->rc_params.h265_cbr_params.intra_period = 20;
    params->rc_params.h265_cbr_params.intra_qp = 20;
    params->rc_params.h265_cbr_params.bit_rate = 1000;
    params->rc_params.h265_cbr_params.frame_rate = 30;
    params->rc_params.h265_cbr_params.initial_rc_qp = 30;
    params->rc_params.h265_cbr_params.vbv_buffer_size = 2000;
    params->rc_params.h265_cbr_params.ctu_level_rc_enalbe = 0;
    params->rc_params.h265_cbr_params.min_qp_I = 8;
    params->rc_params.h265_cbr_params.max_qp_I = 50;
    params->rc_params.h265_cbr_params.min_qp_P = 8;
    params->rc_params.h265_cbr_params.max_qp_P = 50;
    params->rc_params.h265_cbr_params.min_qp_B = 8;
    params->rc_params.h265_cbr_params.max_qp_B = 50;
    params->rc_params.h265_cbr_params.hvs_qp_enable = 1;
    params->rc_params.h265_cbr_params.hvs_qp_scale = 2;
    params->rc_params.h265_cbr_params.max_delta_qp = 10;
    params->rc_params.h265_cbr_params.qp_map_enable = 0;
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h265_cbr_dynamic_bitrate) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "cbr_dynamic_bitrate";
    char inputSuffix[MAX_FILE_PATH] = "_long.yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    ret = hb_mm_mc_get_rate_control_config(context, &params->rc_params);
    ASSERT_EQ(ret, (int32_t)0);
    params->rc_params.h265_cbr_params.intra_period = 20;
    params->rc_params.h265_cbr_params.intra_qp = 20;
    params->rc_params.h265_cbr_params.bit_rate = 1000;
    params->rc_params.h265_cbr_params.frame_rate = 30;
    params->rc_params.h265_cbr_params.initial_rc_qp = 30;
    params->rc_params.h265_cbr_params.vbv_buffer_size = 2000;
    params->rc_params.h265_cbr_params.ctu_level_rc_enalbe = 0;
    params->rc_params.h265_cbr_params.min_qp_I = 8;
    params->rc_params.h265_cbr_params.max_qp_I = 50;
    params->rc_params.h265_cbr_params.min_qp_P = 8;
    params->rc_params.h265_cbr_params.max_qp_P = 50;
    params->rc_params.h265_cbr_params.min_qp_B = 8;
    params->rc_params.h265_cbr_params.max_qp_B = 50;
    params->rc_params.h265_cbr_params.hvs_qp_enable = 1;
    params->rc_params.h265_cbr_params.hvs_qp_scale = 2;
    params->rc_params.h265_cbr_params.max_delta_qp = 10;
    params->rc_params.h265_cbr_params.qp_map_enable = 0;
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    ctx.dynamicTest = 1;
    ctx.dynamicMessage = ENC_CONFIG_RATE_CONTROL;
    ctx.rc_params_dynamic = params->rc_params;
    ctx.rc_params_dynamic.h265_cbr_params.bit_rate = 3000;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h265_cbr_dynamic_fps) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "cbr_dynamic_fps";
    char inputSuffix[MAX_FILE_PATH] = "_long.yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    ret = hb_mm_mc_get_rate_control_config(context, &params->rc_params);
    ASSERT_EQ(ret, (int32_t)0);
    params->rc_params.h265_cbr_params.intra_period = 20;
    params->rc_params.h265_cbr_params.intra_qp = 20;
    params->rc_params.h265_cbr_params.bit_rate = 1000;
    params->rc_params.h265_cbr_params.frame_rate = 30;
    params->rc_params.h265_cbr_params.initial_rc_qp = 30;
    params->rc_params.h265_cbr_params.vbv_buffer_size = 2000;
    params->rc_params.h265_cbr_params.ctu_level_rc_enalbe = 0;
    params->rc_params.h265_cbr_params.min_qp_I = 8;
    params->rc_params.h265_cbr_params.max_qp_I = 50;
    params->rc_params.h265_cbr_params.min_qp_P = 8;
    params->rc_params.h265_cbr_params.max_qp_P = 50;
    params->rc_params.h265_cbr_params.min_qp_B = 8;
    params->rc_params.h265_cbr_params.max_qp_B = 50;
    params->rc_params.h265_cbr_params.hvs_qp_enable = 1;
    params->rc_params.h265_cbr_params.hvs_qp_scale = 2;
    params->rc_params.h265_cbr_params.max_delta_qp = 10;
    params->rc_params.h265_cbr_params.qp_map_enable = 0;
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    ctx.dynamicTest = 1;
    ctx.dynamicMessage = ENC_CONFIG_RATE_CONTROL;
    ctx.rc_params_dynamic = params->rc_params;
    ctx.rc_params_dynamic.h265_cbr_params.frame_rate = 60;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h265_cbr_dynamic_intra_period) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "cbr_dynamic_intra_period";
    char inputSuffix[MAX_FILE_PATH] = "_long.yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    ret = hb_mm_mc_get_rate_control_config(context, &params->rc_params);
    ASSERT_EQ(ret, (int32_t)0);
    params->rc_params.h265_cbr_params.intra_period = 20;
    params->rc_params.h265_cbr_params.intra_qp = 20;
    params->rc_params.h265_cbr_params.bit_rate = 1000;
    params->rc_params.h265_cbr_params.frame_rate = 30;
    params->rc_params.h265_cbr_params.initial_rc_qp = 30;
    params->rc_params.h265_cbr_params.vbv_buffer_size = 2000;
    params->rc_params.h265_cbr_params.ctu_level_rc_enalbe = 0;
    params->rc_params.h265_cbr_params.min_qp_I = 8;
    params->rc_params.h265_cbr_params.max_qp_I = 50;
    params->rc_params.h265_cbr_params.min_qp_P = 8;
    params->rc_params.h265_cbr_params.max_qp_P = 50;
    params->rc_params.h265_cbr_params.min_qp_B = 8;
    params->rc_params.h265_cbr_params.max_qp_B = 50;
    params->rc_params.h265_cbr_params.hvs_qp_enable = 1;
    params->rc_params.h265_cbr_params.hvs_qp_scale = 2;
    params->rc_params.h265_cbr_params.max_delta_qp = 10;
    params->rc_params.h265_cbr_params.qp_map_enable = 0;
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    ctx.dynamicTest = 1;
    ctx.dynamicMessage = ENC_CONFIG_RATE_CONTROL;
    ctx.rc_params_dynamic = params->rc_params;
    ctx.rc_params_dynamic.h265_cbr_params.intra_period = 40;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h265_cbr_dynamic_intra_qp) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "cbr_dynamic_intra_qp";
    char inputSuffix[MAX_FILE_PATH] = "_long.yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    ret = hb_mm_mc_get_rate_control_config(context, &params->rc_params);
    ASSERT_EQ(ret, (int32_t)0);
    params->rc_params.h265_cbr_params.intra_period = 20;
    params->rc_params.h265_cbr_params.intra_qp = 20;
    params->rc_params.h265_cbr_params.bit_rate = 1000;
    params->rc_params.h265_cbr_params.frame_rate = 30;
    params->rc_params.h265_cbr_params.initial_rc_qp = 30;
    params->rc_params.h265_cbr_params.vbv_buffer_size = 2000;
    params->rc_params.h265_cbr_params.ctu_level_rc_enalbe = 0;
    params->rc_params.h265_cbr_params.min_qp_I = 8;
    params->rc_params.h265_cbr_params.max_qp_I = 50;
    params->rc_params.h265_cbr_params.min_qp_P = 8;
    params->rc_params.h265_cbr_params.max_qp_P = 50;
    params->rc_params.h265_cbr_params.min_qp_B = 8;
    params->rc_params.h265_cbr_params.max_qp_B = 50;
    params->rc_params.h265_cbr_params.hvs_qp_enable = 1;
    params->rc_params.h265_cbr_params.hvs_qp_scale = 2;
    params->rc_params.h265_cbr_params.max_delta_qp = 10;
    params->rc_params.h265_cbr_params.qp_map_enable = 0;
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    ctx.dynamicTest = 1;
    ctx.dynamicMessage = ENC_CONFIG_RATE_CONTROL;
    ctx.rc_params_dynamic = params->rc_params;
    ctx.rc_params_dynamic.h265_cbr_params.intra_qp = 30;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h265_cbr_dynamic_initial_qp) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "cbr_dynamic_initial_qp";
    char inputSuffix[MAX_FILE_PATH] = "_long.yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    ret = hb_mm_mc_get_rate_control_config(context, &params->rc_params);
    ASSERT_EQ(ret, (int32_t)0);
    params->rc_params.h265_cbr_params.intra_period = 20;
    params->rc_params.h265_cbr_params.intra_qp = 20;
    params->rc_params.h265_cbr_params.bit_rate = 1000;
    params->rc_params.h265_cbr_params.frame_rate = 30;
    params->rc_params.h265_cbr_params.initial_rc_qp = 30;
    params->rc_params.h265_cbr_params.vbv_buffer_size = 2000;
    params->rc_params.h265_cbr_params.ctu_level_rc_enalbe = 0;
    params->rc_params.h265_cbr_params.min_qp_I = 8;
    params->rc_params.h265_cbr_params.max_qp_I = 50;
    params->rc_params.h265_cbr_params.min_qp_P = 8;
    params->rc_params.h265_cbr_params.max_qp_P = 50;
    params->rc_params.h265_cbr_params.min_qp_B = 8;
    params->rc_params.h265_cbr_params.max_qp_B = 50;
    params->rc_params.h265_cbr_params.hvs_qp_enable = 1;
    params->rc_params.h265_cbr_params.hvs_qp_scale = 2;
    params->rc_params.h265_cbr_params.max_delta_qp = 10;
    params->rc_params.h265_cbr_params.qp_map_enable = 0;
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    ctx.dynamicTest = 1;
    ctx.dynamicMessage = ENC_CONFIG_RATE_CONTROL;
    ctx.rc_params_dynamic = params->rc_params;
    ctx.rc_params_dynamic.h265_cbr_params.initial_rc_qp = 20;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h265_cbr_dynamic_vbv) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "cbr_dynamic_vbv";
    char inputSuffix[MAX_FILE_PATH] = "_long.yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    ret = hb_mm_mc_get_rate_control_config(context, &params->rc_params);
    ASSERT_EQ(ret, (int32_t)0);
    params->rc_params.h265_cbr_params.intra_period = 20;
    params->rc_params.h265_cbr_params.intra_qp = 20;
    params->rc_params.h265_cbr_params.bit_rate = 1000;
    params->rc_params.h265_cbr_params.frame_rate = 30;
    params->rc_params.h265_cbr_params.initial_rc_qp = 20;
    params->rc_params.h265_cbr_params.vbv_buffer_size = 2000;
    params->rc_params.h265_cbr_params.ctu_level_rc_enalbe = 0;
    params->rc_params.h265_cbr_params.min_qp_I = 8;
    params->rc_params.h265_cbr_params.max_qp_I = 50;
    params->rc_params.h265_cbr_params.min_qp_P = 8;
    params->rc_params.h265_cbr_params.max_qp_P = 50;
    params->rc_params.h265_cbr_params.min_qp_B = 8;
    params->rc_params.h265_cbr_params.max_qp_B = 50;
    params->rc_params.h265_cbr_params.hvs_qp_enable = 1;
    params->rc_params.h265_cbr_params.hvs_qp_scale = 2;
    params->rc_params.h265_cbr_params.max_delta_qp = 10;
    params->rc_params.h265_cbr_params.qp_map_enable = 0;
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    ctx.dynamicTest = 1;
    ctx.dynamicMessage = ENC_CONFIG_RATE_CONTROL;
    ctx.rc_params_dynamic = params->rc_params;
    ctx.rc_params_dynamic.h265_cbr_params.vbv_buffer_size = 20;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h265_cbr_dynamic_ctu) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "cbr_dynamic_ctu";
    char inputSuffix[MAX_FILE_PATH] = "_long.yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    ret = hb_mm_mc_get_rate_control_config(context, &params->rc_params);
    ASSERT_EQ(ret, (int32_t)0);
    params->rc_params.h265_cbr_params.intra_period = 20;
    params->rc_params.h265_cbr_params.intra_qp = 20;
    params->rc_params.h265_cbr_params.bit_rate = 1000;
    params->rc_params.h265_cbr_params.frame_rate = 30;
    params->rc_params.h265_cbr_params.initial_rc_qp = 20;
    params->rc_params.h265_cbr_params.vbv_buffer_size = 2000;
    params->rc_params.h265_cbr_params.ctu_level_rc_enalbe = 0;
    params->rc_params.h265_cbr_params.min_qp_I = 8;
    params->rc_params.h265_cbr_params.max_qp_I = 50;
    params->rc_params.h265_cbr_params.min_qp_P = 8;
    params->rc_params.h265_cbr_params.max_qp_P = 50;
    params->rc_params.h265_cbr_params.min_qp_B = 8;
    params->rc_params.h265_cbr_params.max_qp_B = 50;
    params->rc_params.h265_cbr_params.hvs_qp_enable = 1;
    params->rc_params.h265_cbr_params.hvs_qp_scale = 2;
    params->rc_params.h265_cbr_params.max_delta_qp = 10;
    params->rc_params.h265_cbr_params.qp_map_enable = 0;
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    ctx.dynamicTest = 1;
    ctx.dynamicMessage = ENC_CONFIG_RATE_CONTROL;
    ctx.rc_params_dynamic = params->rc_params;
    ctx.rc_params_dynamic.h265_cbr_params.ctu_level_rc_enalbe = 1;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h265_cbr_dynamic_hvs_disable) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "cbr_dynamic_hvs_disable";
    char inputSuffix[MAX_FILE_PATH] = "_long.yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    ret = hb_mm_mc_get_rate_control_config(context, &params->rc_params);
    ASSERT_EQ(ret, (int32_t)0);
    params->rc_params.h265_cbr_params.intra_period = 20;
    params->rc_params.h265_cbr_params.intra_qp = 20;
    params->rc_params.h265_cbr_params.bit_rate = 1000;
    params->rc_params.h265_cbr_params.frame_rate = 30;
    params->rc_params.h265_cbr_params.initial_rc_qp = 20;
    params->rc_params.h265_cbr_params.vbv_buffer_size = 2000;
    params->rc_params.h265_cbr_params.ctu_level_rc_enalbe = 0;
    params->rc_params.h265_cbr_params.min_qp_I = 8;
    params->rc_params.h265_cbr_params.max_qp_I = 50;
    params->rc_params.h265_cbr_params.min_qp_P = 8;
    params->rc_params.h265_cbr_params.max_qp_P = 50;
    params->rc_params.h265_cbr_params.min_qp_B = 8;
    params->rc_params.h265_cbr_params.max_qp_B = 50;
    params->rc_params.h265_cbr_params.hvs_qp_enable = 1;
    params->rc_params.h265_cbr_params.hvs_qp_scale = 2;
    params->rc_params.h265_cbr_params.max_delta_qp = 10;
    params->rc_params.h265_cbr_params.qp_map_enable = 0;
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    ctx.dynamicTest = 1;
    ctx.dynamicMessage = ENC_CONFIG_RATE_CONTROL;
    ctx.rc_params_dynamic = params->rc_params;
    ctx.rc_params_dynamic.h265_cbr_params.hvs_qp_enable = 0;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h265_cbr_dynamic_hvs_scale) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "cbr_dynamic_hvs_scale";
    char inputSuffix[MAX_FILE_PATH] = "_long.yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    ret = hb_mm_mc_get_rate_control_config(context, &params->rc_params);
    ASSERT_EQ(ret, (int32_t)0);
    params->rc_params.h265_cbr_params.intra_period = 20;
    params->rc_params.h265_cbr_params.intra_qp = 20;
    params->rc_params.h265_cbr_params.bit_rate = 1000;
    params->rc_params.h265_cbr_params.frame_rate = 30;
    params->rc_params.h265_cbr_params.initial_rc_qp = 20;
    params->rc_params.h265_cbr_params.vbv_buffer_size = 2000;
    params->rc_params.h265_cbr_params.ctu_level_rc_enalbe = 0;
    params->rc_params.h265_cbr_params.min_qp_I = 8;
    params->rc_params.h265_cbr_params.max_qp_I = 50;
    params->rc_params.h265_cbr_params.min_qp_P = 8;
    params->rc_params.h265_cbr_params.max_qp_P = 50;
    params->rc_params.h265_cbr_params.min_qp_B = 8;
    params->rc_params.h265_cbr_params.max_qp_B = 50;
    params->rc_params.h265_cbr_params.hvs_qp_enable = 1;
    params->rc_params.h265_cbr_params.hvs_qp_scale = 2;
    params->rc_params.h265_cbr_params.max_delta_qp = 10;
    params->rc_params.h265_cbr_params.qp_map_enable = 0;
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    ctx.dynamicTest = 1;
    ctx.dynamicMessage = ENC_CONFIG_RATE_CONTROL;
    ctx.rc_params_dynamic = params->rc_params;
    ctx.rc_params_dynamic.h265_cbr_params.hvs_qp_scale = 4;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h265_cbr_dynamic_hvs_max) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "cbr_dynamic_hvs_max";
    char inputSuffix[MAX_FILE_PATH] = "_long.yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    ret = hb_mm_mc_get_rate_control_config(context, &params->rc_params);
    ASSERT_EQ(ret, (int32_t)0);
    params->rc_params.h265_cbr_params.intra_period = 20;
    params->rc_params.h265_cbr_params.intra_qp = 20;
    params->rc_params.h265_cbr_params.bit_rate = 1000;
    params->rc_params.h265_cbr_params.frame_rate = 30;
    params->rc_params.h265_cbr_params.initial_rc_qp = 20;
    params->rc_params.h265_cbr_params.vbv_buffer_size = 2000;
    params->rc_params.h265_cbr_params.ctu_level_rc_enalbe = 0;
    params->rc_params.h265_cbr_params.min_qp_I = 8;
    params->rc_params.h265_cbr_params.max_qp_I = 50;
    params->rc_params.h265_cbr_params.min_qp_P = 8;
    params->rc_params.h265_cbr_params.max_qp_P = 50;
    params->rc_params.h265_cbr_params.min_qp_B = 8;
    params->rc_params.h265_cbr_params.max_qp_B = 50;
    params->rc_params.h265_cbr_params.hvs_qp_enable = 1;
    params->rc_params.h265_cbr_params.hvs_qp_scale = 2;
    params->rc_params.h265_cbr_params.max_delta_qp = 10;
    params->rc_params.h265_cbr_params.qp_map_enable = 0;
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    ctx.dynamicTest = 1;
    ctx.dynamicMessage = ENC_CONFIG_RATE_CONTROL;
    ctx.rc_params_dynamic = params->rc_params;
    ctx.rc_params_dynamic.h265_cbr_params.max_delta_qp = 5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h265_cbr_dynamic_qp_map_enable) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "cbr_dynamic_qp_map_enable";
    char inputSuffix[MAX_FILE_PATH] = "_long.yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    ret = hb_mm_mc_get_rate_control_config(context, &params->rc_params);
    ASSERT_EQ(ret, (int32_t)0);
    params->rc_params.h265_cbr_params.intra_period = 20;
    params->rc_params.h265_cbr_params.intra_qp = 20;
    params->rc_params.h265_cbr_params.bit_rate = 1000;
    params->rc_params.h265_cbr_params.frame_rate = 30;
    params->rc_params.h265_cbr_params.initial_rc_qp = 20;
    params->rc_params.h265_cbr_params.vbv_buffer_size = 2000;
    params->rc_params.h265_cbr_params.ctu_level_rc_enalbe = 0;
    params->rc_params.h265_cbr_params.min_qp_I = 8;
    params->rc_params.h265_cbr_params.max_qp_I = 50;
    params->rc_params.h265_cbr_params.min_qp_P = 8;
    params->rc_params.h265_cbr_params.max_qp_P = 50;
    params->rc_params.h265_cbr_params.min_qp_B = 8;
    params->rc_params.h265_cbr_params.max_qp_B = 50;
    params->rc_params.h265_cbr_params.hvs_qp_enable = 0;
    params->rc_params.h265_cbr_params.hvs_qp_scale = 2;
    params->rc_params.h265_cbr_params.max_delta_qp = 10;
    params->rc_params.h265_cbr_params.qp_map_enable = 1;
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    ctx.dynamicTest = 1;
    ctx.dynamicMessage = ENC_CONFIG_RATE_CONTROL;
    ctx.rc_params_dynamic = params->rc_params;
    ctx.rc_params_dynamic.h265_cbr_params.qp_map_enable = 1;
    ctx.qpmap_enable_dynamic = 1;
#ifdef J5
    ctx.qpmap_count_dynamic = (((params->width+0x3f)&~0x3f) >> 6)
        *(((params->height+0x3f)&~0x3f) >> 6);
#else
    ctx.qpmap_count_dynamic = (((params->width+0x3f)&~0x3f) >> 5)
        *(((params->height+0x3f)&~0x3f) >> 5);
#endif
    ctx.qpmap_array_dynamic =
        (unsigned char*)malloc(ctx.qpmap_count_dynamic * sizeof(unsigned char));
    for (unsigned int i=0; i<ctx.qpmap_count_dynamic; i++) {
        if (i > ctx.qpmap_count_dynamic/2)
            ctx.qpmap_array_dynamic[i] = 4;
        else
            ctx.qpmap_array_dynamic[i] = 0;
    }
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h265_cbr_with_qpmap) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "cbr_qpmap";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    ret = hb_mm_mc_get_rate_control_config(context, &params->rc_params);
    ASSERT_EQ(ret, (int32_t)0);
    params->rc_params.h265_cbr_params.intra_period = 20;
    params->rc_params.h265_cbr_params.intra_qp = 20;
    params->rc_params.h265_cbr_params.bit_rate = 1000;
    params->rc_params.h265_cbr_params.frame_rate = 30;
    params->rc_params.h265_cbr_params.initial_rc_qp = 20;
    params->rc_params.h265_cbr_params.vbv_buffer_size = 20;
    params->rc_params.h265_cbr_params.ctu_level_rc_enalbe = 0;
    params->rc_params.h265_cbr_params.min_qp_I = 8;
    params->rc_params.h265_cbr_params.max_qp_I = 50;
    params->rc_params.h265_cbr_params.min_qp_P = 8;
    params->rc_params.h265_cbr_params.max_qp_P = 50;
    params->rc_params.h265_cbr_params.min_qp_B = 8;
    params->rc_params.h265_cbr_params.max_qp_B = 50;
#ifdef J5
    params->rc_params.h265_cbr_params.hvs_qp_enable = 0;
#else
    params->rc_params.h265_cbr_params.hvs_qp_enable = 1;
#endif
    params->rc_params.h265_cbr_params.hvs_qp_scale = 2;
    params->rc_params.h265_cbr_params.max_delta_qp = 10;
    params->rc_params.h265_cbr_params.qp_map_enable = 1;
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h265_avbr) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "avbr";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    params->rc_params.mode = MC_AV_RC_MODE_H265AVBR;
    ret = hb_mm_mc_get_rate_control_config(context, &params->rc_params);
    ASSERT_EQ(ret, (int32_t)0);
    params->rc_params.h265_avbr_params.intra_period = 20;
    params->rc_params.h265_avbr_params.intra_qp = 30;
    params->rc_params.h265_avbr_params.bit_rate = 500;
    params->rc_params.h265_avbr_params.frame_rate = 25;
    params->rc_params.h265_avbr_params.initial_rc_qp = 30;
    params->rc_params.h265_avbr_params.vbv_buffer_size = 3000;
    params->rc_params.h265_avbr_params.ctu_level_rc_enalbe = 1;
    params->rc_params.h265_avbr_params.min_qp_I = 8;
    params->rc_params.h265_avbr_params.max_qp_I = 51;
    params->rc_params.h265_avbr_params.min_qp_P = 8;
    params->rc_params.h265_avbr_params.max_qp_P = 51;
    params->rc_params.h265_avbr_params.min_qp_B = 8;
    params->rc_params.h265_avbr_params.max_qp_B = 51;
    params->rc_params.h265_avbr_params.hvs_qp_enable = 1;
    params->rc_params.h265_avbr_params.hvs_qp_scale = 2;
    params->rc_params.h265_avbr_params.max_delta_qp = 10;
    params->rc_params.h265_avbr_params.qp_map_enable = 0;
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h265_avbr_2) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "avbr2";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    params->rc_params.mode = MC_AV_RC_MODE_H265AVBR;
    ret = hb_mm_mc_get_rate_control_config(context, &params->rc_params);
    ASSERT_EQ(ret, (int32_t)0);
    params->rc_params.h265_avbr_params.intra_period = 20;
    params->rc_params.h265_avbr_params.intra_qp = 20;
    params->rc_params.h265_avbr_params.bit_rate = 1000;
    params->rc_params.h265_avbr_params.frame_rate = 25;
    params->rc_params.h265_avbr_params.initial_rc_qp = 20;
    params->rc_params.h265_avbr_params.vbv_buffer_size = 3000;
    params->rc_params.h265_avbr_params.ctu_level_rc_enalbe = 0;
    params->rc_params.h265_avbr_params.min_qp_I = 15;
    params->rc_params.h265_avbr_params.max_qp_I = 50;
    params->rc_params.h265_avbr_params.min_qp_P = 8;
    params->rc_params.h265_avbr_params.max_qp_P = 45;
    params->rc_params.h265_avbr_params.min_qp_B = 8;
    params->rc_params.h265_avbr_params.max_qp_B = 48;
    params->rc_params.h265_avbr_params.hvs_qp_enable = 0;
    params->rc_params.h265_avbr_params.hvs_qp_scale = 2;
    params->rc_params.h265_avbr_params.max_delta_qp = 5;
    params->rc_params.h265_avbr_params.qp_map_enable = 0;
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

#ifdef J5
TEST_F(MediaCodecTest, test_encoding_effect_case_h265_avbr_and_tranrate) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "avbr_transrate";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    params->rc_params.mode = MC_AV_RC_MODE_H265AVBR;
    ret = hb_mm_mc_get_rate_control_config(context, &params->rc_params);
    ASSERT_EQ(ret, (int32_t)0);
    params->rc_params.h265_avbr_params.intra_period = 20;
    params->rc_params.h265_avbr_params.intra_qp = 20;
    params->rc_params.h265_avbr_params.bit_rate = 1000;
    params->rc_params.h265_avbr_params.frame_rate = 25;
    params->rc_params.h265_avbr_params.initial_rc_qp = 20;
    params->rc_params.h265_avbr_params.vbv_buffer_size = 3000;
    params->rc_params.h265_avbr_params.ctu_level_rc_enalbe = 0;
    params->rc_params.h265_avbr_params.min_qp_I = 15;
    params->rc_params.h265_avbr_params.max_qp_I = 50;
    params->rc_params.h265_avbr_params.min_qp_P = 8;
    params->rc_params.h265_avbr_params.max_qp_P = 45;
    params->rc_params.h265_avbr_params.min_qp_B = 8;
    params->rc_params.h265_avbr_params.max_qp_B = 48;
    params->rc_params.h265_avbr_params.hvs_qp_enable = 0;
    params->rc_params.h265_avbr_params.hvs_qp_scale = 2;
    params->rc_params.h265_avbr_params.max_delta_qp = 5;
    params->rc_params.h265_avbr_params.qp_map_enable = 0;
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    hb_u32 *max_bitrate = &ctx.max_bitrate;
    ret = hb_mm_mc_get_max_bit_rate_config(context, max_bitrate);
    ASSERT_EQ(ret, (int32_t)0);
    *max_bitrate = 1500;
    ctx.message = ENC_CONFIG_TRANS_BITRATE;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h265_avbr_and_tranrate_2) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "avbr_transrate2";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    params->rc_params.mode = MC_AV_RC_MODE_H265AVBR;
    ret = hb_mm_mc_get_rate_control_config(context, &params->rc_params);
    ASSERT_EQ(ret, (int32_t)0);
    params->rc_params.h265_avbr_params.intra_period = 20;
    params->rc_params.h265_avbr_params.intra_qp = 20;
    params->rc_params.h265_avbr_params.bit_rate = 1000;
    params->rc_params.h265_avbr_params.frame_rate = 25;
    params->rc_params.h265_avbr_params.initial_rc_qp = 20;
    params->rc_params.h265_avbr_params.vbv_buffer_size = 3000;
    params->rc_params.h265_avbr_params.ctu_level_rc_enalbe = 0;
    params->rc_params.h265_avbr_params.min_qp_I = 15;
    params->rc_params.h265_avbr_params.max_qp_I = 50;
    params->rc_params.h265_avbr_params.min_qp_P = 8;
    params->rc_params.h265_avbr_params.max_qp_P = 45;
    params->rc_params.h265_avbr_params.min_qp_B = 8;
    params->rc_params.h265_avbr_params.max_qp_B = 48;
    params->rc_params.h265_avbr_params.hvs_qp_enable = 0;
    params->rc_params.h265_avbr_params.hvs_qp_scale = 2;
    params->rc_params.h265_avbr_params.max_delta_qp = 5;
    params->rc_params.h265_avbr_params.qp_map_enable = 0;
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    hb_u32 *max_bitrate = &ctx.max_bitrate;
    ret = hb_mm_mc_get_max_bit_rate_config(context, max_bitrate);
    ASSERT_EQ(ret, (int32_t)0);
    *max_bitrate = params->rc_params.h265_avbr_params.bit_rate - 100;
    ctx.message = ENC_CONFIG_TRANS_BITRATE;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h265_avbr_and_tranrate_dynamic) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "dynamic_avbr_transrate";
    char inputSuffix[MAX_FILE_PATH] = "_long.yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    params->rc_params.mode = MC_AV_RC_MODE_H265AVBR;
    ret = hb_mm_mc_get_rate_control_config(context, &params->rc_params);
    ASSERT_EQ(ret, (int32_t)0);
    params->rc_params.h265_avbr_params.intra_period = 20;
    params->rc_params.h265_avbr_params.intra_qp = 20;
    params->rc_params.h265_avbr_params.bit_rate = 1000;
    params->rc_params.h265_avbr_params.frame_rate = 25;
    params->rc_params.h265_avbr_params.initial_rc_qp = 20;
    params->rc_params.h265_avbr_params.vbv_buffer_size = 300;
    params->rc_params.h265_avbr_params.ctu_level_rc_enalbe = 0;
    params->rc_params.h265_avbr_params.min_qp_I = 15;
    params->rc_params.h265_avbr_params.max_qp_I = 50;
    params->rc_params.h265_avbr_params.min_qp_P = 8;
    params->rc_params.h265_avbr_params.max_qp_P = 45;
    params->rc_params.h265_avbr_params.min_qp_B = 8;
    params->rc_params.h265_avbr_params.max_qp_B = 48;
    params->rc_params.h265_avbr_params.hvs_qp_enable = 0;
    params->rc_params.h265_avbr_params.hvs_qp_scale = 2;
    params->rc_params.h265_avbr_params.max_delta_qp = 5;
    params->rc_params.h265_avbr_params.qp_map_enable = 0;
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    hb_u32 *max_bitrate = &ctx.max_bitrate;
    ret = hb_mm_mc_get_max_bit_rate_config(context, max_bitrate);
    ASSERT_EQ(ret, (int32_t)0);
    *max_bitrate = 1000;
    ctx.message = ENC_CONFIG_TRANS_BITRATE;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    ctx.dynamicTest = 1;
    ctx.dynamicMessage = ENC_CONFIG_TRANS_BITRATE;
    ctx.max_bitrate_dynamic = 2000;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

#endif

TEST_F(MediaCodecTest, test_encoding_case_h265_avbr_dynamic_intra_period) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "avbr_dynamic_intra_period";
    char inputSuffix[MAX_FILE_PATH] = "_long.yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    params->rc_params.mode = MC_AV_RC_MODE_H265AVBR;
    ret = hb_mm_mc_get_rate_control_config(context, &params->rc_params);
    ASSERT_EQ(ret, (int32_t)0);
    params->rc_params.h265_avbr_params.intra_period = 20;
    params->rc_params.h265_avbr_params.intra_qp = 20;
    params->rc_params.h265_avbr_params.bit_rate = 1000;
    params->rc_params.h265_avbr_params.frame_rate = 30;
    params->rc_params.h265_avbr_params.initial_rc_qp = 30;
    params->rc_params.h265_avbr_params.vbv_buffer_size = 2000;
    params->rc_params.h265_avbr_params.ctu_level_rc_enalbe = 0;
    params->rc_params.h265_avbr_params.min_qp_I = 8;
    params->rc_params.h265_avbr_params.max_qp_I = 50;
    params->rc_params.h265_avbr_params.min_qp_P = 8;
    params->rc_params.h265_avbr_params.max_qp_P = 50;
    params->rc_params.h265_avbr_params.min_qp_B = 8;
    params->rc_params.h265_avbr_params.max_qp_B = 50;
    params->rc_params.h265_avbr_params.hvs_qp_enable = 1;
    params->rc_params.h265_avbr_params.hvs_qp_scale = 2;
    params->rc_params.h265_avbr_params.max_delta_qp = 10;
    params->rc_params.h265_avbr_params.qp_map_enable = 0;
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    ctx.dynamicTest = 1;
    ctx.dynamicMessage = ENC_CONFIG_RATE_CONTROL;
    ctx.rc_params_dynamic = params->rc_params;
    ctx.rc_params_dynamic.h265_avbr_params.intra_period = 10;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h265_avbr_dynamic_fps) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "avbr_dynamic_fps";
    char inputSuffix[MAX_FILE_PATH] = "_long.yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    params->rc_params.mode = MC_AV_RC_MODE_H265AVBR;
    ret = hb_mm_mc_get_rate_control_config(context, &params->rc_params);
    ASSERT_EQ(ret, (int32_t)0);
    params->rc_params.h265_avbr_params.intra_period = 20;
    params->rc_params.h265_avbr_params.intra_qp = 20;
    params->rc_params.h265_avbr_params.bit_rate = 1000;
    params->rc_params.h265_avbr_params.frame_rate = 30;
    params->rc_params.h265_avbr_params.initial_rc_qp = 30;
    params->rc_params.h265_avbr_params.vbv_buffer_size = 2000;
    params->rc_params.h265_avbr_params.ctu_level_rc_enalbe = 0;
    params->rc_params.h265_avbr_params.min_qp_I = 8;
    params->rc_params.h265_avbr_params.max_qp_I = 50;
    params->rc_params.h265_avbr_params.min_qp_P = 8;
    params->rc_params.h265_avbr_params.max_qp_P = 50;
    params->rc_params.h265_avbr_params.min_qp_B = 8;
    params->rc_params.h265_avbr_params.max_qp_B = 50;
    params->rc_params.h265_avbr_params.hvs_qp_enable = 1;
    params->rc_params.h265_avbr_params.hvs_qp_scale = 2;
    params->rc_params.h265_avbr_params.max_delta_qp = 10;
    params->rc_params.h265_avbr_params.qp_map_enable = 0;
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    ctx.dynamicTest = 1;
    ctx.dynamicMessage = ENC_CONFIG_RATE_CONTROL;
    ctx.rc_params_dynamic = params->rc_params;
    ctx.rc_params_dynamic.h265_avbr_params.frame_rate = 15;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h265_avbr_dynamic_bitrate) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "avbr_dynamic_bitrate";
    char inputSuffix[MAX_FILE_PATH] = "_long.yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    params->rc_params.mode = MC_AV_RC_MODE_H265AVBR;
    ret = hb_mm_mc_get_rate_control_config(context, &params->rc_params);
    ASSERT_EQ(ret, (int32_t)0);
    params->rc_params.h265_avbr_params.intra_period = 20;
    params->rc_params.h265_avbr_params.intra_qp = 20;
    params->rc_params.h265_avbr_params.bit_rate = 1000;
    params->rc_params.h265_avbr_params.frame_rate = 30;
    params->rc_params.h265_avbr_params.initial_rc_qp = 30;
    params->rc_params.h265_avbr_params.vbv_buffer_size = 2000;
    params->rc_params.h265_avbr_params.ctu_level_rc_enalbe = 0;
    params->rc_params.h265_avbr_params.min_qp_I = 8;
    params->rc_params.h265_avbr_params.max_qp_I = 50;
    params->rc_params.h265_avbr_params.min_qp_P = 8;
    params->rc_params.h265_avbr_params.max_qp_P = 50;
    params->rc_params.h265_avbr_params.min_qp_B = 8;
    params->rc_params.h265_avbr_params.max_qp_B = 50;
    params->rc_params.h265_avbr_params.hvs_qp_enable = 1;
    params->rc_params.h265_avbr_params.hvs_qp_scale = 2;
    params->rc_params.h265_avbr_params.max_delta_qp = 10;
    params->rc_params.h265_avbr_params.qp_map_enable = 0;
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    ctx.dynamicTest = 1;
    ctx.dynamicMessage = ENC_CONFIG_RATE_CONTROL;
    ctx.rc_params_dynamic = params->rc_params;
    ctx.rc_params_dynamic.h265_avbr_params.bit_rate = 4000;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h265_vbr) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "vbr";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    params->rc_params.mode = MC_AV_RC_MODE_H265VBR;
    ret = hb_mm_mc_get_rate_control_config(context, &params->rc_params);
    ASSERT_EQ(ret, (int32_t)0);
    params->rc_params.h265_vbr_params.intra_period = 30;
    params->rc_params.h265_vbr_params.intra_qp = 15;
    params->rc_params.h265_vbr_params.frame_rate = 25;
    params->rc_params.h265_vbr_params.qp_map_enable = 0;
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h265_vbr_2) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "vbr2";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    params->rc_params.mode = MC_AV_RC_MODE_H265VBR;
    ret = hb_mm_mc_get_rate_control_config(context, &params->rc_params);
    ASSERT_EQ(ret, (int32_t)0);
    params->rc_params.h265_vbr_params.intra_period = 20;
    params->rc_params.h265_vbr_params.intra_qp = 20;
    params->rc_params.h265_vbr_params.frame_rate = 30;
    params->rc_params.h265_vbr_params.qp_map_enable = 0;
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h265_vbr_dynamic_intra_period) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "vbr_dynamic_intra_period";
    char inputSuffix[MAX_FILE_PATH] = "_long.yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    params->rc_params.mode = MC_AV_RC_MODE_H265VBR;
    ret = hb_mm_mc_get_rate_control_config(context, &params->rc_params);
    ASSERT_EQ(ret, (int32_t)0);
    params->rc_params.h265_vbr_params.intra_period = 30;
    params->rc_params.h265_vbr_params.intra_qp = 15;
    params->rc_params.h265_vbr_params.frame_rate = 25;
    params->rc_params.h265_vbr_params.qp_map_enable = 0;
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    ctx.dynamicTest = 1;
    ctx.dynamicMessage = ENC_CONFIG_RATE_CONTROL;
    ctx.rc_params_dynamic = params->rc_params;
    ctx.rc_params_dynamic.h265_vbr_params.intra_period = 40;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h265_vbr_dynamic_fps) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "vbr_dynamic_fps";
    char inputSuffix[MAX_FILE_PATH] = "_long.yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    params->rc_params.mode = MC_AV_RC_MODE_H265VBR;
    ret = hb_mm_mc_get_rate_control_config(context, &params->rc_params);
    ASSERT_EQ(ret, (int32_t)0);
    params->rc_params.h265_vbr_params.intra_period = 30;
    params->rc_params.h265_vbr_params.intra_qp = 15;
    params->rc_params.h265_vbr_params.frame_rate = 25;
    params->rc_params.h265_vbr_params.qp_map_enable = 0;
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    ctx.dynamicTest = 1;
    ctx.dynamicMessage = ENC_CONFIG_RATE_CONTROL;
    ctx.rc_params_dynamic = params->rc_params;
    ctx.rc_params_dynamic.h265_vbr_params.intra_qp = 30;
    ctx.rc_params_dynamic.h265_vbr_params.frame_rate = 40;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h265_fixqp) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "fixqp";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    params->rc_params.mode = MC_AV_RC_MODE_H265FIXQP;
    ret = hb_mm_mc_get_rate_control_config(context, &params->rc_params);
    ASSERT_EQ(ret, (int32_t)0);
    params->rc_params.h265_fixqp_params.intra_period = 30;
    params->rc_params.h265_fixqp_params.frame_rate = 25;
    params->rc_params.h265_fixqp_params.force_qp_I = 15;
    params->rc_params.h265_fixqp_params.force_qp_P = 20;
    params->rc_params.h265_fixqp_params.force_qp_B = 30;
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h265_fixqp_2) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "fixqp2";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    params->rc_params.mode = MC_AV_RC_MODE_H265FIXQP;
    ret = hb_mm_mc_get_rate_control_config(context, &params->rc_params);
    ASSERT_EQ(ret, (int32_t)0);
    params->rc_params.h265_fixqp_params.intra_period = 20;
    params->rc_params.h265_fixqp_params.frame_rate = 15;
    params->rc_params.h265_fixqp_params.force_qp_I = 20;
    params->rc_params.h265_fixqp_params.force_qp_P = 30;
    params->rc_params.h265_fixqp_params.force_qp_B = 40;
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h265_fixqp_dynamic_intra_period) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "fixqp_dynamic_intra_period";
    char inputSuffix[MAX_FILE_PATH] = "_long.yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    params->rc_params.mode = MC_AV_RC_MODE_H265FIXQP;
    ret = hb_mm_mc_get_rate_control_config(context, &params->rc_params);
    ASSERT_EQ(ret, (int32_t)0);
    params->rc_params.h265_fixqp_params.intra_period = 30;
    params->rc_params.h265_fixqp_params.frame_rate = 25;
    params->rc_params.h265_fixqp_params.force_qp_I = 15;
    params->rc_params.h265_fixqp_params.force_qp_P = 20;
    params->rc_params.h265_fixqp_params.force_qp_B = 30;
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    ctx.dynamicTest = 1;
    ctx.dynamicMessage = ENC_CONFIG_RATE_CONTROL;
    ctx.rc_params_dynamic = params->rc_params;
    ctx.rc_params_dynamic.h265_fixqp_params.intra_period = 40;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h265_fixqp_dynamic_qp) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "fixqp_dynamic_qp";
    char inputSuffix[MAX_FILE_PATH] = "_long.yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    params->rc_params.mode = MC_AV_RC_MODE_H265FIXQP;
    ret = hb_mm_mc_get_rate_control_config(context, &params->rc_params);
    ASSERT_EQ(ret, (int32_t)0);
    params->rc_params.h265_fixqp_params.intra_period = 30;
    params->rc_params.h265_fixqp_params.frame_rate = 25;
    params->rc_params.h265_fixqp_params.force_qp_I = 15;
    params->rc_params.h265_fixqp_params.force_qp_P = 20;
    params->rc_params.h265_fixqp_params.force_qp_B = 30;
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    ctx.dynamicTest = 1;
    ctx.dynamicMessage = ENC_CONFIG_RATE_CONTROL;
    ctx.rc_params_dynamic = params->rc_params;
    ctx.rc_params_dynamic.h265_fixqp_params.force_qp_I = 20;
    ctx.rc_params_dynamic.h265_fixqp_params.force_qp_P = 25;
    ctx.rc_params_dynamic.h265_fixqp_params.force_qp_P = 15;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h265_qpmap) {
    hb_s32 ret = 0;
    int qp_count;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "qpmap";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    params->rc_params.mode = MC_AV_RC_MODE_H265QPMAP;
    ret = hb_mm_mc_get_rate_control_config(context, &params->rc_params);
    ASSERT_EQ(ret, (int32_t)0);
#ifdef J5
    qp_count = (((params->width+0x3f)&~0x3f) >> 6)
        *(((params->height+0x3f)&~0x3f) >> 6);
#else
    qp_count = (((params->width+0x3f)&~0x3f) >> 5)
        *(((params->height+0x3f)&~0x3f) >> 5);
#endif
    params->rc_params.h265_qpmap_params.intra_period = 20;
    params->rc_params.h265_qpmap_params.frame_rate = 15;
    params->rc_params.h265_qpmap_params.qp_map_array =
        (unsigned char*)malloc(qp_count*sizeof(unsigned char));
    params->rc_params.h265_qpmap_params.qp_map_array_count = qp_count;
    for (int i=0; i<qp_count; i++) {
        params->rc_params.h265_qpmap_params.qp_map_array[i] = 40;
    }
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (params->rc_params.h265_qpmap_params.qp_map_array)
        free(params->rc_params.h265_qpmap_params.qp_map_array);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h265_qpmap_2) {
    hb_s32 ret = 0;
    int qp_count;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "qpmap2";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    params->rc_params.mode = MC_AV_RC_MODE_H265QPMAP;
    ret = hb_mm_mc_get_rate_control_config(context, &params->rc_params);
    ASSERT_EQ(ret, (int32_t)0);
#ifdef J5
    qp_count = (((params->width+0x3f)&~0x3f) >> 6)
        *(((params->height+0x3f)&~0x3f) >> 6);
#else
    qp_count = (((params->width+0x3f)&~0x3f) >> 5)
        *(((params->height+0x3f)&~0x3f) >> 5);
#endif
    params->rc_params.h265_qpmap_params.intra_period = 15;
    params->rc_params.h265_qpmap_params.frame_rate = 25;
    params->rc_params.h265_qpmap_params.qp_map_array =
        (unsigned char*)malloc(qp_count*sizeof(unsigned char));
    params->rc_params.h265_qpmap_params.qp_map_array_count = qp_count;
    for (int i=0; i<qp_count; i++) {
        params->rc_params.h265_qpmap_params.qp_map_array[i] = 20;
    }
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (params->rc_params.h265_qpmap_params.qp_map_array)
        free(params->rc_params.h265_qpmap_params.qp_map_array);
    if (context != NULL) {
        free(context);
    }
}

#ifdef J5
TEST_F(MediaCodecTest, test_encoding_effect_case_h265_qpmap_3) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "qpmap3";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    params->rc_params.mode = MC_AV_RC_MODE_H265QPMAP;
    ret = hb_mm_mc_get_rate_control_config(context, &params->rc_params);
    ASSERT_EQ(ret, (int32_t)0);
    int qp_count = (((params->width+0x3f)&~0x3f) >> 6)
        *(((params->height+0x3f)&~0x3f) >> 6);
    params->rc_params.h265_qpmap_params.intra_period = 15;
    params->rc_params.h265_qpmap_params.frame_rate = 25;
    params->rc_params.h265_qpmap_params.qp_map_array =
        (unsigned char*)malloc(qp_count*sizeof(unsigned char));
    params->rc_params.h265_qpmap_params.qp_map_array_count = qp_count;
    for (int i=0; i<qp_count; i++) {
        params->rc_params.h265_qpmap_params.qp_map_array[i] = 20;
    }
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (params->rc_params.h265_qpmap_params.qp_map_array)
        free(params->rc_params.h265_qpmap_params.qp_map_array);
    if (context != NULL) {
        free(context);
    }
}
#endif

TEST_F(MediaCodecTest, test_encoding_case_h265_qpmap_dynamic) {
    hb_s32 ret = 0;
    int qp_count;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "qpmap_dynamic";
    char inputSuffix[MAX_FILE_PATH] = "_long.yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    params->rc_params.mode = MC_AV_RC_MODE_H265QPMAP;
    ret = hb_mm_mc_get_rate_control_config(context, &params->rc_params);
    ASSERT_EQ(ret, (int32_t)0);
#ifdef J5
    qp_count = (((params->width+0x3f)&~0x3f) >> 6)
        *(((params->height+0x3f)&~0x3f) >> 6);
#else
    qp_count = (((params->width+0x3f)&~0x3f) >> 5)
        *(((params->height+0x3f)&~0x3f) >> 5);
#endif
    params->rc_params.h265_qpmap_params.intra_period = 20;
    params->rc_params.h265_qpmap_params.frame_rate = 15;
    params->rc_params.h265_qpmap_params.qp_map_array =
        (unsigned char*)malloc(qp_count*sizeof(unsigned char));
    params->rc_params.h265_qpmap_params.qp_map_array_count = qp_count;
    for (int i=0; i<qp_count; i++) {
        params->rc_params.h265_qpmap_params.qp_map_array[i] = 40;
    }
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    ctx.dynamicTest = 1;
    ctx.dynamicMessage = ENC_CONFIG_RATE_CONTROL;
    ctx.rc_params_dynamic = params->rc_params;
    ctx.rc_params_dynamic.h265_qpmap_params.qp_map_array =
        (unsigned char*)malloc(qp_count*sizeof(unsigned char));
    ctx.rc_params_dynamic.h265_qpmap_params.qp_map_array_count = qp_count;
    for (int i=0; i<qp_count; i++) {
        if (i > qp_count/2)
            ctx.rc_params_dynamic.h265_qpmap_params.qp_map_array[i] = 20;
        else
            ctx.rc_params_dynamic.h265_qpmap_params.qp_map_array[i] = 30;
    }
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (params->rc_params.h265_qpmap_params.qp_map_array)
        free(params->rc_params.h265_qpmap_params.qp_map_array);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h264_profile) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H264;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "profile";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;
    params->h264_enc_config.h264_profile = MC_H264_PROFILE_MP;
    params->h264_enc_config.h264_level = MC_H264_LEVEL_UNSPECIFIED;

    params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    ret = hb_mm_mc_get_rate_control_config(context, &params->rc_params);
    ASSERT_EQ(ret, (int32_t)0);
    params->rc_params.h264_cbr_params.intra_period = 20;
    params->rc_params.h264_cbr_params.intra_qp = 20;
    params->rc_params.h264_cbr_params.bit_rate = 1000;
    params->rc_params.h264_cbr_params.frame_rate = 30;
    params->rc_params.h264_cbr_params.initial_rc_qp = 20;
    params->rc_params.h264_cbr_params.vbv_buffer_size = 20;
    params->rc_params.h264_cbr_params.mb_level_rc_enalbe = 0;
    params->rc_params.h264_cbr_params.min_qp_I = 8;
    params->rc_params.h264_cbr_params.max_qp_I = 50;
    params->rc_params.h264_cbr_params.min_qp_P = 8;
    params->rc_params.h264_cbr_params.max_qp_P = 50;
    params->rc_params.h264_cbr_params.min_qp_B = 8;
    params->rc_params.h264_cbr_params.max_qp_B = 50;
    params->rc_params.h264_cbr_params.hvs_qp_enable = 1;
    params->rc_params.h264_cbr_params.hvs_qp_scale = 2;
    params->rc_params.h264_cbr_params.max_delta_qp = 10;
    params->rc_params.h264_cbr_params.qp_map_enable = 0;
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h264_profile_1) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H264;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "profile1";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;
    params->h264_enc_config.h264_profile = MC_H264_PROFILE_HP;
    params->h264_enc_config.h264_level = MC_H264_LEVEL3_1;

    params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    ret = hb_mm_mc_get_rate_control_config(context, &params->rc_params);
    ASSERT_EQ(ret, (int32_t)0);
    params->rc_params.h264_cbr_params.intra_period = 20;
    params->rc_params.h264_cbr_params.intra_qp = 20;
    params->rc_params.h264_cbr_params.bit_rate = 1000;
    params->rc_params.h264_cbr_params.frame_rate = 30;
    params->rc_params.h264_cbr_params.initial_rc_qp = 20;
    params->rc_params.h264_cbr_params.vbv_buffer_size = 20;
    params->rc_params.h264_cbr_params.mb_level_rc_enalbe = 0;
    params->rc_params.h264_cbr_params.min_qp_I = 8;
    params->rc_params.h264_cbr_params.max_qp_I = 50;
    params->rc_params.h264_cbr_params.min_qp_P = 8;
    params->rc_params.h264_cbr_params.max_qp_P = 50;
    params->rc_params.h264_cbr_params.min_qp_B = 8;
    params->rc_params.h264_cbr_params.max_qp_B = 50;
    params->rc_params.h264_cbr_params.hvs_qp_enable = 1;
    params->rc_params.h264_cbr_params.hvs_qp_scale = 2;
    params->rc_params.h264_cbr_params.max_delta_qp = 10;
    params->rc_params.h264_cbr_params.qp_map_enable = 0;
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h265_profile) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "profile";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    ret = hb_mm_mc_get_rate_control_config(context, &params->rc_params);
    ASSERT_EQ(ret, (int32_t)0);
    params->rc_params.h265_cbr_params.intra_period = 20;
    params->rc_params.h265_cbr_params.intra_qp = 8;
    params->rc_params.h265_cbr_params.bit_rate = 200;
    params->rc_params.h265_cbr_params.frame_rate = 15;
    params->rc_params.h265_cbr_params.initial_rc_qp = 20;
    params->rc_params.h265_cbr_params.vbv_buffer_size = 20;
    params->rc_params.h265_cbr_params.ctu_level_rc_enalbe = 1;
    params->rc_params.h265_cbr_params.min_qp_I = 8;
    params->rc_params.h265_cbr_params.max_qp_I = 30;
    params->rc_params.h265_cbr_params.min_qp_P = 8;
    params->rc_params.h265_cbr_params.max_qp_P = 30;
    params->rc_params.h265_cbr_params.min_qp_B = 8;
    params->rc_params.h265_cbr_params.max_qp_B = 30;
    params->rc_params.h265_cbr_params.hvs_qp_enable = 1;
    params->rc_params.h265_cbr_params.hvs_qp_scale = 2;
    params->rc_params.h265_cbr_params.max_delta_qp = 10;
    params->rc_params.h265_cbr_params.qp_map_enable = 0;
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h265_profile_1) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "profile1";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;
    params->h265_enc_config.h265_level = MC_H265_LEVEL_UNSPECIFIED;
    params->h265_enc_config.h265_tier = 0;
    params->h265_enc_config.main_still_picture_profile_enable = 1;

    params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    ret = hb_mm_mc_get_rate_control_config(context, &params->rc_params);
    ASSERT_EQ(ret, (int32_t)0);
    params->rc_params.h265_cbr_params.intra_period = 20;
    params->rc_params.h265_cbr_params.intra_qp = 8;
    params->rc_params.h265_cbr_params.bit_rate = 200;
    params->rc_params.h265_cbr_params.frame_rate = 15;
    params->rc_params.h265_cbr_params.initial_rc_qp = 20;
    params->rc_params.h265_cbr_params.vbv_buffer_size = 20;
    params->rc_params.h265_cbr_params.ctu_level_rc_enalbe = 1;
    params->rc_params.h265_cbr_params.min_qp_I = 8;
    params->rc_params.h265_cbr_params.max_qp_I = 30;
    params->rc_params.h265_cbr_params.min_qp_P = 8;
    params->rc_params.h265_cbr_params.max_qp_P = 30;
    params->rc_params.h265_cbr_params.min_qp_B = 8;
    params->rc_params.h265_cbr_params.max_qp_B = 30;
    params->rc_params.h265_cbr_params.hvs_qp_enable = 1;
    params->rc_params.h265_cbr_params.hvs_qp_scale = 2;
    params->rc_params.h265_cbr_params.max_delta_qp = 10;
    params->rc_params.h265_cbr_params.qp_map_enable = 0;
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h265_profile_2) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "profile2";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;
    params->h265_enc_config.h265_level = MC_H265_LEVEL4_1;
    params->h265_enc_config.h265_tier = 1;
    params->h265_enc_config.main_still_picture_profile_enable = 1;

    params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    ret = hb_mm_mc_get_rate_control_config(context, &params->rc_params);
    ASSERT_EQ(ret, (int32_t)0);
    params->rc_params.h265_cbr_params.intra_period = 20;
    params->rc_params.h265_cbr_params.intra_qp = 8;
    params->rc_params.h265_cbr_params.bit_rate = 200;
    params->rc_params.h265_cbr_params.frame_rate = 15;
    params->rc_params.h265_cbr_params.initial_rc_qp = 20;
    params->rc_params.h265_cbr_params.vbv_buffer_size = 20;
    params->rc_params.h265_cbr_params.ctu_level_rc_enalbe = 1;
    params->rc_params.h265_cbr_params.min_qp_I = 8;
    params->rc_params.h265_cbr_params.max_qp_I = 30;
    params->rc_params.h265_cbr_params.min_qp_P = 8;
    params->rc_params.h265_cbr_params.max_qp_P = 30;
    params->rc_params.h265_cbr_params.min_qp_B = 8;
    params->rc_params.h265_cbr_params.max_qp_B = 30;
    params->rc_params.h265_cbr_params.hvs_qp_enable = 1;
    params->rc_params.h265_cbr_params.hvs_qp_scale = 2;
    params->rc_params.h265_cbr_params.max_delta_qp = 10;
    params->rc_params.h265_cbr_params.qp_map_enable = 0;
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h265_profile_3) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "profile3";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;
    params->h265_enc_config.h265_level = MC_H265_LEVEL_UNSPECIFIED;
    params->h265_enc_config.h265_tier = 0;
    params->h265_enc_config.main_still_picture_profile_enable = 0;

    params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    ret = hb_mm_mc_get_rate_control_config(context, &params->rc_params);
    ASSERT_EQ(ret, (int32_t)0);
    params->rc_params.h265_cbr_params.intra_period = 20;
    params->rc_params.h265_cbr_params.intra_qp = 8;
    params->rc_params.h265_cbr_params.bit_rate = 200;
    params->rc_params.h265_cbr_params.frame_rate = 15;
    params->rc_params.h265_cbr_params.initial_rc_qp = 20;
    params->rc_params.h265_cbr_params.vbv_buffer_size = 20;
    params->rc_params.h265_cbr_params.ctu_level_rc_enalbe = 1;
    params->rc_params.h265_cbr_params.min_qp_I = 8;
    params->rc_params.h265_cbr_params.max_qp_I = 30;
    params->rc_params.h265_cbr_params.min_qp_P = 8;
    params->rc_params.h265_cbr_params.max_qp_P = 30;
    params->rc_params.h265_cbr_params.min_qp_B = 8;
    params->rc_params.h265_cbr_params.max_qp_B = 30;
    params->rc_params.h265_cbr_params.hvs_qp_enable = 1;
    params->rc_params.h265_cbr_params.hvs_qp_scale = 2;
    params->rc_params.h265_cbr_params.max_delta_qp = 10;
    params->rc_params.h265_cbr_params.qp_map_enable = 0;
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h265_profile_4) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "profile4";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;
    params->h265_enc_config.h265_level = MC_H265_LEVEL4_1;
    params->h265_enc_config.h265_tier = 1;
    params->h265_enc_config.main_still_picture_profile_enable = 0;

    params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    ret = hb_mm_mc_get_rate_control_config(context, &params->rc_params);
    ASSERT_EQ(ret, (int32_t)0);
    params->rc_params.h265_cbr_params.intra_period = 20;
    params->rc_params.h265_cbr_params.intra_qp = 8;
    params->rc_params.h265_cbr_params.bit_rate = 200;
    params->rc_params.h265_cbr_params.frame_rate = 15;
    params->rc_params.h265_cbr_params.initial_rc_qp = 20;
    params->rc_params.h265_cbr_params.vbv_buffer_size = 20;
    params->rc_params.h265_cbr_params.ctu_level_rc_enalbe = 1;
    params->rc_params.h265_cbr_params.min_qp_I = 8;
    params->rc_params.h265_cbr_params.max_qp_I = 30;
    params->rc_params.h265_cbr_params.min_qp_P = 8;
    params->rc_params.h265_cbr_params.max_qp_P = 30;
    params->rc_params.h265_cbr_params.min_qp_B = 8;
    params->rc_params.h265_cbr_params.max_qp_B = 30;
    params->rc_params.h265_cbr_params.hvs_qp_enable = 1;
    params->rc_params.h265_cbr_params.hvs_qp_scale = 2;
    params->rc_params.h265_cbr_params.max_delta_qp = 10;
    params->rc_params.h265_cbr_params.qp_map_enable = 0;
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h265_lossless) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "losssless";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;
    params->h265_enc_config.transform_skip_enabled_flag = 1;
    params->h265_enc_config.lossless_mode = 1;
    params->h265_enc_config.tmvp_enable =1;

    params->rc_params.mode = MC_AV_RC_MODE_H265VBR;
    ret = hb_mm_mc_get_rate_control_config(context, &params->rc_params);
    ASSERT_EQ(ret, (int32_t)0);
    params->rc_params.h265_vbr_params.intra_period = 20;
    params->rc_params.h265_vbr_params.frame_rate = 15;
    params->rc_params.h265_vbr_params.intra_qp = 20;
    params->rc_params.h265_vbr_params.qp_map_enable = 0;
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;

    mc_h265_sao_params_t *sao = &ctx.sao;
    ret = hb_mm_mc_get_sao_config(context, sao);
    sao->sample_adaptive_offset_enabled_flag = 0;

    mc_video_deblk_filter_params_t *deblk_filter = &ctx.deblk_filter;
    ret = hb_mm_mc_get_deblk_filter_config(context, deblk_filter);
    deblk_filter->h265_deblk.slice_deblocking_filter_disabled_flag = 1;
    ctx.message = (ENC_CONFIG_MESSAGE)(ENC_CONFIG_SAO | ENC_CONFIG_DEBLK_FILTER);

    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h265_trans_skip) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "tran_skip";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;
    params->h265_enc_config.transform_skip_enabled_flag = 1;

    params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    ret = hb_mm_mc_get_rate_control_config(context, &params->rc_params);
    ASSERT_EQ(ret, (int32_t)0);
    params->rc_params.h265_cbr_params.intra_period = 20;
    params->rc_params.h265_cbr_params.intra_qp = 8;
    params->rc_params.h265_cbr_params.bit_rate = 200;
    params->rc_params.h265_cbr_params.frame_rate = 15;
    params->rc_params.h265_cbr_params.initial_rc_qp = 20;
    params->rc_params.h265_cbr_params.vbv_buffer_size = 20;
    params->rc_params.h265_cbr_params.ctu_level_rc_enalbe = 1;
    params->rc_params.h265_cbr_params.min_qp_I = 8;
    params->rc_params.h265_cbr_params.max_qp_I = 30;
    params->rc_params.h265_cbr_params.min_qp_P = 8;
    params->rc_params.h265_cbr_params.max_qp_P = 30;
    params->rc_params.h265_cbr_params.min_qp_B = 8;
    params->rc_params.h265_cbr_params.max_qp_B = 30;
    params->rc_params.h265_cbr_params.hvs_qp_enable = 1;
    params->rc_params.h265_cbr_params.hvs_qp_scale = 2;
    params->rc_params.h265_cbr_params.max_delta_qp = 10;
    params->rc_params.h265_cbr_params.qp_map_enable = 0;
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h265_tmvp) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "tmvp";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;
    params->h265_enc_config.tmvp_enable = 1;

    params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    ret = hb_mm_mc_get_rate_control_config(context, &params->rc_params);
    ASSERT_EQ(ret, (int32_t)0);
    params->rc_params.h265_cbr_params.intra_period = 20;
    params->rc_params.h265_cbr_params.intra_qp = 8;
    params->rc_params.h265_cbr_params.bit_rate = 200;
    params->rc_params.h265_cbr_params.frame_rate = 15;
    params->rc_params.h265_cbr_params.initial_rc_qp = 20;
    params->rc_params.h265_cbr_params.vbv_buffer_size = 20;
    params->rc_params.h265_cbr_params.ctu_level_rc_enalbe = 1;
    params->rc_params.h265_cbr_params.min_qp_I = 8;
    params->rc_params.h265_cbr_params.max_qp_I = 30;
    params->rc_params.h265_cbr_params.min_qp_P = 8;
    params->rc_params.h265_cbr_params.max_qp_P = 30;
    params->rc_params.h265_cbr_params.min_qp_B = 8;
    params->rc_params.h265_cbr_params.max_qp_B = 30;
    params->rc_params.h265_cbr_params.hvs_qp_enable = 1;
    params->rc_params.h265_cbr_params.hvs_qp_scale = 2;
    params->rc_params.h265_cbr_params.max_delta_qp = 10;
    params->rc_params.h265_cbr_params.qp_map_enable = 0;
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h265_wpp) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "wpp";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;
    params->h265_enc_config.wpp_enable = 1;

    params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    ret = hb_mm_mc_get_rate_control_config(context, &params->rc_params);
    ASSERT_EQ(ret, (int32_t)0);
    params->rc_params.h265_cbr_params.intra_period = 20;
    params->rc_params.h265_cbr_params.intra_qp = 8;
    params->rc_params.h265_cbr_params.bit_rate = 200;
    params->rc_params.h265_cbr_params.frame_rate = 15;
    params->rc_params.h265_cbr_params.initial_rc_qp = 20;
    params->rc_params.h265_cbr_params.vbv_buffer_size = 20;
    params->rc_params.h265_cbr_params.ctu_level_rc_enalbe = 1;
    params->rc_params.h265_cbr_params.min_qp_I = 8;
    params->rc_params.h265_cbr_params.max_qp_I = 30;
    params->rc_params.h265_cbr_params.min_qp_P = 8;
    params->rc_params.h265_cbr_params.max_qp_P = 30;
    params->rc_params.h265_cbr_params.min_qp_B = 8;
    params->rc_params.h265_cbr_params.max_qp_B = 30;
    params->rc_params.h265_cbr_params.hvs_qp_enable = 1;
    params->rc_params.h265_cbr_params.hvs_qp_scale = 2;
    params->rc_params.h265_cbr_params.max_delta_qp = 10;
    params->rc_params.h265_cbr_params.qp_map_enable = 0;
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h265_wpp_off) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "wppOff";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;
    params->h265_enc_config.wpp_enable = 0;

    params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    ret = hb_mm_mc_get_rate_control_config(context, &params->rc_params);
    ASSERT_EQ(ret, (int32_t)0);
    params->rc_params.h265_cbr_params.intra_period = 20;
    params->rc_params.h265_cbr_params.intra_qp = 8;
    params->rc_params.h265_cbr_params.bit_rate = 200;
    params->rc_params.h265_cbr_params.frame_rate = 15;
    params->rc_params.h265_cbr_params.initial_rc_qp = 20;
    params->rc_params.h265_cbr_params.vbv_buffer_size = 20;
    params->rc_params.h265_cbr_params.ctu_level_rc_enalbe = 1;
    params->rc_params.h265_cbr_params.min_qp_I = 8;
    params->rc_params.h265_cbr_params.max_qp_I = 30;
    params->rc_params.h265_cbr_params.min_qp_P = 8;
    params->rc_params.h265_cbr_params.max_qp_P = 30;
    params->rc_params.h265_cbr_params.min_qp_B = 8;
    params->rc_params.h265_cbr_params.max_qp_B = 30;
    params->rc_params.h265_cbr_params.hvs_qp_enable = 1;
    params->rc_params.h265_cbr_params.hvs_qp_scale = 2;
    params->rc_params.h265_cbr_params.max_delta_qp = 10;
    params->rc_params.h265_cbr_params.qp_map_enable = 0;
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h265_gop_ref_0) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "refresh0";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;
    params->h265_enc_config.wpp_enable = 1;

    params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    ret = hb_mm_mc_get_rate_control_config(context, &params->rc_params);
    ASSERT_EQ(ret, (int32_t)0);
    params->rc_params.h265_cbr_params.intra_period = 20;
    params->rc_params.h265_cbr_params.intra_qp = 8;
    params->rc_params.h265_cbr_params.bit_rate = 200;
    params->rc_params.h265_cbr_params.frame_rate = 15;
    params->rc_params.h265_cbr_params.initial_rc_qp = 20;
    params->rc_params.h265_cbr_params.vbv_buffer_size = 20;
    params->rc_params.h265_cbr_params.ctu_level_rc_enalbe = 1;
    params->rc_params.h265_cbr_params.min_qp_I = 8;
    params->rc_params.h265_cbr_params.max_qp_I = 30;
    params->rc_params.h265_cbr_params.min_qp_P = 8;
    params->rc_params.h265_cbr_params.max_qp_P = 30;
    params->rc_params.h265_cbr_params.min_qp_B = 8;
    params->rc_params.h265_cbr_params.max_qp_B = 30;
    params->rc_params.h265_cbr_params.hvs_qp_enable = 1;
    params->rc_params.h265_cbr_params.hvs_qp_scale = 2;
    params->rc_params.h265_cbr_params.max_delta_qp = 10;
    params->rc_params.h265_cbr_params.qp_map_enable = 0;
    params->gop_params.decoding_refresh_type = 0;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h265_gop_ref_1) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "refresh1";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;
    params->h265_enc_config.wpp_enable = 1;

    params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    ret = hb_mm_mc_get_rate_control_config(context, &params->rc_params);
    ASSERT_EQ(ret, (int32_t)0);
    params->rc_params.h265_cbr_params.intra_period = 20;
    params->rc_params.h265_cbr_params.intra_qp = 8;
    params->rc_params.h265_cbr_params.bit_rate = 200;
    params->rc_params.h265_cbr_params.frame_rate = 15;
    params->rc_params.h265_cbr_params.initial_rc_qp = 20;
    params->rc_params.h265_cbr_params.vbv_buffer_size = 20;
    params->rc_params.h265_cbr_params.ctu_level_rc_enalbe = 1;
    params->rc_params.h265_cbr_params.min_qp_I = 8;
    params->rc_params.h265_cbr_params.max_qp_I = 30;
    params->rc_params.h265_cbr_params.min_qp_P = 8;
    params->rc_params.h265_cbr_params.max_qp_P = 30;
    params->rc_params.h265_cbr_params.min_qp_B = 8;
    params->rc_params.h265_cbr_params.max_qp_B = 30;
    params->rc_params.h265_cbr_params.hvs_qp_enable = 1;
    params->rc_params.h265_cbr_params.hvs_qp_scale = 2;
    params->rc_params.h265_cbr_params.max_delta_qp = 10;
    params->rc_params.h265_cbr_params.qp_map_enable = 0;
    params->gop_params.decoding_refresh_type = 1;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h265_gop_ref_2) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "refresh2";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;
    params->h265_enc_config.wpp_enable = 1;

    params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    ret = hb_mm_mc_get_rate_control_config(context, &params->rc_params);
    ASSERT_EQ(ret, (int32_t)0);
    params->rc_params.h265_cbr_params.intra_period = 20;
    params->rc_params.h265_cbr_params.intra_qp = 8;
    params->rc_params.h265_cbr_params.bit_rate = 200;
    params->rc_params.h265_cbr_params.frame_rate = 15;
    params->rc_params.h265_cbr_params.initial_rc_qp = 20;
    params->rc_params.h265_cbr_params.vbv_buffer_size = 20;
    params->rc_params.h265_cbr_params.ctu_level_rc_enalbe = 1;
    params->rc_params.h265_cbr_params.min_qp_I = 8;
    params->rc_params.h265_cbr_params.max_qp_I = 30;
    params->rc_params.h265_cbr_params.min_qp_P = 8;
    params->rc_params.h265_cbr_params.max_qp_P = 30;
    params->rc_params.h265_cbr_params.min_qp_B = 8;
    params->rc_params.h265_cbr_params.max_qp_B = 30;
    params->rc_params.h265_cbr_params.hvs_qp_enable = 1;
    params->rc_params.h265_cbr_params.hvs_qp_scale = 2;
    params->rc_params.h265_cbr_params.max_delta_qp = 10;
    params->rc_params.h265_cbr_params.qp_map_enable = 0;
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_gop_preset_1) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "gopP1";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264VBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265VBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 1;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_gop_preset_2) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "gopP2";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264VBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265VBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_gop_preset_3) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "gopP3";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264VBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265VBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 3;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_gop_preset_4) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "gopP4";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264VBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265VBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 4;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_gop_preset_5) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "gopP5";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264VBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265VBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 5;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_gop_preset_6) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "gopP6";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264VBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265VBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 6;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_gop_preset_7) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "gopP7";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264VBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265VBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 7;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_gop_preset_8) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "gopP8";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264VBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265VBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 8;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_gop_preset_9) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "gopP8";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264VBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265VBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 9;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h264_gop_custom) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H264;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "gopCustom";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 0;
    params->gop_params.custom_gop_size = 4;
    for (int i=0; i<4; i++) {
        params->gop_params.custom_gop_pic_param[i].pic_type = 1;
        params->gop_params.custom_gop_pic_param[i].poc_offset = i+1;
        params->gop_params.custom_gop_pic_param[i].pic_qp = 25;
        params->gop_params.custom_gop_pic_param[i].num_ref_picL0 = 1;
        params->gop_params.custom_gop_pic_param[i].ref_pocL0 = i;
        params->gop_params.custom_gop_pic_param[i].ref_pocL1 = (i==0)?(-4):0;
        params->gop_params.custom_gop_pic_param[i].temporal_id = 0;
    }

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h265_gop_custom) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "gopCustom";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;
    params->h265_enc_config.wpp_enable = 1;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 1;
    params->gop_params.gop_preset_idx = 0;
    params->gop_params.custom_gop_size = 4;
    for (int i=0; i<4; i++) {
        params->gop_params.custom_gop_pic_param[i].pic_type = 1;
        params->gop_params.custom_gop_pic_param[i].poc_offset = i+1;
        params->gop_params.custom_gop_pic_param[i].pic_qp = 25;
#ifdef J5
        params->gop_params.custom_gop_pic_param[i].num_ref_picL0 = 0;
#else
        params->gop_params.custom_gop_pic_param[i].num_ref_picL0 = 1;
#endif
        params->gop_params.custom_gop_pic_param[i].ref_pocL0 = i;
#ifdef J5
        params->gop_params.custom_gop_pic_param[i].ref_pocL1 = 0;
#else
        params->gop_params.custom_gop_pic_param[i].ref_pocL1 = (i==0)?(-4):0;
#endif
        params->gop_params.custom_gop_pic_param[i].temporal_id = 0;
    }

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h265_gop_custom_1) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "gopCustom1";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;
    params->h265_enc_config.wpp_enable = 1;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 1;
    params->gop_params.gop_preset_idx = 0;
    params->gop_params.custom_gop_size = 4;
    for (int i=0; i<4; i++) {
        params->gop_params.custom_gop_pic_param[i].pic_type = 1;
        params->gop_params.custom_gop_pic_param[i].poc_offset = i+1;
        params->gop_params.custom_gop_pic_param[i].pic_qp = 25;
        params->gop_params.custom_gop_pic_param[i].num_ref_picL0 = 0;
        params->gop_params.custom_gop_pic_param[i].ref_pocL0 = (i==0)?(-4):0;
        params->gop_params.custom_gop_pic_param[i].ref_pocL1 = 0;
        params->gop_params.custom_gop_pic_param[i].temporal_id = 0;
    }

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h265_gop_custom_2) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "gopCustom2";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;
    params->h265_enc_config.wpp_enable = 1;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->rc_params.h265_cbr_params.intra_period = 26;
    params->gop_params.decoding_refresh_type = 1;
    params->gop_params.gop_preset_idx = 0;
    params->gop_params.custom_gop_size = 4;
    for (int i=0; i<4; i++) {
        params->gop_params.custom_gop_pic_param[i].pic_type = 1;
        params->gop_params.custom_gop_pic_param[i].poc_offset = i+1;
        params->gop_params.custom_gop_pic_param[i].pic_qp = 25;
        params->gop_params.custom_gop_pic_param[i].num_ref_picL0 = 0;
        params->gop_params.custom_gop_pic_param[i].ref_pocL0 = (i==0)?(-4):0;
        params->gop_params.custom_gop_pic_param[i].ref_pocL1 = 0;
        params->gop_params.custom_gop_pic_param[i].temporal_id = 0;
    }

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h265_gop_custom_3) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "gopCustom3";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->rc_params.h265_cbr_params.intra_period = 20;
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 0;

    // I-P3-P2-P3-P1-P3-P2-P3-P0 -- P3-P2-P3-P1-P3-P2-P3-P0
    params->gop_params.custom_gop_size = 8;
    params->gop_params.custom_gop_pic_param[0].pic_type = 1;
    params->gop_params.custom_gop_pic_param[0].poc_offset = 1;
    params->gop_params.custom_gop_pic_param[0].pic_qp = 27;//7;
    params->gop_params.custom_gop_pic_param[0].num_ref_picL0 = 0;
    params->gop_params.custom_gop_pic_param[0].ref_pocL0 = 0;
    params->gop_params.custom_gop_pic_param[0].ref_pocL1 = 0;
    params->gop_params.custom_gop_pic_param[0].temporal_id = 3;

    params->gop_params.custom_gop_pic_param[1].pic_type = 1;
    params->gop_params.custom_gop_pic_param[1].poc_offset = 2;
    params->gop_params.custom_gop_pic_param[1].pic_qp = 25;//5;
    params->gop_params.custom_gop_pic_param[1].num_ref_picL0 = 0;
    params->gop_params.custom_gop_pic_param[1].ref_pocL0 = 0;
    params->gop_params.custom_gop_pic_param[1].ref_pocL1 = 0;
    params->gop_params.custom_gop_pic_param[1].temporal_id = 2;

    params->gop_params.custom_gop_pic_param[2].pic_type = 1;
    params->gop_params.custom_gop_pic_param[2].poc_offset = 3;
    params->gop_params.custom_gop_pic_param[2].pic_qp = 27;//7;
    params->gop_params.custom_gop_pic_param[2].num_ref_picL0 = 0;
    params->gop_params.custom_gop_pic_param[2].ref_pocL0 = 2;
    params->gop_params.custom_gop_pic_param[2].ref_pocL1 = 0;
    params->gop_params.custom_gop_pic_param[2].temporal_id = 3;

    params->gop_params.custom_gop_pic_param[3].pic_type = 1;
    params->gop_params.custom_gop_pic_param[3].poc_offset = 4;
    params->gop_params.custom_gop_pic_param[3].pic_qp = 23;//3;
    params->gop_params.custom_gop_pic_param[3].num_ref_picL0 = 0;
    params->gop_params.custom_gop_pic_param[3].ref_pocL0 = 0;
    params->gop_params.custom_gop_pic_param[3].ref_pocL1 = 0;
    params->gop_params.custom_gop_pic_param[3].temporal_id = 1;

    params->gop_params.custom_gop_pic_param[4].pic_type = 1;
    params->gop_params.custom_gop_pic_param[4].poc_offset = 5;
    params->gop_params.custom_gop_pic_param[4].pic_qp = 27;//7;
    params->gop_params.custom_gop_pic_param[4].num_ref_picL0 = 0;
    params->gop_params.custom_gop_pic_param[4].ref_pocL0 = 4;
    params->gop_params.custom_gop_pic_param[4].ref_pocL1 = 0;
    params->gop_params.custom_gop_pic_param[4].temporal_id = 3;

    params->gop_params.custom_gop_pic_param[5].pic_type = 1;
    params->gop_params.custom_gop_pic_param[5].poc_offset = 6;
    params->gop_params.custom_gop_pic_param[5].pic_qp = 25;//5;
    params->gop_params.custom_gop_pic_param[5].num_ref_picL0 = 0;
    params->gop_params.custom_gop_pic_param[5].ref_pocL0 = 4;
    params->gop_params.custom_gop_pic_param[5].ref_pocL1 = 0;
    params->gop_params.custom_gop_pic_param[5].temporal_id = 2;

    params->gop_params.custom_gop_pic_param[6].pic_type = 1;
    params->gop_params.custom_gop_pic_param[6].poc_offset = 7;
    params->gop_params.custom_gop_pic_param[6].pic_qp = 27;//7;
    params->gop_params.custom_gop_pic_param[6].num_ref_picL0 = 0;
    params->gop_params.custom_gop_pic_param[6].ref_pocL0 = 6;
    params->gop_params.custom_gop_pic_param[6].ref_pocL1 = 0;
    params->gop_params.custom_gop_pic_param[6].temporal_id = 3;

    params->gop_params.custom_gop_pic_param[7].pic_type = 1;
    params->gop_params.custom_gop_pic_param[7].poc_offset = 8;
    params->gop_params.custom_gop_pic_param[7].pic_qp = 21;//1;
    params->gop_params.custom_gop_pic_param[7].num_ref_picL0 = 0;
    params->gop_params.custom_gop_pic_param[7].ref_pocL0 = 0;
    params->gop_params.custom_gop_pic_param[7].ref_pocL1 = 0;
    params->gop_params.custom_gop_pic_param[7].temporal_id = 0;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h264_longterm_ref) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H264;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "longRef";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    mc_video_longterm_ref_mode_t *ref_mode = &ctx.ref_mode;
    ret = hb_mm_mc_get_longterm_ref_mode(context, ref_mode);
    ASSERT_EQ(ret, (int32_t)0);
    ref_mode->use_longterm = 1;
    ref_mode->longterm_pic_period = 10;
    ref_mode->longterm_pic_using_period = 5;
    ctx.message = ENC_CONFIG_LONGTERM_REF;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h265_longterm_ref) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "longRef";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;
    params->h265_enc_config.wpp_enable = 1;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 1;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    mc_video_longterm_ref_mode_t *ref_mode = &ctx.ref_mode;
    ret = hb_mm_mc_get_longterm_ref_mode(context, ref_mode);
    ASSERT_EQ(ret, (int32_t)0);
    ref_mode->use_longterm = 1;
    ref_mode->longterm_pic_period = 8;
    ref_mode->longterm_pic_using_period = 4;
    ctx.message = ENC_CONFIG_LONGTERM_REF;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_longterm_ref_dynamic) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "dynamic_longRef";
    char inputSuffix[MAX_FILE_PATH] = "_long.yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;
    params->h265_enc_config.wpp_enable = 1;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 1;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    mc_video_longterm_ref_mode_t *ref_mode = &ctx.ref_mode;
    ret = hb_mm_mc_get_longterm_ref_mode(context, ref_mode);
    ASSERT_EQ(ret, (int32_t)0);
    ref_mode->use_longterm = 1;
    ref_mode->longterm_pic_period = 8;
    ref_mode->longterm_pic_using_period = 4;
    ctx.message = ENC_CONFIG_LONGTERM_REF;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    ctx.dynamicTest = 1;
    ctx.dynamicMessage = ENC_CONFIG_LONGTERM_REF;
    ctx.ref_mode_dynamic = *ref_mode;
    ctx.ref_mode_dynamic.longterm_pic_period = 12;
    ctx.ref_mode_dynamic.longterm_pic_using_period = 5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h264_intra_refresh_1) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H264;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "intraRef1";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    mc_video_intra_refresh_params_t *intra_refr = &ctx.intra_refr;
    ret = hb_mm_mc_get_intra_refresh_config(context, intra_refr);
    ASSERT_EQ(ret, (int32_t)0);
    intra_refr->intra_refresh_mode = 1;
    intra_refr->intra_refresh_arg = 15;
    ctx.message = ENC_CONFIG_INTRA_REFRESH;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h264_intra_refresh_2) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H264;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "intraRef2";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    mc_video_intra_refresh_params_t *intra_refr = &ctx.intra_refr;
    ret = hb_mm_mc_get_intra_refresh_config(context, intra_refr);
    ASSERT_EQ(ret, (int32_t)0);
    intra_refr->intra_refresh_mode = 2;
    intra_refr->intra_refresh_arg = 2;
    ctx.message = ENC_CONFIG_INTRA_REFRESH;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h264_intra_refresh_3) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H264;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "intraRef3";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    mc_video_intra_refresh_params_t *intra_refr = &ctx.intra_refr;
    ret = hb_mm_mc_get_intra_refresh_config(context, intra_refr);
    ASSERT_EQ(ret, (int32_t)0);
    intra_refr->intra_refresh_mode = 3;
    intra_refr->intra_refresh_arg = 2;
    ctx.message = ENC_CONFIG_INTRA_REFRESH;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h265_intra_refresh_1) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "intraRef1";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;
    params->h265_enc_config.wpp_enable = 1;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 1;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    mc_video_intra_refresh_params_t *intra_refr = &ctx.intra_refr;
    ret = hb_mm_mc_get_intra_refresh_config(context, intra_refr);
    ASSERT_EQ(ret, (int32_t)0);
    intra_refr->intra_refresh_mode = 1;
    intra_refr->intra_refresh_arg = 2;
    ctx.message = ENC_CONFIG_INTRA_REFRESH;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h265_intra_refresh_2) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "intraRef2";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;
    params->h265_enc_config.wpp_enable = 1;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 1;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    mc_video_intra_refresh_params_t *intra_refr = &ctx.intra_refr;
    ret = hb_mm_mc_get_intra_refresh_config(context, intra_refr);
    ASSERT_EQ(ret, (int32_t)0);
    intra_refr->intra_refresh_mode = 2;
    intra_refr->intra_refresh_arg = 2;
    ctx.message = ENC_CONFIG_INTRA_REFRESH;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h265_intra_refresh_3) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "intraRef3";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;
    params->h265_enc_config.wpp_enable = 1;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 1;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    mc_video_intra_refresh_params_t *intra_refr = &ctx.intra_refr;
    ret = hb_mm_mc_get_intra_refresh_config(context, intra_refr);
    ASSERT_EQ(ret, (int32_t)0);
    intra_refr->intra_refresh_mode = 3;
    intra_refr->intra_refresh_arg = 35;
    ctx.message = ENC_CONFIG_INTRA_REFRESH;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h265_intra_refresh_4) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "intraRef4";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;
    params->h265_enc_config.wpp_enable = 1;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 1;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    mc_video_intra_refresh_params_t *intra_refr = &ctx.intra_refr;
    ret = hb_mm_mc_get_intra_refresh_config(context, intra_refr);
    ASSERT_EQ(ret, (int32_t)0);
#ifdef J5
    intra_refr->intra_refresh_mode = 3;
    intra_refr->intra_refresh_arg = 35;
#else
    intra_refr->intra_refresh_mode = 4;
    intra_refr->intra_refresh_arg = 25;
#endif
    ctx.message = ENC_CONFIG_INTRA_REFRESH;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h264_deblk_filter) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H264;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "deblkFilter";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    mc_video_deblk_filter_params_t *deblk_filter = &ctx.deblk_filter;
    ret = hb_mm_mc_get_deblk_filter_config(context, deblk_filter);
    ASSERT_EQ(ret, (int32_t)0);
    deblk_filter->h264_deblk.disable_deblocking_filter_idc = 0;
    deblk_filter->h264_deblk.slice_alpha_c0_offset_div2 = 6;
    deblk_filter->h264_deblk.slice_beta_offset_div2 = 6;
    ctx.message = ENC_CONFIG_DEBLK_FILTER;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h264_deblk_filter_1) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H264;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "deblkFilter1";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    mc_video_deblk_filter_params_t *deblk_filter = &ctx.deblk_filter;
    ret = hb_mm_mc_get_deblk_filter_config(context, deblk_filter);
    ASSERT_EQ(ret, (int32_t)0);
    deblk_filter->h264_deblk.disable_deblocking_filter_idc = 1;
    deblk_filter->h264_deblk.slice_alpha_c0_offset_div2 = 0;
    deblk_filter->h264_deblk.slice_beta_offset_div2 = 0;
    ctx.message = ENC_CONFIG_DEBLK_FILTER;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h264_deblk_filter_2) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H264;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "deblkFilter2";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    mc_video_deblk_filter_params_t *deblk_filter = &ctx.deblk_filter;
    ret = hb_mm_mc_get_deblk_filter_config(context, deblk_filter);
    ASSERT_EQ(ret, (int32_t)0);
    deblk_filter->h264_deblk.disable_deblocking_filter_idc = 2;
    deblk_filter->h264_deblk.slice_alpha_c0_offset_div2 = 6;
    deblk_filter->h264_deblk.slice_beta_offset_div2 = 6;
    ctx.message = ENC_CONFIG_DEBLK_FILTER;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h265_deblk_filter) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "deblkFilter";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;
    params->h265_enc_config.wpp_enable = 1;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 1;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    mc_video_deblk_filter_params_t *deblk_filter = &ctx.deblk_filter;
    ret = hb_mm_mc_get_deblk_filter_config(context, deblk_filter);
    ASSERT_EQ(ret, (int32_t)0);
    deblk_filter->h265_deblk.slice_deblocking_filter_disabled_flag = 0;
    deblk_filter->h265_deblk.slice_tc_offset_div2 = 5;
    deblk_filter->h265_deblk.slice_beta_offset_div2 = 5;
    deblk_filter->h265_deblk.slice_loop_filter_across_slices_enabled_flag = 1;
    ctx.message = ENC_CONFIG_DEBLK_FILTER;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h265_deblk_filter_1) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "deblkFilter1";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;
    params->h265_enc_config.wpp_enable = 1;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 1;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    mc_video_deblk_filter_params_t *deblk_filter = &ctx.deblk_filter;
    ret = hb_mm_mc_get_deblk_filter_config(context, deblk_filter);
    ASSERT_EQ(ret, (int32_t)0);
    deblk_filter->h265_deblk.slice_deblocking_filter_disabled_flag = 1;
    deblk_filter->h265_deblk.slice_tc_offset_div2 = 5;
    deblk_filter->h265_deblk.slice_beta_offset_div2 = 5;
    deblk_filter->h265_deblk.slice_loop_filter_across_slices_enabled_flag = 1;
    ctx.message = ENC_CONFIG_DEBLK_FILTER;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h265_deblk_filter_2) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "deblkFilter2";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;
    params->h265_enc_config.wpp_enable = 1;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 1;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    mc_video_deblk_filter_params_t *deblk_filter = &ctx.deblk_filter;
    ret = hb_mm_mc_get_deblk_filter_config(context, deblk_filter);
    ASSERT_EQ(ret, (int32_t)0);
    deblk_filter->h265_deblk.slice_deblocking_filter_disabled_flag = 1;
    deblk_filter->h265_deblk.slice_tc_offset_div2 = 5;
    deblk_filter->h265_deblk.slice_beta_offset_div2 = 5;
    deblk_filter->h265_deblk.slice_loop_filter_across_slices_enabled_flag = 0;
    ctx.message = ENC_CONFIG_DEBLK_FILTER;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_deblk_filter_dynamic) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "dynamic_deblkFilter";
    char inputSuffix[MAX_FILE_PATH] = "_long.yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;
    params->h265_enc_config.wpp_enable = 1;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 1;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    mc_video_deblk_filter_params_t *deblk_filter = &ctx.deblk_filter;
    ret = hb_mm_mc_get_deblk_filter_config(context, deblk_filter);
    ASSERT_EQ(ret, (int32_t)0);
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        deblk_filter->h264_deblk.disable_deblocking_filter_idc = 2;
        deblk_filter->h264_deblk.slice_alpha_c0_offset_div2 = 6;
        deblk_filter->h264_deblk.slice_beta_offset_div2 = 6;
    } else {
        deblk_filter->h265_deblk.slice_deblocking_filter_disabled_flag = 0;
        deblk_filter->h265_deblk.slice_tc_offset_div2 = 5;
        deblk_filter->h265_deblk.slice_beta_offset_div2 = 5;
        deblk_filter->h265_deblk.slice_loop_filter_across_slices_enabled_flag = 1;
    }
    ctx.message = ENC_CONFIG_DEBLK_FILTER;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    ctx.dynamicTest = 1;
    ctx.dynamicMessage = ENC_CONFIG_DEBLK_FILTER;
    ctx.deblk_filter_dynamic = *deblk_filter;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        ctx.deblk_filter_dynamic.h264_deblk.disable_deblocking_filter_idc = 1;
        ctx.deblk_filter_dynamic.h264_deblk.slice_alpha_c0_offset_div2 = 5;
        ctx.deblk_filter_dynamic.h264_deblk.slice_beta_offset_div2 = 5;
    } else {
        ctx.deblk_filter_dynamic.h265_deblk.slice_deblocking_filter_disabled_flag = 0;
        ctx.deblk_filter_dynamic.h265_deblk.slice_tc_offset_div2 = 3;
        ctx.deblk_filter_dynamic.h265_deblk.slice_beta_offset_div2 = 2;
        ctx.deblk_filter_dynamic.h265_deblk.slice_loop_filter_across_slices_enabled_flag = 1;
    }
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}


TEST_F(MediaCodecTest, test_encoding_effect_case_h265_sao) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "sao";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;
    params->h265_enc_config.wpp_enable = 1;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 1;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    mc_h265_sao_params_t *sao = &ctx.sao;
    ret = hb_mm_mc_get_sao_config(context, sao);
    ASSERT_EQ(ret, (int32_t)0);
    sao->sample_adaptive_offset_enabled_flag = 1;
    ctx.message = ENC_CONFIG_SAO;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h264_entropy) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H264;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "entropy";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    mc_h264_entropy_params_t *entropy = &ctx.entropy;
    ret = hb_mm_mc_get_entropy_config(context, entropy);
    ASSERT_EQ(ret, (int32_t)0);
    entropy->entropy_coding_mode = 0;
    ctx.message = ENC_CONFIG_ENTROPY;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h264_vui) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H264;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "vui";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    mc_video_vui_params_t *vui = &ctx.vui;
    ret = hb_mm_mc_get_vui_config(context, vui);
    ASSERT_EQ(ret, (int32_t)0);
    vui->h264_vui.aspect_ratio_info_present_flag = 1;
    vui->h264_vui.aspect_ratio_idc = 255;
    vui->h264_vui.sar_height = 2;
    vui->h264_vui.sar_width = 3;
    vui->h264_vui.overscan_info_present_flag = 1;
    vui->h264_vui.overscan_appropriate_flag = 1;
    vui->h264_vui.video_signal_type_present_flag = 1;
    vui->h264_vui.video_format = 0;
    vui->h264_vui.video_full_range_flag = 1;
    vui->h264_vui.colour_description_present_flag = 1;
    vui->h264_vui.colour_primaries = 255;
    vui->h264_vui.transfer_characteristics = 255;
    vui->h264_vui.matrix_coefficients = 255;
    vui->h264_vui.vui_timing_info_present_flag = 1;
    vui->h264_vui.vui_num_units_in_tick = 1000;
    vui->h264_vui.vui_time_scale =
        params->rc_params.h264_cbr_params.frame_rate *
        vui->h264_vui.vui_num_units_in_tick;
    vui->h264_vui.vui_fixed_frame_rate_flag = 1;
    vui->h264_vui.bitstream_restriction_flag = 1;
    ctx.message = ENC_CONFIG_VUI;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h265_vui) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "vui";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;
    params->h265_enc_config.wpp_enable = 1;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 1;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    mc_video_vui_params_t *vui = &ctx.vui;
    ret = hb_mm_mc_get_vui_config(context, vui);
    ASSERT_EQ(ret, (int32_t)0);
    vui->h265_vui.aspect_ratio_info_present_flag = 1;
    vui->h265_vui.aspect_ratio_idc = 1;
    vui->h265_vui.sar_height = 2;
    vui->h265_vui.sar_width = 3;
    vui->h265_vui.overscan_info_present_flag = 1;
    vui->h265_vui.overscan_appropriate_flag = 1;
    vui->h265_vui.video_signal_type_present_flag = 1;
    vui->h265_vui.video_format = 1;
    vui->h265_vui.video_full_range_flag = 1;
    vui->h265_vui.colour_description_present_flag = 1;
    vui->h265_vui.colour_primaries = 30;
    vui->h265_vui.transfer_characteristics = 30;
    vui->h265_vui.matrix_coefficients = 30;
    vui->h265_vui.vui_timing_info_present_flag = 0;
    vui->h265_vui.vui_num_units_in_tick = 1000;
    vui->h265_vui.vui_time_scale =
        params->rc_params.h265_cbr_params.frame_rate *
        vui->h265_vui.vui_num_units_in_tick;
    vui->h265_vui.vui_poc_proportional_to_timing_flag = 1;
    vui->h265_vui.vui_num_ticks_poc_diff_one_minus1 = 999;
    vui->h265_vui.bitstream_restriction_flag = 1;
    ctx.message = ENC_CONFIG_VUI;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h265_vui_1) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "vui1";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;
    params->h265_enc_config.wpp_enable = 1;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 1;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    mc_video_vui_params_t *vui = &ctx.vui;
    ret = hb_mm_mc_get_vui_config(context, vui);
    ASSERT_EQ(ret, (int32_t)0);
    vui->h265_vui.aspect_ratio_info_present_flag = 1;
    vui->h265_vui.aspect_ratio_idc = 255;
    vui->h265_vui.sar_height = 2;
    vui->h265_vui.sar_width = 3;
    vui->h265_vui.overscan_info_present_flag = 1;
    vui->h265_vui.overscan_appropriate_flag = 1;
    vui->h265_vui.video_signal_type_present_flag = 1;
    vui->h265_vui.video_format = 1;
    vui->h265_vui.video_full_range_flag = 1;
    vui->h265_vui.colour_description_present_flag = 1;
    vui->h265_vui.colour_primaries = 30;
    vui->h265_vui.transfer_characteristics = 30;
    vui->h265_vui.matrix_coefficients = 30;
    vui->h265_vui.vui_timing_info_present_flag = 1;
    vui->h265_vui.vui_num_units_in_tick = 1000;
    vui->h265_vui.vui_time_scale =
        params->rc_params.h265_cbr_params.frame_rate *
        vui->h265_vui.vui_num_units_in_tick;
    vui->h265_vui.vui_poc_proportional_to_timing_flag = 1;
    vui->h265_vui.vui_num_ticks_poc_diff_one_minus1 = 999;
    vui->h265_vui.bitstream_restriction_flag = 1;
    ctx.message = ENC_CONFIG_VUI;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h265_vui_dynamic) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "dynamic_vui";
    char inputSuffix[MAX_FILE_PATH] = "_long.yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;
    params->h265_enc_config.wpp_enable = 1;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 1;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    mc_video_vui_params_t *vui = &ctx.vui;
    ret = hb_mm_mc_get_vui_config(context, vui);
    ASSERT_EQ(ret, (int32_t)0);
    vui->h265_vui.aspect_ratio_info_present_flag = 1;
    vui->h265_vui.aspect_ratio_idc = 1;
    vui->h265_vui.sar_height = 2;
    vui->h265_vui.sar_width = 3;
    vui->h265_vui.overscan_info_present_flag = 1;
    vui->h265_vui.overscan_appropriate_flag = 1;
    vui->h265_vui.video_signal_type_present_flag = 1;
    vui->h265_vui.video_format = 1;
    vui->h265_vui.video_full_range_flag = 1;
    vui->h265_vui.colour_description_present_flag = 1;
    vui->h265_vui.colour_primaries = 30;
    vui->h265_vui.transfer_characteristics = 30;
    vui->h265_vui.matrix_coefficients = 30;
    vui->h265_vui.vui_timing_info_present_flag = 0;
    vui->h265_vui.vui_num_units_in_tick = 1000;
    vui->h265_vui.vui_time_scale =
        params->rc_params.h265_cbr_params.frame_rate *
        vui->h265_vui.vui_num_units_in_tick;
    vui->h265_vui.vui_poc_proportional_to_timing_flag = 1;
    vui->h265_vui.vui_num_ticks_poc_diff_one_minus1 = 999;
    vui->h265_vui.bitstream_restriction_flag = 1;
    ctx.message = ENC_CONFIG_VUI;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    ctx.dynamicTest = 1;
    ctx.dynamicMessage = ENC_CONFIG_VUI;
    ctx.vui_dynamic = *vui;
    ctx.vui_dynamic.h265_vui.vui_num_units_in_tick = 2000;
    ctx.vui_dynamic.h265_vui.vui_time_scale =
        params->rc_params.h265_cbr_params.frame_rate *
        vui->h265_vui.vui_num_units_in_tick;

    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h264_vui_timing) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H264;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "vuiTiming";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    mc_video_vui_timing_params_t *vui_timing = &ctx.vui_timing;
    ret = hb_mm_mc_get_vui_timing_config(context, vui_timing);
    ASSERT_EQ(ret, (int32_t)0);
    vui_timing->h264_timing.vui_num_units_in_tick = 2000;
    vui_timing->h264_timing.vui_time_scale = 2000*20;
    ctx.message = ENC_CONFIG_VUI_TIMING;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h265_vui_timing) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "vuiTiming";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;
    params->h265_enc_config.wpp_enable = 1;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 1;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    mc_video_vui_timing_params_t *vui_timing = &ctx.vui_timing;
    ret = hb_mm_mc_get_vui_timing_config(context, vui_timing);
    ASSERT_EQ(ret, (int32_t)0);
    vui_timing->h265_timing.vui_num_units_in_tick = 3000;
    vui_timing->h265_timing.vui_time_scale = 3000*20;
    vui_timing->h265_timing.vui_num_ticks_poc_diff_one_minus1 = 20;
    ctx.message = ENC_CONFIG_VUI_TIMING;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h264_slice) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H264;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "slice";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    mc_video_slice_params_t *slice = &ctx.slice;
    ret = hb_mm_mc_get_slice_config(context, slice);
    ASSERT_EQ(ret, (int32_t)0);
    slice->h264_slice.h264_slice_mode = 1;
    slice->h264_slice.h264_slice_arg = 60;
    ctx.message = ENC_CONFIG_SLICE;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h265_slice) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "slice";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;
    params->h265_enc_config.wpp_enable = 0;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    mc_video_slice_params_t *slice = &ctx.slice;
    ret = hb_mm_mc_get_slice_config(context, slice);
    ASSERT_EQ(ret, (int32_t)0);
    slice->h265_slice.h265_dependent_slice_mode = 1;
    slice->h265_slice.h265_dependent_slice_arg = 16;
    slice->h265_slice.h265_independent_slice_mode = 1;
    slice->h265_slice.h265_independent_slice_arg = 20;
    ctx.message = ENC_CONFIG_SLICE;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h265_slice_2) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "slice2";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;
    params->h265_enc_config.wpp_enable = 0;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 1;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    mc_video_slice_params_t *slice = &ctx.slice;
    ret = hb_mm_mc_get_slice_config(context, slice);
    ASSERT_EQ(ret, (int32_t)0);
    slice->h265_slice.h265_dependent_slice_mode = 2;
    slice->h265_slice.h265_dependent_slice_arg = 80;
    slice->h265_slice.h265_independent_slice_mode = 1;
    slice->h265_slice.h265_independent_slice_arg = 100;
    ctx.message = ENC_CONFIG_SLICE;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

#ifdef J5
TEST_F(MediaCodecTest, test_encoding_effect_case_h265_slice_3) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "slice3";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;
    params->h265_enc_config.wpp_enable = 0;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    mc_video_slice_params_t *slice = &ctx.slice;
    ret = hb_mm_mc_get_slice_config(context, slice);
    ASSERT_EQ(ret, (int32_t)0);
    slice->h265_slice.h265_dependent_slice_mode = 3;
    slice->h265_slice.h265_dependent_slice_arg = 16;
    slice->h265_slice.h265_independent_slice_mode = 2;
    slice->h265_slice.h265_independent_slice_arg = 20;
    ctx.message = ENC_CONFIG_SLICE;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_poll_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h265_slice_4) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "slice4";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;
    params->h265_enc_config.wpp_enable = 0;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 1;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    mc_video_slice_params_t *slice = &ctx.slice;
    ret = hb_mm_mc_get_slice_config(context, slice);
    ASSERT_EQ(ret, (int32_t)0);
    slice->h265_slice.h265_dependent_slice_mode = 4;
    slice->h265_slice.h265_dependent_slice_arg = 80;
    slice->h265_slice.h265_independent_slice_mode = 2;
    slice->h265_slice.h265_independent_slice_arg = 100;
    ctx.message = ENC_CONFIG_SLICE;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_poll_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h265_slice_dynamic_with_int) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "dynamic_slice_with_int";
    char inputSuffix[MAX_FILE_PATH] = "_long.yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;
    params->h265_enc_config.wpp_enable = 0;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 1;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    mc_video_slice_params_t *slice = &ctx.slice;
    ret = hb_mm_mc_get_slice_config(context, slice);
    ASSERT_EQ(ret, (int32_t)0);
    slice->h265_slice.h265_dependent_slice_mode = 4;
    slice->h265_slice.h265_dependent_slice_arg = 80;
    slice->h265_slice.h265_independent_slice_mode = 2;
    slice->h265_slice.h265_independent_slice_arg = 100;
    ctx.message = ENC_CONFIG_SLICE;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    ctx.dynamicTest = 1;
    ctx.dynamicMessage = ENC_CONFIG_SLICE;
    ctx.slice_dynamic = *slice;
    ctx.slice_dynamic.h265_slice.h265_dependent_slice_mode = 4;
    ctx.slice_dynamic.h265_slice.h265_dependent_slice_arg = 60;
    ctx.slice_dynamic.h265_slice.h265_independent_slice_mode = 2;
    ctx.slice_dynamic.h265_slice.h265_independent_slice_arg = 80;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_poll_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

#endif

TEST_F(MediaCodecTest, test_encoding_effect_case_h265_slice_dynamic_without_int) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "dynamic_slice_without_int";
    char inputSuffix[MAX_FILE_PATH] = "_long.yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;
    params->h265_enc_config.wpp_enable = 0;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 1;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    mc_video_slice_params_t *slice = &ctx.slice;
    ret = hb_mm_mc_get_slice_config(context, slice);
    ASSERT_EQ(ret, (int32_t)0);
    slice->h265_slice.h265_dependent_slice_mode = 1;
    slice->h265_slice.h265_dependent_slice_arg = 16;
    slice->h265_slice.h265_independent_slice_mode = 1;
    slice->h265_slice.h265_independent_slice_arg = 20;
    ctx.message = ENC_CONFIG_SLICE;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    ctx.dynamicTest = 1;
    ctx.dynamicMessage = ENC_CONFIG_SLICE;
    ctx.slice_dynamic = *slice;
    ctx.slice_dynamic.h265_slice.h265_dependent_slice_mode = 2;
    ctx.slice_dynamic.h265_slice.h265_dependent_slice_arg = 60;
    ctx.slice_dynamic.h265_slice.h265_independent_slice_mode = 1;
    ctx.slice_dynamic.h265_slice.h265_independent_slice_arg = 80;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_poll_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h265_3dnr_off) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "3dnr_off";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = MC_PIXEL_FORMAT_YUV420P;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    mc_video_3dnr_enc_params_t *noise_rd = &ctx.noise_reduction;
    ret = hb_mm_mc_get_3dnr_enc_config(context, noise_rd);
    ASSERT_EQ(ret, (int32_t)0);
    noise_rd->nr_y_enable = 0;
    noise_rd->nr_cb_enable = 0;
    noise_rd->nr_cr_enable = 0;
    noise_rd->nr_est_enable = 0;
    ctx.message = ENC_CONFIG_3DNR;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h265_3dnr_1) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "3dnr1";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = MC_PIXEL_FORMAT_YUV420P;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    mc_video_3dnr_enc_params_t *noise_rd = &ctx.noise_reduction;
    ret = hb_mm_mc_get_3dnr_enc_config(context, noise_rd);
    ASSERT_EQ(ret, (int32_t)0);
    noise_rd->nr_y_enable = 0;
    noise_rd->nr_cb_enable = 0;
    noise_rd->nr_cr_enable = 0;
    noise_rd->nr_est_enable = 1;
    ctx.message = ENC_CONFIG_3DNR;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h265_3dnr_2) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "3dnr2";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = MC_PIXEL_FORMAT_YUV420P;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    mc_video_3dnr_enc_params_t *noise_rd = &ctx.noise_reduction;
    ret = hb_mm_mc_get_3dnr_enc_config(context, noise_rd);
    ASSERT_EQ(ret, (int32_t)0);
    noise_rd->nr_y_enable = 1;
    noise_rd->nr_cb_enable = 1;
    noise_rd->nr_cr_enable = 1;
    noise_rd->nr_est_enable = 0;
    noise_rd->nr_noise_sigmaY = 6;
    noise_rd->nr_noise_sigmaCb = 6;
    noise_rd->nr_noise_sigmaCr = 6;
    ctx.message = ENC_CONFIG_3DNR;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h264_smart_bg_off) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H264;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "smartBg0";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    mc_video_smart_bg_enc_params_t *smart_bg = &ctx.smart_bg;
    ret = hb_mm_mc_get_smart_bg_enc_config(context, smart_bg);
    ASSERT_EQ(ret, (int32_t)0);
    smart_bg->bg_detect_enable = 0;
    smart_bg->bg_threshold_diff = 8;
    smart_bg->bg_threshold_mean_diff = 1;
    smart_bg->bg_lambda_qp = 32;
    smart_bg->bg_delta_qp = 3;
    smart_bg->s2fme_disable = 0;
    ctx.message = ENC_CONFIG_SMART_BG;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h264_smart_bg_1) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H264;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "smartBg1";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    mc_video_smart_bg_enc_params_t *smart_bg = &ctx.smart_bg;
    ret = hb_mm_mc_get_smart_bg_enc_config(context, smart_bg);
    ASSERT_EQ(ret, (int32_t)0);
    smart_bg->bg_detect_enable = 1;
    smart_bg->bg_threshold_diff = 15;
    smart_bg->bg_threshold_mean_diff = 10;
    smart_bg->bg_lambda_qp = 32;
    smart_bg->bg_delta_qp = 3;
    smart_bg->s2fme_disable = 0;
    ctx.message = ENC_CONFIG_SMART_BG;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h264_smart_bg_2) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H264;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "smartBg2";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    mc_video_smart_bg_enc_params_t *smart_bg = &ctx.smart_bg;
    ret = hb_mm_mc_get_smart_bg_enc_config(context, smart_bg);
    ASSERT_EQ(ret, (int32_t)0);
    smart_bg->bg_detect_enable = 1;
    smart_bg->bg_threshold_diff = 15;
    smart_bg->bg_threshold_mean_diff = 10;
    smart_bg->bg_lambda_qp = 32;
    smart_bg->bg_delta_qp = 3;
    smart_bg->s2fme_disable = 1;
    ctx.message = ENC_CONFIG_SMART_BG;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h265_smart_bg_off) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "smartBg0";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;
    params->h265_enc_config.wpp_enable = 1;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 1;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    mc_video_smart_bg_enc_params_t *smart_bg = &ctx.smart_bg;
    ret = hb_mm_mc_get_smart_bg_enc_config(context, smart_bg);
    ASSERT_EQ(ret, (int32_t)0);
    smart_bg->bg_detect_enable = 0;
    smart_bg->bg_threshold_diff = 8;
    smart_bg->bg_threshold_mean_diff = 1;
    smart_bg->bg_lambda_qp = 32;
    smart_bg->bg_delta_qp = 3;
    smart_bg->s2fme_disable = 0;
    ctx.message = ENC_CONFIG_SMART_BG;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h265_smart_bg_1) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "smartBg1";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;
    params->h265_enc_config.wpp_enable = 1;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 1;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    mc_video_smart_bg_enc_params_t *smart_bg = &ctx.smart_bg;
    ret = hb_mm_mc_get_smart_bg_enc_config(context, smart_bg);
    ASSERT_EQ(ret, (int32_t)0);
    smart_bg->bg_detect_enable = 1;
    smart_bg->bg_threshold_diff = 8;
    smart_bg->bg_threshold_mean_diff = 1;
    smart_bg->bg_lambda_qp = 32;
    smart_bg->bg_delta_qp = 3;
    smart_bg->s2fme_disable = 0;
    ctx.message = ENC_CONFIG_SMART_BG;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h264_pred_unit) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H264;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "predUnit";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    mc_video_pred_unit_params_t *pred_unit = &ctx.pred_unit;
    ret = hb_mm_mc_get_pred_unit_config(context, pred_unit);
    ASSERT_EQ(ret, (int32_t)0);
    pred_unit->h264_intra_pred.constrained_intra_pred_flag = 1;
    ctx.message = ENC_CONFIG_PRED_UNIT;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h265_pred_unit_0) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "predUnit0";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;
    params->h265_enc_config.wpp_enable = 1;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 1;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    mc_video_pred_unit_params_t *pred_unit = &ctx.pred_unit;
    ret = hb_mm_mc_get_pred_unit_config(context, pred_unit);
    ASSERT_EQ(ret, (int32_t)0);
    pred_unit->h265_pred_unit.intra_nxn_enable = 0;
    pred_unit->h265_pred_unit.constrained_intra_pred_flag = 1;
#ifdef J5
    pred_unit->h265_pred_unit.strong_intra_smoothing_enabled_flag = 0;
#else
    pred_unit->h265_pred_unit.strong_intra_smoothing_enabled_flag = 1;
#endif
    pred_unit->h265_pred_unit.max_num_merge = 0;
    ctx.message = ENC_CONFIG_PRED_UNIT;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h265_pred_unit_1) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "predUnit1";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;
    params->h265_enc_config.wpp_enable = 1;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 1;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    mc_video_pred_unit_params_t *pred_unit = &ctx.pred_unit;
    ret = hb_mm_mc_get_pred_unit_config(context, pred_unit);
    ASSERT_EQ(ret, (int32_t)0);
    pred_unit->h265_pred_unit.intra_nxn_enable = 0;
    pred_unit->h265_pred_unit.constrained_intra_pred_flag = 0;
    pred_unit->h265_pred_unit.strong_intra_smoothing_enabled_flag = 0;
    pred_unit->h265_pred_unit.max_num_merge = 0;
    ctx.message = ENC_CONFIG_PRED_UNIT;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h265_pred_unit_2) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "predUnit2";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;
    params->h265_enc_config.wpp_enable = 1;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 1;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    mc_video_pred_unit_params_t *pred_unit = &ctx.pred_unit;
    ret = hb_mm_mc_get_pred_unit_config(context, pred_unit);
    ASSERT_EQ(ret, (int32_t)0);
    pred_unit->h265_pred_unit.intra_nxn_enable = 1;
    pred_unit->h265_pred_unit.constrained_intra_pred_flag = 0;
    pred_unit->h265_pred_unit.strong_intra_smoothing_enabled_flag = 0;
    pred_unit->h265_pred_unit.max_num_merge = 0;
    ctx.message = ENC_CONFIG_PRED_UNIT;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h265_pred_unit_3) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "predUnit3";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;
    params->h265_enc_config.wpp_enable = 1;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 1;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    mc_video_pred_unit_params_t *pred_unit = &ctx.pred_unit;
    ret = hb_mm_mc_get_pred_unit_config(context, pred_unit);
    ASSERT_EQ(ret, (int32_t)0);
    pred_unit->h265_pred_unit.intra_nxn_enable = 1;
    pred_unit->h265_pred_unit.constrained_intra_pred_flag = 0;
    pred_unit->h265_pred_unit.strong_intra_smoothing_enabled_flag = 0;
    pred_unit->h265_pred_unit.max_num_merge = 1;
    ctx.message = ENC_CONFIG_PRED_UNIT;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h265_pred_unit_4) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "predUnit4";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;
    params->h265_enc_config.wpp_enable = 1;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 1;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    mc_video_pred_unit_params_t *pred_unit = &ctx.pred_unit;
    ret = hb_mm_mc_get_pred_unit_config(context, pred_unit);
    ASSERT_EQ(ret, (int32_t)0);
    pred_unit->h265_pred_unit.intra_nxn_enable = 1;
    pred_unit->h265_pred_unit.constrained_intra_pred_flag = 0;
    pred_unit->h265_pred_unit.strong_intra_smoothing_enabled_flag = 0;
    pred_unit->h265_pred_unit.max_num_merge = 2;
    ctx.message = ENC_CONFIG_PRED_UNIT;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h265_pred_unit_dynamic_intra) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "predUnit_dynamic_intra";
    char inputSuffix[MAX_FILE_PATH] = "_long.yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;
    params->h265_enc_config.wpp_enable = 1;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 1;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    mc_video_pred_unit_params_t *pred_unit = &ctx.pred_unit;
    ret = hb_mm_mc_get_pred_unit_config(context, pred_unit);
    ASSERT_EQ(ret, (int32_t)0);
    pred_unit->h265_pred_unit.intra_nxn_enable = 1;
    pred_unit->h265_pred_unit.constrained_intra_pred_flag = 0;
    pred_unit->h265_pred_unit.strong_intra_smoothing_enabled_flag = 0;
    pred_unit->h265_pred_unit.max_num_merge = 2;
    ctx.message = ENC_CONFIG_PRED_UNIT;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    ctx.dynamicTest = 1;
    ctx.dynamicMessage = ENC_CONFIG_PRED_UNIT;
    ctx.pred_unit_dynamic = *pred_unit;
    ctx.pred_unit_dynamic.h265_pred_unit.intra_nxn_enable = 0;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h265_pred_unit_dynamic_constrained) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "predUnit_dynamic_constrained";
    char inputSuffix[MAX_FILE_PATH] = "_long.yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;
    params->h265_enc_config.wpp_enable = 1;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 1;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    mc_video_pred_unit_params_t *pred_unit = &ctx.pred_unit;
    ret = hb_mm_mc_get_pred_unit_config(context, pred_unit);
    ASSERT_EQ(ret, (int32_t)0);
    pred_unit->h265_pred_unit.intra_nxn_enable = 1;
    pred_unit->h265_pred_unit.constrained_intra_pred_flag = 0;
    pred_unit->h265_pred_unit.strong_intra_smoothing_enabled_flag = 0;
    pred_unit->h265_pred_unit.max_num_merge = 2;
    ctx.message = ENC_CONFIG_PRED_UNIT;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    ctx.dynamicTest = 1;
    ctx.dynamicMessage = ENC_CONFIG_PRED_UNIT;
    ctx.pred_unit_dynamic = *pred_unit;
    ctx.pred_unit_dynamic.h265_pred_unit.constrained_intra_pred_flag = 1;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h265_pred_unit_dynamic_merge) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "predUnit_dynamic_merge";
    char inputSuffix[MAX_FILE_PATH] = "_long.yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;
    params->h265_enc_config.wpp_enable = 1;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 1;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    mc_video_pred_unit_params_t *pred_unit = &ctx.pred_unit;
    ret = hb_mm_mc_get_pred_unit_config(context, pred_unit);
    ASSERT_EQ(ret, (int32_t)0);
    pred_unit->h265_pred_unit.intra_nxn_enable = 1;
    pred_unit->h265_pred_unit.constrained_intra_pred_flag = 0;
    pred_unit->h265_pred_unit.strong_intra_smoothing_enabled_flag = 0;
    pred_unit->h265_pred_unit.max_num_merge = 2;
    ctx.message = ENC_CONFIG_PRED_UNIT;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    ctx.dynamicTest = 1;
    ctx.dynamicMessage = ENC_CONFIG_PRED_UNIT;
    ctx.pred_unit_dynamic = *pred_unit;
    ctx.pred_unit_dynamic.h265_pred_unit.max_num_merge = 1;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h264_transform) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H264;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "transform";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    mc_video_transform_params_t *transform = &ctx.transform;
    ret = hb_mm_mc_get_transform_config(context, transform);
    ASSERT_EQ(ret, (int32_t)0);
    transform->h264_transform.transform_8x8_enable = 1;
    transform->h264_transform.chroma_cb_qp_offset = 4;
    transform->h264_transform.chroma_cr_qp_offset = 3;
    transform->h264_transform.user_scaling_list_enable = 1;
    uint8_t intra4x4_luma[16] = {6,13,20,28,13,20,28,32,
        20,28,32,37,28,32,37,42};
    uint8_t intra4x4_chromau[16] =  {6,13,20,28,13,20,28,32,
        20,28,32,37,28,32,37,42};
    uint8_t intra4x4_chromav[16] =  {6,13,20,28,13,20,28,32,
        20,28,32,37,28,32,37,42};
    uint8_t inter4x4_luma[16] =  {10,14,20,24,14,20,24,27,
        20,24,27,30,24,27,30,34};
    uint8_t inter4x4_chromau[16] =  {10,14,20,24,14,20,24,27,
        20,24,27,30,24,27,30,34};
    uint8_t inter4x4_chromav[16] =  {10,14,20,24,14,20,24,27,
        20,24,27,30,24,27,30,34};
    uint8_t intra8x8_luma[64] = {6,10,13,16,18,23,25,27,
        10,11,16,18,23,25,27,29,
        13,16,18,23,25,27,29,31,
        16,18,23,25,27,29,31,33,
        18,23,25,27,29,31,33,36,
        23,25,27,29,31,33,36,38,
        25,27,29,31,33,36,38,40,
        27,29,31,33,36,38,40,42
    };
    uint8_t inter8x8_luma[64] = {9,13,15,17,19,21,22,24,
        13,13,17,19,21,22,24,25,
        16,17,19,21,22,24,25,27,
        17,19,21,22,24,25,27,28,
        19,21,22,24,25,27,28,30,
        21,22,24,25,27,28,30,32,
        22,24,25,27,28,30,32,33,
        24,25,27,28,30,32,33,35
    };
    int i = 0;
    for (i=0; i<16;i++){
        transform->h264_transform.scaling_list_4x4[0][i] =
            intra4x4_luma[i];
    }
    for (i=0; i<16;i++){
        transform->h264_transform.scaling_list_4x4[1][i] =
            intra4x4_chromau[i];
        transform->h264_transform.scaling_list_4x4[2][i] =
            intra4x4_chromav[i];
        transform->h264_transform.scaling_list_4x4[3][i] =
            inter4x4_luma[i];
        transform->h264_transform.scaling_list_4x4[4][i] =
            inter4x4_chromau[i];
        transform->h264_transform.scaling_list_4x4[5][i] =
            inter4x4_chromav[i];
    }
    for (i=0; i<64;i++){
        transform->h264_transform.scaling_list_8x8[0][i] =
            intra8x8_luma[i];
        transform->h264_transform.scaling_list_8x8[1][i] =
            inter8x8_luma[i];
    }
    ctx.message = ENC_CONFIG_TRANSFORM;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h265_transform) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "transform";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;
    params->h265_enc_config.wpp_enable = 1;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 1;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    mc_video_transform_params_t *transform = &ctx.transform;
    ret = hb_mm_mc_get_transform_config(context, transform);
    ASSERT_EQ(ret, (int32_t)0);
#ifdef J5
    transform->h265_transform.chroma_cb_qp_offset = 0;
    transform->h265_transform.chroma_cr_qp_offset = 0;
#else
    transform->h265_transform.chroma_cb_qp_offset = 6;
    transform->h265_transform.chroma_cr_qp_offset = 5;
#endif
    transform->h265_transform.user_scaling_list_enable = 1;
    int i, j;
    for (i=0; i<6; i++) {
        for (j=0;j<16;j++) {
            transform->h265_transform.scaling_list_4x4[i][j] = 16;
        }
    }
    uint8_t intra8x8_luma[64] = {16,16,16,16,17,18,21,24,
        16,16,16,16,17,19,22,25,
        16,16,17,18,20,22,25,29,
        16,16,18,21,24,27,31,36,
        17,17,20,24,30,35,41,47,
        18,19,22,27,35,44,54,65,
        21,22,25,31,41,54,70,88,
        24,25,29,36,47,65,88,115
    };
    uint8_t intra8x8_chromau[64] = {16,16,16,16,17,18,21,24,
        16,16,16,16,17,19,22,25,
        16,16,17,18,20,22,25,29,
        16,16,18,21,24,27,31,36,
        17,17,20,24,30,35,41,47,
        18,19,22,27,35,44,54,65,
        21,22,25,31,41,54,70,88,
        24,25,29,36,47,65,88,115
    };
    uint8_t intra8x8_chromav[64] = {16,16,16,16,17,18,21,24,
        16,16,16,16,17,19,22,25,
        16,16,17,18,20,22,25,29,
        16,16,18,21,24,27,31,36,
        17,17,20,24,30,35,41,47,
        18,19,22,27,35,44,54,65,
        21,22,25,31,41,54,70,88,
        24,25,29,36,47,65,88,115
    };
    uint8_t inter8x8_luma[64] = {16,16,16,16,17,18,20,24,
        16,16,16,17,18,20,24,25,
        16,16,17,18,20,24,25,28,
        16,17,18,20,24,25,28,33,
        17,18,20,24,25,28,33,41,
        18,20,24,25,28,33,41,54,
        20,24,25,28,33,41,54,71,
        24,25,28,33,41,54,71,91
    };
    uint8_t inter8x8_chromau[64] = {16,16,16,16,17,18,20,24,
        16,16,16,17,18,20,24,25,
        16,16,17,18,20,24,25,28,
        16,17,18,20,24,25,28,33,
        17,18,20,24,25,28,33,41,
        18,20,24,25,28,33,41,54,
        20,24,25,28,33,41,54,71,
        24,25,28,33,41,54,71,91
    };
    uint8_t inter8x8_chromav[64] = {16,16,16,16,17,18,20,24,
        16,16,16,17,18,20,24,25,
        16,16,17,18,20,24,25,28,
        16,17,18,20,24,25,28,33,
        17,18,20,24,25,28,33,41,
        18,20,24,25,28,33,41,54,
        20,24,25,28,33,41,54,71,
        24,25,28,33,41,54,71,91
    };
    uint8_t intra16x16_luma[64] = {16,16,16,16,17,18,21,24,
        16,16,16,16,17,19,22,25,
        16,16,17,18,20,22,25,29,
        16,16,18,21,24,27,31,36,
        17,17,20,24,30,35,41,47,
        18,19,22,27,35,44,54,65,
        21,22,25,31,41,54,70,88,
        24,25,29,36,47,65,88,115
    };
    uint8_t intra16x16_luma_dc = 16;
    uint8_t intra16x16_chromau[64] = {16,16,16,16,17,18,21,24,
        16,16,16,16,17,19,22,25,
        16,16,17,18,20,22,25,29,
        16,16,18,21,24,27,31,36,
        17,17,20,24,30,35,41,47,
        18,19,22,27,35,44,54,65,
        21,22,25,31,41,54,70,88,
        24,25,29,36,47,65,88,115
    };
    uint8_t intra16x16_chromau_dc = 16;
    uint8_t intra16x16_chromav[64] = {16,16,16,16,17,18,21,24,
        16,16,16,16,17,19,22,25,
        16,16,17,18,20,22,25,29,
        16,16,18,21,24,27,31,36,
        17,17,20,24,30,35,41,47,
        18,19,22,27,35,44,54,65,
        21,22,25,31,41,54,70,88,
        24,25,29,36,47,65,88,115
    };
    uint8_t intra16x16_chromav_dc = 16;
    uint8_t inter16x16_luma[64] = {16,16,16,16,17,18,20,24,
        16,16,16,17,18,20,24,25,
        16,16,17,18,20,24,25,28,
        16,17,18,20,24,25,28,33,
        17,18,20,24,25,28,33,41,
        18,20,24,25,28,33,41,54,
        20,24,25,28,33,41,54,71,
        24,25,28,33,41,54,71,91
    };
    uint8_t inter16x16_luma_dc = 16;
    uint8_t inter16x16_chromau[64] = {16,16,16,16,17,18,20,24,
        16,16,16,17,18,20,24,25,
        16,16,17,18,20,24,25,28,
        16,17,18,20,24,25,28,33,
        17,18,20,24,25,28,33,41,
        18,20,24,25,28,33,41,54,
        20,24,25,28,33,41,54,71,
        24,25,28,33,41,54,71,91
    };
    uint8_t inter16x16_chromau_dc = 16;
    uint8_t inter16x16_chromav[64] = {16,16,16,16,17,18,20,24,
        16,16,16,17,18,20,24,25,
        16,16,17,18,20,24,25,28,
        16,17,18,20,24,25,28,33,
        17,18,20,24,25,28,33,41,
        18,20,24,25,28,33,41,54,
        20,24,25,28,33,41,54,71,
        24,25,28,33,41,54,71,91
    };
    uint8_t inter16x16_chromav_dc = 16;
    uint8_t intra32x32_luma[64] = {16,16,16,16,17,18,21,24,
        16,16,16,16,17,19,22,25,
        16,16,17,18,20,22,25,29,
        16,16,18,21,24,27,31,36,
        17,17,20,24,30,35,41,47,
        18,19,22,27,35,44,54,65,
        21,22,25,31,41,54,70,88,
        24,25,29,36,47,65,88,115
    };
    uint8_t intra32x32_luma_dc = 16;
    uint8_t inter32x32_luma[64] = {16,16,16,16,17,18,20,24,
        16,16,16,17,18,20,24,25,
        16,16,17,18,20,24,25,28,
        16,17,18,20,24,25,28,33,
        17,18,20,24,25,28,33,41,
        18,20,24,25,28,33,41,54,
        20,24,25,28,33,41,54,71,
        24,25,28,33,41,54,71,91
    };
    uint8_t inter32x32_luma_dc = 16;
    for (i=0; i<64; i++) {
        transform->h265_transform.scaling_list_8x8[0][i] =
            intra8x8_luma[i];
        transform->h265_transform.scaling_list_16x16[0][i] =
            intra16x16_luma[i];
        transform->h265_transform.scaling_list_8x8[1][i] =
            intra8x8_chromau[i];
        transform->h265_transform.scaling_list_16x16[1][i] =
            intra16x16_chromau[i];
        transform->h265_transform.scaling_list_8x8[2][i] =
            intra8x8_chromav[i];
        transform->h265_transform.scaling_list_16x16[2][i] =
            intra16x16_chromav[i];
        transform->h265_transform.scaling_list_8x8[3][i] =
            inter8x8_luma[i];
        transform->h265_transform.scaling_list_16x16[3][i] =
            inter16x16_luma[i];
        transform->h265_transform.scaling_list_8x8[4][i] =
            inter8x8_chromau[i];
        transform->h265_transform.scaling_list_16x16[4][i] =
            inter16x16_chromau[i];
        transform->h265_transform.scaling_list_8x8[5][i] =
            inter8x8_chromav[i];
        transform->h265_transform.scaling_list_16x16[5][i] =
            inter16x16_chromav[i];
        transform->h265_transform.scaling_list_32x32[0][i] =
            intra32x32_luma[i];
        transform->h265_transform.scaling_list_32x32[1][i] =
            inter32x32_luma[i];
    }
    transform->h265_transform.scaling_list_dc_16x16[0] = intra16x16_luma_dc;
    transform->h265_transform.scaling_list_dc_16x16[1] = intra16x16_chromau_dc;
    transform->h265_transform.scaling_list_dc_16x16[2] = intra16x16_chromav_dc;
    transform->h265_transform.scaling_list_dc_16x16[3] = inter16x16_luma_dc;
    transform->h265_transform.scaling_list_dc_16x16[4] = inter16x16_chromau_dc;
    transform->h265_transform.scaling_list_dc_16x16[5] = inter16x16_chromav_dc;
    transform->h265_transform.scaling_list_dc_32x32[0] = intra32x32_luma_dc;
    transform->h265_transform.scaling_list_dc_32x32[1] = inter32x32_luma_dc;
    ctx.message = ENC_CONFIG_TRANSFORM;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h265_transform_dynamic) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "dynamic_transform";
    char inputSuffix[MAX_FILE_PATH] = "_long.yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;
    params->h265_enc_config.wpp_enable = 1;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 1;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    mc_video_transform_params_t *transform = &ctx.transform;
    ret = hb_mm_mc_get_transform_config(context, transform);
    ASSERT_EQ(ret, (int32_t)0);
#ifdef J5
    transform->h265_transform.chroma_cb_qp_offset = 0;
    transform->h265_transform.chroma_cr_qp_offset = 0;
#else
    transform->h265_transform.chroma_cb_qp_offset = 6;
    transform->h265_transform.chroma_cr_qp_offset = 5;
#endif
    transform->h265_transform.user_scaling_list_enable = 1;
    int i, j;
    for (i=0; i<6; i++) {
        for (j=0;j<16;j++) {
            transform->h265_transform.scaling_list_4x4[i][j] = 16;
        }
    }
    uint8_t intra8x8_luma[64] = {16,16,16,16,17,18,21,24,
        16,16,16,16,17,19,22,25,
        16,16,17,18,20,22,25,29,
        16,16,18,21,24,27,31,36,
        17,17,20,24,30,35,41,47,
        18,19,22,27,35,44,54,65,
        21,22,25,31,41,54,70,88,
        24,25,29,36,47,65,88,115
    };
    uint8_t intra8x8_chromau[64] = {16,16,16,16,17,18,21,24,
        16,16,16,16,17,19,22,25,
        16,16,17,18,20,22,25,29,
        16,16,18,21,24,27,31,36,
        17,17,20,24,30,35,41,47,
        18,19,22,27,35,44,54,65,
        21,22,25,31,41,54,70,88,
        24,25,29,36,47,65,88,115
    };
    uint8_t intra8x8_chromav[64] = {16,16,16,16,17,18,21,24,
        16,16,16,16,17,19,22,25,
        16,16,17,18,20,22,25,29,
        16,16,18,21,24,27,31,36,
        17,17,20,24,30,35,41,47,
        18,19,22,27,35,44,54,65,
        21,22,25,31,41,54,70,88,
        24,25,29,36,47,65,88,115
    };
    uint8_t inter8x8_luma[64] = {16,16,16,16,17,18,20,24,
        16,16,16,17,18,20,24,25,
        16,16,17,18,20,24,25,28,
        16,17,18,20,24,25,28,33,
        17,18,20,24,25,28,33,41,
        18,20,24,25,28,33,41,54,
        20,24,25,28,33,41,54,71,
        24,25,28,33,41,54,71,91
    };
    uint8_t inter8x8_chromau[64] = {16,16,16,16,17,18,20,24,
        16,16,16,17,18,20,24,25,
        16,16,17,18,20,24,25,28,
        16,17,18,20,24,25,28,33,
        17,18,20,24,25,28,33,41,
        18,20,24,25,28,33,41,54,
        20,24,25,28,33,41,54,71,
        24,25,28,33,41,54,71,91
    };
    uint8_t inter8x8_chromav[64] = {16,16,16,16,17,18,20,24,
        16,16,16,17,18,20,24,25,
        16,16,17,18,20,24,25,28,
        16,17,18,20,24,25,28,33,
        17,18,20,24,25,28,33,41,
        18,20,24,25,28,33,41,54,
        20,24,25,28,33,41,54,71,
        24,25,28,33,41,54,71,91
    };
    uint8_t intra16x16_luma[64] = {16,16,16,16,17,18,21,24,
        16,16,16,16,17,19,22,25,
        16,16,17,18,20,22,25,29,
        16,16,18,21,24,27,31,36,
        17,17,20,24,30,35,41,47,
        18,19,22,27,35,44,54,65,
        21,22,25,31,41,54,70,88,
        24,25,29,36,47,65,88,115
    };
    uint8_t intra16x16_luma_dc = 16;
    uint8_t intra16x16_chromau[64] = {16,16,16,16,17,18,21,24,
        16,16,16,16,17,19,22,25,
        16,16,17,18,20,22,25,29,
        16,16,18,21,24,27,31,36,
        17,17,20,24,30,35,41,47,
        18,19,22,27,35,44,54,65,
        21,22,25,31,41,54,70,88,
        24,25,29,36,47,65,88,115
    };
    uint8_t intra16x16_chromau_dc = 16;
    uint8_t intra16x16_chromav[64] = {16,16,16,16,17,18,21,24,
        16,16,16,16,17,19,22,25,
        16,16,17,18,20,22,25,29,
        16,16,18,21,24,27,31,36,
        17,17,20,24,30,35,41,47,
        18,19,22,27,35,44,54,65,
        21,22,25,31,41,54,70,88,
        24,25,29,36,47,65,88,115
    };
    uint8_t intra16x16_chromav_dc = 16;
    uint8_t inter16x16_luma[64] = {16,16,16,16,17,18,20,24,
        16,16,16,17,18,20,24,25,
        16,16,17,18,20,24,25,28,
        16,17,18,20,24,25,28,33,
        17,18,20,24,25,28,33,41,
        18,20,24,25,28,33,41,54,
        20,24,25,28,33,41,54,71,
        24,25,28,33,41,54,71,91
    };
    uint8_t inter16x16_luma_dc = 16;
    uint8_t inter16x16_chromau[64] = {16,16,16,16,17,18,20,24,
        16,16,16,17,18,20,24,25,
        16,16,17,18,20,24,25,28,
        16,17,18,20,24,25,28,33,
        17,18,20,24,25,28,33,41,
        18,20,24,25,28,33,41,54,
        20,24,25,28,33,41,54,71,
        24,25,28,33,41,54,71,91
    };
    uint8_t inter16x16_chromau_dc = 16;
    uint8_t inter16x16_chromav[64] = {16,16,16,16,17,18,20,24,
        16,16,16,17,18,20,24,25,
        16,16,17,18,20,24,25,28,
        16,17,18,20,24,25,28,33,
        17,18,20,24,25,28,33,41,
        18,20,24,25,28,33,41,54,
        20,24,25,28,33,41,54,71,
        24,25,28,33,41,54,71,91
    };
    uint8_t inter16x16_chromav_dc = 16;
    uint8_t intra32x32_luma[64] = {16,16,16,16,17,18,21,24,
        16,16,16,16,17,19,22,25,
        16,16,17,18,20,22,25,29,
        16,16,18,21,24,27,31,36,
        17,17,20,24,30,35,41,47,
        18,19,22,27,35,44,54,65,
        21,22,25,31,41,54,70,88,
        24,25,29,36,47,65,88,115
    };
    uint8_t intra32x32_luma_dc = 16;
    uint8_t inter32x32_luma[64] = {16,16,16,16,17,18,20,24,
        16,16,16,17,18,20,24,25,
        16,16,17,18,20,24,25,28,
        16,17,18,20,24,25,28,33,
        17,18,20,24,25,28,33,41,
        18,20,24,25,28,33,41,54,
        20,24,25,28,33,41,54,71,
        24,25,28,33,41,54,71,91
    };
    uint8_t inter32x32_luma_dc = 16;
    for (i=0; i<64; i++) {
        transform->h265_transform.scaling_list_8x8[0][i] =
            intra8x8_luma[i];
        transform->h265_transform.scaling_list_16x16[0][i] =
            intra16x16_luma[i];
        transform->h265_transform.scaling_list_8x8[1][i] =
            intra8x8_chromau[i];
        transform->h265_transform.scaling_list_16x16[1][i] =
            intra16x16_chromau[i];
        transform->h265_transform.scaling_list_8x8[2][i] =
            intra8x8_chromav[i];
        transform->h265_transform.scaling_list_16x16[2][i] =
            intra16x16_chromav[i];
        transform->h265_transform.scaling_list_8x8[3][i] =
            inter8x8_luma[i];
        transform->h265_transform.scaling_list_16x16[3][i] =
            inter16x16_luma[i];
        transform->h265_transform.scaling_list_8x8[4][i] =
            inter8x8_chromau[i];
        transform->h265_transform.scaling_list_16x16[4][i] =
            inter16x16_chromau[i];
        transform->h265_transform.scaling_list_8x8[5][i] =
            inter8x8_chromav[i];
        transform->h265_transform.scaling_list_16x16[5][i] =
            inter16x16_chromav[i];
        transform->h265_transform.scaling_list_32x32[0][i] =
            intra32x32_luma[i];
        transform->h265_transform.scaling_list_32x32[1][i] =
            inter32x32_luma[i];
    }
    transform->h265_transform.scaling_list_dc_16x16[0] = intra16x16_luma_dc;
    transform->h265_transform.scaling_list_dc_16x16[1] = intra16x16_chromau_dc;
    transform->h265_transform.scaling_list_dc_16x16[2] = intra16x16_chromav_dc;
    transform->h265_transform.scaling_list_dc_16x16[3] = inter16x16_luma_dc;
    transform->h265_transform.scaling_list_dc_16x16[4] = inter16x16_chromau_dc;
    transform->h265_transform.scaling_list_dc_16x16[5] = inter16x16_chromav_dc;
    transform->h265_transform.scaling_list_dc_32x32[0] = intra32x32_luma_dc;
    transform->h265_transform.scaling_list_dc_32x32[1] = inter32x32_luma_dc;
    ctx.message = ENC_CONFIG_TRANSFORM;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    ctx.dynamicTest = 1;
    ctx.dynamicMessage = ENC_CONFIG_TRANSFORM;
    ctx.transform_dynamic = *transform;
    ctx.transform_dynamic.h265_transform.user_scaling_list_enable = 0;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h264_roi) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H264;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "roi";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264VBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;


    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    mc_video_roi_params_t *roi = &ctx.roi;
    ret = hb_mm_mc_get_roi_config(context, roi);
    ASSERT_EQ(ret, (int32_t)0);
    roi->roi_enable = 1;
    roi->roi_map_array_count = (((params->width+0x0f)&~0x0f) >> 4)
        *(((params->height+0x0f)&~0x0f) >> 4);
    roi->roi_map_array =
        (unsigned char*)malloc(roi->roi_map_array_count*sizeof(unsigned char));
    for (unsigned int i=0; i<roi->roi_map_array_count; i++) {
        roi->roi_map_array[i] = 15;
    }
    ctx.message = ENC_CONFIG_ROI;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (roi->roi_map_array)
        free(roi->roi_map_array);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h265_cbr_with_qpmap_val) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "cbr_with_qpmap";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.h264_cbr_params.hvs_qp_enable = 0;
        params->rc_params.h264_cbr_params.qp_map_enable = 1;
    } else {
        params->rc_params.h265_cbr_params.hvs_qp_enable = 0;
        params->rc_params.h265_cbr_params.qp_map_enable = 1;
    }
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    ctx.qpmap_enable = 1;
#ifdef J5
    ctx.qpmap_count = (((params->width+0x3f)&~0x3f) >> 6)
        *(((params->height+0x3f)&~0x3f) >> 6);
#else
    ctx.qpmap_count = (((params->width+0x3f)&~0x3f) >> 5)
        *(((params->height+0x3f)&~0x3f) >> 5);
#endif
    ctx.qpmap_array =
        (unsigned char*)malloc(ctx.qpmap_count * sizeof(unsigned char));
    for (unsigned int i=0; i<ctx.qpmap_count; i++) {
        ctx.qpmap_array[i] = 2;
    }
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (ctx.qpmap_array) {
        free(ctx.qpmap_array);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h265_avbr_with_qpmap_val) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "avbr_with_qpmap";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264AVBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265AVBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.h264_cbr_params.hvs_qp_enable = 0;
        params->rc_params.h264_cbr_params.qp_map_enable = 1;
    } else {
        params->rc_params.h265_cbr_params.hvs_qp_enable = 0;
        params->rc_params.h265_cbr_params.qp_map_enable = 1;
    }
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    ctx.qpmap_enable = 1;
#ifdef J5
    ctx.qpmap_count = (((params->width+0x3f)&~0x3f) >> 6)
        *(((params->height+0x3f)&~0x3f) >> 6);
#else
    ctx.qpmap_count = (((params->width+0x3f)&~0x3f) >> 5)
        *(((params->height+0x3f)&~0x3f) >> 5);
#endif
    ctx.qpmap_array =
        (unsigned char*)malloc(ctx.qpmap_count * sizeof(unsigned char));
    for (unsigned int i=0; i<ctx.qpmap_count; i++) {
        ctx.qpmap_array[i] = 4;
    }
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (ctx.qpmap_array) {
        free(ctx.qpmap_array);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h265_roi) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "roi";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264VBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265VBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;


    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    mc_video_roi_params_t *roi = &ctx.roi;
    ret = hb_mm_mc_get_roi_config(context, roi);
    ASSERT_EQ(ret, (int32_t)0);
    roi->roi_enable = 1;
#ifdef J5
    roi->roi_map_array_count = (((params->width+0x3f)&~0x3f) >> 6)
        *(((params->height+0x3f)&~0x3f) >> 6);
#else
    roi->roi_map_array_count = (((params->width+0x3f)&~0x3f) >> 5)
        *(((params->height+0x3f)&~0x3f) >> 5);
#endif
    roi->roi_map_array =
        (unsigned char*)malloc(roi->roi_map_array_count*sizeof(unsigned char));
    for (unsigned int i=0; i<roi->roi_map_array_count; i++) {
        roi->roi_map_array[i] = 25;
    }
    ctx.message = ENC_CONFIG_ROI;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (roi->roi_map_array)
        free(roi->roi_map_array);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h265_roi_dynamic) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "dynamic_roi";
    char inputSuffix[MAX_FILE_PATH] = "_long.yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264VBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265VBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    mc_video_roi_params_t *roi = &ctx.roi;
    ret = hb_mm_mc_get_roi_config(context, roi);
    ASSERT_EQ(ret, (int32_t)0);
    roi->roi_enable = 1;
#ifdef J5
    roi->roi_map_array_count = (((params->width+0x3f)&~0x3f) >> 6)
        *(((params->height+0x3f)&~0x3f) >> 6);
#else
    roi->roi_map_array_count = (((params->width+0x3f)&~0x3f) >> 5)
        *(((params->height+0x3f)&~0x3f) >> 5);
#endif
    roi->roi_map_array =
        (unsigned char*)malloc(roi->roi_map_array_count*sizeof(unsigned char));
    for (unsigned int i=0; i<roi->roi_map_array_count; i++) {
        roi->roi_map_array[i] = 25;
    }
    ctx.message = ENC_CONFIG_ROI;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    ctx.dynamicTest = 1;
    ctx.dynamicMessage = ENC_CONFIG_ROI;
    ctx.roi_dynamic = *roi;
    ctx.roi_dynamic.roi_map_array =
        (unsigned char*)malloc(ctx.roi_dynamic.roi_map_array_count*sizeof(unsigned char));
    for (unsigned int i=0; i<ctx.roi_dynamic.roi_map_array_count; i++) {
        ctx.roi_dynamic.roi_map_array[i] = 15;
    }
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (roi->roi_map_array)
        free(roi->roi_map_array);
    if (context != NULL) {
        free(context);
    }
}

#ifdef J5
TEST_F(MediaCodecTest, test_encoding_case_h265_roi_2) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "roi2";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264VBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265VBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;


    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    mc_video_roi_params_t *roi = &ctx.roi;
    ret = hb_mm_mc_get_roi_config(context, roi);
    ASSERT_EQ(ret, (int32_t)0);
    roi->roi_enable = 1;
    roi->roi_map_array_count = (((params->width+0x3f)&~0x3f) >> 6)
        *(((params->height+0x3f)&~0x3f) >> 6);
    roi->roi_map_array =
        (unsigned char*)malloc(roi->roi_map_array_count*sizeof(unsigned char));
    for (unsigned int i=0; i<roi->roi_map_array_count; i++) {
        roi->roi_map_array[i] = 25;
    }
    ctx.message = ENC_CONFIG_ROI;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (roi->roi_map_array)
        free(roi->roi_map_array);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h265_roi_ex_mode_1) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "roiExMode1";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.h264_cbr_params.hvs_qp_enable = 0;
    } else {
        params->rc_params.h265_cbr_params.hvs_qp_enable = 0;
    }
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;


    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    mc_video_roi_params_ex_t *roiEx = &ctx.roiEx;
    ret = hb_mm_mc_get_roi_config_ex(context, 0, roiEx);
    ASSERT_EQ(ret, (int32_t)0);
    roiEx->roi_mode = 1;
    roiEx->roi_idx = 0;
    roiEx->roi_enable = 1;
    roiEx->roi_val = 5;
    roiEx->roi_delta_qp = 2;
    roiEx->crop_rect.x_pos = 0;
    roiEx->crop_rect.y_pos = 0;
    roiEx->crop_rect.width = (((params->width + 0x3f)&~0x3f) >> 6) - 1;
    roiEx->crop_rect.height = (((params->height + 0x3f)&~0x3f) >> 6) - 1;
    ctx.message = ENC_CONFIG_ROI_EX;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h265_roi_ex_mode_1_2) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "roiExMode1_2";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.h264_cbr_params.hvs_qp_enable = 0;
    } else {
        params->rc_params.h265_cbr_params.hvs_qp_enable = 0;
    }
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;


    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    mc_video_roi_params_ex_t *roiEx = &ctx.roiEx;
    ret = hb_mm_mc_get_roi_config_ex(context, 0, roiEx);
    ASSERT_EQ(ret, (int32_t)0);
    roiEx->roi_mode = 1;
    roiEx->roi_idx = 0;
    roiEx->roi_enable = 1;
    roiEx->roi_val = 5;
    roiEx->roi_delta_qp = 2;
    roiEx->crop_rect.x_pos = 0;
    roiEx->crop_rect.y_pos = 0;
    roiEx->crop_rect.width = ((params->width + 0x3f)&~0x3f) >> 6;
    roiEx->crop_rect.height = ((params->height + 0x3f)&~0x3f) >> 6;
    ctx.message = ENC_CONFIG_ROI_EX;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h265_roi_ex_mode_1_dynamic) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "dynamic_roiExMode1";
    char inputSuffix[MAX_FILE_PATH] = "_long.yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.h264_cbr_params.hvs_qp_enable = 0;
    } else {
        params->rc_params.h265_cbr_params.hvs_qp_enable = 0;
    }
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    mc_video_roi_params_ex_t *roiEx = &ctx.roiEx;
    ret = hb_mm_mc_get_roi_config_ex(context, 0, roiEx);
    ASSERT_EQ(ret, (int32_t)0);
    roiEx->roi_mode = 1;
    roiEx->roi_idx = 0;
    roiEx->roi_enable = 1;
    roiEx->roi_val = 5;
    roiEx->roi_delta_qp = 2;
    roiEx->crop_rect.x_pos = 0;
    roiEx->crop_rect.y_pos = 0;
    roiEx->crop_rect.width = (((params->width + 0x3f)&~0x3f) >> 6) - 1;
    roiEx->crop_rect.height = (((params->height + 0x3f)&~0x3f) >> 6) - 1;
    ctx.message = ENC_CONFIG_ROI_EX;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    ctx.dynamicTest = 1;
    ctx.dynamicMessage = ENC_CONFIG_ROI_EX;
    ctx.roiEx_dynamic = *roiEx;
    ctx.roiEx_dynamic.roi_val = 1;
    ctx.roiEx_dynamic.roi_delta_qp = 3;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h265_roi_ex_mode_2) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "roiExMode2";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264VBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265VBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;


    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    mc_video_roi_params_ex_t *roiEx = &ctx.roiEx;
    ret = hb_mm_mc_get_roi_config_ex(context, 0, roiEx);
    ASSERT_EQ(ret, (int32_t)0);
    roiEx->roi_mode = 2;
    roiEx->roi_idx = 0;
    roiEx->roi_enable = 1;
    roiEx->roi_val = 25;
    roiEx->roi_delta_qp = 0;
    roiEx->crop_rect.x_pos = 0;
    roiEx->crop_rect.y_pos = 0;
    roiEx->crop_rect.width = ((params->width + 0x3f)&~0x3f) >> 6;
    roiEx->crop_rect.height = ((params->height + 0x3f)&~0x3f) >> 6;
    ctx.message = ENC_CONFIG_ROI_EX;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h265_roi_ex_mode_2_dynamic) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "dynamic_roiExMode2";
    char inputSuffix[MAX_FILE_PATH] = "_long.yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264VBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265VBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    mc_video_roi_params_ex_t *roiEx = &ctx.roiEx;
    ret = hb_mm_mc_get_roi_config_ex(context, 0, roiEx);
    ASSERT_EQ(ret, (int32_t)0);
    roiEx->roi_mode = 2;
    roiEx->roi_idx = 0;
    roiEx->roi_enable = 1;
    roiEx->roi_val = 25;
    roiEx->roi_delta_qp = 0;
    roiEx->crop_rect.x_pos = 0;
    roiEx->crop_rect.y_pos = 0;
    roiEx->crop_rect.width = ((params->width + 0x3f)&~0x3f) >> 6;
    roiEx->crop_rect.height = ((params->height + 0x3f)&~0x3f) >> 6;
    ctx.message = ENC_CONFIG_ROI_EX;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    ctx.dynamicTest = 1;
    ctx.dynamicMessage = ENC_CONFIG_ROI_EX;
    ctx.roiEx_dynamic = *roiEx;
    ctx.roiEx_dynamic.roi_val = 14;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

#endif

TEST_F(MediaCodecTest, test_encoding_case_h264_roi_avg_qp) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H264;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "roiAvgQP";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264VBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265VBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    mc_video_roi_params_t *roi = &ctx.roi;
    ret = hb_mm_mc_get_roi_config(context, roi);
    ASSERT_EQ(ret, (int32_t)0);
    roi->roi_enable = 1;
    roi->roi_map_array_count = (((params->width+0x0f)&~0x0f) >> 4)
        *(((params->height+0x0f)&~0x0f) >> 4);
    roi->roi_map_array =
        (unsigned char*)malloc(roi->roi_map_array_count*sizeof(unsigned char));
    for (unsigned int i=0; i<roi->roi_map_array_count; i++) {
        roi->roi_map_array[i] = 15;
    }

    hb_u32 *roi_avg_qp = &ctx.roi_avg_qp;
    ret = hb_mm_mc_get_roi_avg_qp(context, roi_avg_qp);
    ASSERT_EQ(ret, (int32_t)0);
    *roi_avg_qp = 13;
    ctx.message = (ENC_CONFIG_MESSAGE)(ENC_CONFIG_ROI | ENC_CONFIG_ROI_AVG_QP);
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (roi->roi_map_array)
        free(roi->roi_map_array);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h265_roi_avg_qp) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "roiAvgQP";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264VBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265VBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    mc_video_roi_params_t *roi = &ctx.roi;
    ret = hb_mm_mc_get_roi_config(context, roi);
    ASSERT_EQ(ret, (int32_t)0);
    roi->roi_enable = 1;
#ifdef J5
    roi->roi_map_array_count = (((params->width+0x3f)&~0x3f) >> 6)
        *(((params->height+0x3f)&~0x3f) >> 6);
#else
    roi->roi_map_array_count = (((params->width+0x3f)&~0x3f) >> 5)
        *(((params->height+0x3f)&~0x3f) >> 5);
#endif
    roi->roi_map_array =
        (unsigned char*)malloc(roi->roi_map_array_count*sizeof(unsigned char));
    for (unsigned int i=0; i<roi->roi_map_array_count; i++) {
        roi->roi_map_array[i] = 25;
    }
    hb_u32 *roi_avg_qp = &ctx.roi_avg_qp;
    ret = hb_mm_mc_get_roi_avg_qp(context, roi_avg_qp);
    ASSERT_EQ(ret, (int32_t)0);
    *roi_avg_qp = 13;
    ctx.message = (ENC_CONFIG_MESSAGE)(ENC_CONFIG_ROI | ENC_CONFIG_ROI_AVG_QP);
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (roi->roi_map_array)
        free(roi->roi_map_array);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h265_roi_avg_qp_2) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "roiAvgQP2";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.h264_cbr_params.hvs_qp_enable = 0;
    } else {
        params->rc_params.h265_cbr_params.hvs_qp_enable = 0;
    }
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    mc_video_roi_params_ex_t *roiEx = &ctx.roiEx;
    ret = hb_mm_mc_get_roi_config_ex(context, 0, roiEx);
    ASSERT_EQ(ret, (int32_t)0);
    roiEx->roi_mode = 1;
    roiEx->roi_idx = 0;
    roiEx->roi_enable = 1;
    roiEx->roi_val = 5;
    roiEx->roi_delta_qp = 2;
    roiEx->crop_rect.x_pos = 0;
    roiEx->crop_rect.y_pos = 0;
    roiEx->crop_rect.width = (((params->width + 0x3f)&~0x3f) >> 6) - 1;
    roiEx->crop_rect.height = (((params->height + 0x3f)&~0x3f) >> 6) - 1;

    hb_u32 *roi_avg_qp = &ctx.roi_avg_qp;
    ret = hb_mm_mc_get_roi_avg_qp(context, roi_avg_qp);
    ASSERT_EQ(ret, (int32_t)0);
    *roi_avg_qp = 5;
    ctx.message = (ENC_CONFIG_MESSAGE)(ENC_CONFIG_ROI_EX | ENC_CONFIG_ROI_AVG_QP);
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h265_roi_avg_qp_3) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "roiAvgQP3";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.h264_cbr_params.hvs_qp_enable = 0;
    } else {
        params->rc_params.h265_cbr_params.hvs_qp_enable = 0;
    }
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    mc_video_roi_params_ex_t *roiEx = &ctx.roiEx;
    ret = hb_mm_mc_get_roi_config_ex(context, 0, roiEx);
    ASSERT_EQ(ret, (int32_t)0);
    roiEx->roi_mode = 1;
    roiEx->roi_idx = 0;
    roiEx->roi_enable = 1;
    roiEx->roi_val = 5;
    roiEx->roi_delta_qp = 2;
    roiEx->crop_rect.x_pos = 0;
    roiEx->crop_rect.y_pos = 0;
    roiEx->crop_rect.width = (((params->width + 0x3f)&~0x3f) >> 6) - 1;
    roiEx->crop_rect.height = (((params->height + 0x3f)&~0x3f) >> 6) - 1;

    hb_u32 *roi_avg_qp = &ctx.roi_avg_qp;
    ret = hb_mm_mc_get_roi_avg_qp(context, roi_avg_qp);
    ASSERT_EQ(ret, (int32_t)0);
    *roi_avg_qp = 6;
    ctx.message = (ENC_CONFIG_MESSAGE)(ENC_CONFIG_ROI_EX | ENC_CONFIG_ROI_AVG_QP);
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h265_roi_avg_qp_dynamic) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "dynamic_roiAvgQP";
    char inputSuffix[MAX_FILE_PATH] = "_long.yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.h264_cbr_params.hvs_qp_enable = 0;
    } else {
        params->rc_params.h265_cbr_params.hvs_qp_enable = 0;
    }
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    mc_video_roi_params_ex_t *roiEx = &ctx.roiEx;
    ret = hb_mm_mc_get_roi_config_ex(context, 0, roiEx);
    ASSERT_EQ(ret, (int32_t)0);
    roiEx->roi_mode = 1;
    roiEx->roi_idx = 0;
    roiEx->roi_enable = 1;
    roiEx->roi_val = 5;
    roiEx->roi_delta_qp = 2;
    roiEx->crop_rect.x_pos = 0;
    roiEx->crop_rect.y_pos = 0;
    roiEx->crop_rect.width = (((params->width + 0x3f)&~0x3f) >> 6) - 1;
    roiEx->crop_rect.height = (((params->height + 0x3f)&~0x3f) >> 6) - 1;

    hb_u32 *roi_avg_qp = &ctx.roi_avg_qp;
    ret = hb_mm_mc_get_roi_avg_qp(context, roi_avg_qp);
    ASSERT_EQ(ret, (int32_t)0);
    *roi_avg_qp = 6;
    ctx.message = (ENC_CONFIG_MESSAGE)(ENC_CONFIG_ROI_EX | ENC_CONFIG_ROI_AVG_QP);
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    ctx.dynamicTest = 1;
    ctx.dynamicMessage = ENC_CONFIG_ROI_AVG_QP;
    ctx.roi_avg_qp_dynamic = 3;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h265_mode_decision_off) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "modeDeci0";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = MC_PIXEL_FORMAT_YUV420P;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    mc_video_mode_decision_params_t *mode_decision = &ctx.mode_decision;
    ret = hb_mm_mc_get_mode_decision_config(context, mode_decision);
    ASSERT_EQ(ret, (int32_t)0);
    mode_decision->mode_decision_enable = FALSE;
    mode_decision->pu04_delta_rate = 76;
    mode_decision->pu08_delta_rate = 80;
    mode_decision->pu16_delta_rate = 86;
    mode_decision->pu32_delta_rate = 87;
    mode_decision->pu04_intra_planar_delta_rate = 0;
    mode_decision->pu04_intra_dc_delta_rate = 0;
    mode_decision->pu04_intra_angle_delta_rate = 0;
    mode_decision->pu08_intra_planar_delta_rate = 0;
    mode_decision->pu08_intra_dc_delta_rate = 0;
    mode_decision->pu08_intra_angle_delta_rate = 0;
    mode_decision->pu16_intra_planar_delta_rate = 0;
    mode_decision->pu16_intra_dc_delta_rate = 0;
    mode_decision->pu16_intra_angle_delta_rate = 0;
    mode_decision->pu32_intra_planar_delta_rate = 0;
    mode_decision->pu32_intra_dc_delta_rate = 0;
    mode_decision->pu32_intra_angle_delta_rate = 0;
    mode_decision->cu08_intra_delta_rate = 0;
    mode_decision->cu08_inter_delta_rate = 0;
    mode_decision->cu08_merge_delta_rate = 0;
    mode_decision->cu16_intra_delta_rate = 0;
    mode_decision->cu16_inter_delta_rate = 0;
    mode_decision->cu16_merge_delta_rate = 0;
    mode_decision->cu32_intra_delta_rate = 0;
    mode_decision->cu32_inter_delta_rate = 0;
    mode_decision->cu32_merge_delta_rate = 0;
    ctx.message = ENC_CONFIG_MODE_DECISION;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_effect_case_h265_mode_decision_1) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "modeDeci1";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = MC_PIXEL_FORMAT_YUV420P;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    mc_video_mode_decision_params_t *mode_decision = &ctx.mode_decision;
    ret = hb_mm_mc_get_mode_decision_config(context, mode_decision);
    ASSERT_EQ(ret, (int32_t)0);
    mode_decision->mode_decision_enable = TRUE;
    mode_decision->pu04_delta_rate = 0;
    mode_decision->pu08_delta_rate = 80;
    mode_decision->pu16_delta_rate = 160;
    mode_decision->pu32_delta_rate = 240;
    mode_decision->pu04_intra_planar_delta_rate = 0;
    mode_decision->pu04_intra_dc_delta_rate = 0;
    mode_decision->pu04_intra_angle_delta_rate = 0;
    mode_decision->pu08_intra_planar_delta_rate = 0;
    mode_decision->pu08_intra_dc_delta_rate = 0;
    mode_decision->pu08_intra_angle_delta_rate = 0;
    mode_decision->pu16_intra_planar_delta_rate = 0;
    mode_decision->pu16_intra_dc_delta_rate = 0;
    mode_decision->pu16_intra_angle_delta_rate = 0;
    mode_decision->pu32_intra_planar_delta_rate = 0;
    mode_decision->pu32_intra_dc_delta_rate = 0;
    mode_decision->pu32_intra_angle_delta_rate = 0;
    mode_decision->cu08_intra_delta_rate = 0;
    mode_decision->cu08_inter_delta_rate = 0;
    mode_decision->cu08_merge_delta_rate = 0;
    mode_decision->cu16_intra_delta_rate = 0;
    mode_decision->cu16_inter_delta_rate = 0;
    mode_decision->cu16_merge_delta_rate = 0;
    mode_decision->cu32_intra_delta_rate = 0;
    mode_decision->cu32_inter_delta_rate = 0;
    mode_decision->cu32_merge_delta_rate = 0;
    ctx.message = ENC_CONFIG_MODE_DECISION;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h264_insert_user_data) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H264;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "userdata";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.insert_userData_num = 15;
    ctx.message = ENC_CONFIG_INSERT_USERDATA;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h265_insert_user_data) {
    hb_s32 ret = 0;
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "userdata";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;
    params->h265_enc_config.wpp_enable = 1;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    mc_video_slice_params_t *slice = &ctx.slice;
    ret = hb_mm_mc_get_slice_config(context, slice);
    ASSERT_EQ(ret, (int32_t)0);
    slice->h265_slice.h265_dependent_slice_mode = 0;
    slice->h265_slice.h265_dependent_slice_arg = 0;
    slice->h265_slice.h265_independent_slice_mode = 0;
    slice->h265_slice.h265_independent_slice_arg = 0;
    ctx.insert_userData_num = 15;
    ctx.message = (ENC_CONFIG_MESSAGE)(ENC_CONFIG_SLICE | ENC_CONFIG_INSERT_USERDATA);
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h265_insert_user_data_2) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "userdata2";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;
    params->h265_enc_config.wpp_enable = 1;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.message = ENC_CONFIG_INSERT_USERDATA;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_enable_idr) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "enableIdr";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.enable_idr_num = 0;
    ctx.message = ENC_CONFIG_ENABLE_IDR;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_disable_idr) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "disableIdr";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.enable_idr_num = 35;
    ctx.message = ENC_CONFIG_ENABLE_IDR;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h264_req_idr) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H264;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "reqIdr";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.req_idr_num = 15;
    ctx.message = ENC_CONFIG_REQUEST_IDR;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h264_req_idr_header_1) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H264;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "reqIdrHeader";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.force_idr_header_num = 0;
    ctx.force_idr_header = 1;
    ctx.message = ENC_CONFIG_REQUEST_IDR_HEADER;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h264_req_idr_header_2) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H264;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "reqIdrHeader2";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 1;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.force_idr_header_num = 0;
    ctx.force_idr_header = 2;
    ctx.message = ENC_CONFIG_REQUEST_IDR_HEADER;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h264_enable_explicit_header) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H264;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "enableExHeader";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    EXPECT_EQ(hb_mm_mc_get_explicit_header_config(context,
        &ctx.enable_explicit_header), 0);
    EXPECT_EQ(ctx.enable_explicit_header, 1);
    ctx.enable_explicit_header = 1;
    ctx.message = ENC_CONFIG_ENABLE_EXP_HEADER;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h264_disable_explicit_header) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H264;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "disableExHeader";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    EXPECT_EQ(hb_mm_mc_get_explicit_header_config(context,
        &ctx.enable_explicit_header), 0);
    EXPECT_EQ(ctx.enable_explicit_header, 1);
    ctx.enable_explicit_header = 0;
    ctx.message = ENC_CONFIG_ENABLE_EXP_HEADER;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest,
    test_encoding_case_h264_enable_explicit_header_and_req_header) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H264;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "enableExHeaderAndReqHeader";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    EXPECT_EQ(hb_mm_mc_get_explicit_header_config(context,
        &ctx.enable_explicit_header), 0);
    EXPECT_EQ(ctx.enable_explicit_header, 1);
    ctx.enable_explicit_header = 1;
    ctx.force_idr_header_num = 0;
    ctx.force_idr_header = 1;
    ctx.message = (ENC_CONFIG_MESSAGE)
        (ENC_CONFIG_REQUEST_IDR_HEADER | ENC_CONFIG_ENABLE_EXP_HEADER);
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h265_req_idr) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "reqIdr";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;
    params->h265_enc_config.wpp_enable = 1;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 1;
    params->gop_params.gop_preset_idx = 6;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.req_idr_num = 7;
    ctx.message = ENC_CONFIG_REQUEST_IDR;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h265_req_idr_header_1) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "reqIdrHeader";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;
    params->h265_enc_config.wpp_enable = 1;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.force_idr_header_num = 0;
    ctx.force_idr_header = 1;
    ctx.message = ENC_CONFIG_REQUEST_IDR_HEADER;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h265_req_idr_header_2) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "reqIdrHeader2";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;
    params->h265_enc_config.wpp_enable = 1;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 1;
    params->gop_params.gop_preset_idx = 1;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.force_idr_header_num = 0;
    ctx.force_idr_header = 2;
    ctx.message = ENC_CONFIG_REQUEST_IDR_HEADER;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h265_req_idr_header_3) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "reqIdrHeader3";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;
    params->h265_enc_config.wpp_enable = 1;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
#ifdef J5
    ctx.force_idr_header_num = 0;
#else
    ctx.force_idr_header_num = 35;
#endif
    ctx.force_idr_header = 0;
    ctx.message = ENC_CONFIG_REQUEST_IDR_HEADER;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h265_enable_explicit_header) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "enableExHeader";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;
    params->h265_enc_config.wpp_enable = 1;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    EXPECT_EQ(hb_mm_mc_get_explicit_header_config(context,
        &ctx.enable_explicit_header), 0);
    EXPECT_EQ(ctx.enable_explicit_header, 1);
    ctx.enable_explicit_header = 1;
    ctx.message = ENC_CONFIG_ENABLE_EXP_HEADER;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h265_disable_explicit_header) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "disableExHeader";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;
    params->h265_enc_config.wpp_enable = 1;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    EXPECT_EQ(hb_mm_mc_get_explicit_header_config(context,
        &ctx.enable_explicit_header), 0);
    EXPECT_EQ(ctx.enable_explicit_header, 1);
    ctx.enable_explicit_header = 0;
    ctx.message = ENC_CONFIG_ENABLE_EXP_HEADER;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest,
	test_encoding_case_h265_enable_explicit_header_and_req_header) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "enableExHeaderAndReqHeader";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;
    params->h265_enc_config.wpp_enable = 1;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    EXPECT_EQ(hb_mm_mc_get_explicit_header_config(context,
        &ctx.enable_explicit_header), 0);
    EXPECT_EQ(ctx.enable_explicit_header, 1);
    ctx.enable_explicit_header = 1;
    ctx.force_idr_header_num = 0;
    ctx.force_idr_header = 1;
    ctx.message = (ENC_CONFIG_MESSAGE)
        (ENC_CONFIG_REQUEST_IDR_HEADER | ENC_CONFIG_ENABLE_EXP_HEADER);
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h264_skip_pic) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H264;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "skipPic";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 3;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.skip_pic_num = 16;
    ctx.message = ENC_CONFIG_REQUEST_IDR;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h265_skip_pic) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "skipPic";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;
    params->h265_enc_config.wpp_enable = 1;

    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 1;
    params->gop_params.gop_preset_idx = 6;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.skip_pic_num = 16;
    ctx.message = ENC_CONFIG_REQUEST_IDR;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_poll) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "poll";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = TRUE;
    params->bitstream_buf_count = 5;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.abnormal = 0;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_poll_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_async) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "async";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_async_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_encoding_case_multi_2_instance) {
    pthread_t thread_id[MAX_VPU_INSTANCE];
    void* retVal[MAX_VPU_INSTANCE];
    media_codec_context_t *context[MAX_VPU_INSTANCE];
    for (int i = 0; i < MAX_VPU_INSTANCE; i++) {
        context[i] = (media_codec_context_t *)malloc(sizeof(media_codec_context_t));
        ASSERT_NE(context[i], nullptr);
    }
    MediaCodecTestContext ctx[MAX_VPU_INSTANCE];
    mc_video_codec_enc_params_t *params;
    hb_s32 i = 0;
    char outputFileName[MAX_VPU_INSTANCE][MAX_FILE_PATH];
    char inputFileName[MAX_VPU_INSTANCE][MAX_FILE_PATH];
    char inputMd5FileName[MAX_VPU_INSTANCE][MAX_FILE_PATH];
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "multi2Inst";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);

    mTestThreadNum = 2;

    for (i = 0; i < mTestThreadNum; i++) {
        snprintf(inputFileName[i], MAX_FILE_PATH, "%s%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
        snprintf(outputFileName[i], MAX_FILE_PATH, "%s%s_%s_%d%s%s",
            dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
            i, outputSuffix, mGlobalCodecName[mTestCodec]);
        memset(context[i], 0x00, sizeof(media_codec_context_t));

        context[i]->codec_id = get_codec_id(mTestCodec);
        context[i]->encoder = TRUE;
        params = &context[i]->video_enc_params;
        params->width = mTestWidth;
        params->height = mTestHeight;
        params->pix_fmt = mTestPixFmt;
        params->frame_buf_count = 5;
        params->external_frame_buf = FALSE;
        params->bitstream_buf_count = 5;
        if (context[i]->codec_id == MEDIA_CODEC_ID_H264) {
            params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
        } else {
            params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
        }
        ASSERT_EQ(get_rc_params(context[i], &params->rc_params),
            (int32_t)0);
        params->gop_params.decoding_refresh_type = 2;
        params->gop_params.gop_preset_idx = 2;
        params->rot_degree = MC_CCW_0;
        params->mir_direction = MC_DIRECTION_NONE;
        params->frame_cropping_flag = FALSE;

        memset(&ctx[i], 0x00, sizeof(ctx[i]));
        ctx[i].context = context[i];
        ctx[i].inputFileName = inputFileName[i];
        ctx[i].outputFileName = outputFileName[i];
        ctx[i].testLog = mTestLog;
        ctx[i].md5Test = mTestMd5;
        if (ctx[i].md5Test) {
            char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
            snprintf(inputMd5FileName[i], MAX_FILE_PATH, "%s%s_%s_%d_%s%s",
                dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
                dedicatedSuffix, i, mGlobalCodecName[mTestCodec], inputMd5Suffix);
            ctx[i].inputMd5FileName = inputMd5FileName[i];
        }
        pthread_create(&thread_id[i], NULL, (void* (*)(void*))do_sync_encoding, &ctx[i]);
    }

    for (i = 0; i < mTestThreadNum; i++) {
        pthread_join(thread_id[i], &retVal[i]);
        printf("%s thread %d return = %ld\n", TAG, i, (intptr_t)retVal[i]);
    }

    for (i = 0; i < MAX_VPU_INSTANCE; i++) {
        if (context[i] != NULL) {
            free(context[i]);
        }
    }
}

TEST_F(MediaCodecTest, test_encoding_case_multi_4_instance) {
    pthread_t thread_id[MAX_VPU_INSTANCE];
    void* retVal[MAX_VPU_INSTANCE];
    media_codec_context_t *context[MAX_VPU_INSTANCE];
    for (int i = 0; i < MAX_VPU_INSTANCE; i++) {
        context[i] = (media_codec_context_t *)malloc(sizeof(media_codec_context_t));
        ASSERT_NE(context[i], nullptr);
    }
    MediaCodecTestContext ctx[MAX_VPU_INSTANCE];
    mc_video_codec_enc_params_t *params;
    hb_s32 i = 0;
    char outputFileName[MAX_VPU_INSTANCE][MAX_FILE_PATH];
    char inputFileName[MAX_VPU_INSTANCE][MAX_FILE_PATH];
    char inputMd5FileName[MAX_VPU_INSTANCE][MAX_FILE_PATH];
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "multi4Inst";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);

    mTestThreadNum = 4;

    for (i = 0; i < mTestThreadNum; i++) {
        snprintf(inputFileName[i], MAX_FILE_PATH, "%s%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
        snprintf(outputFileName[i], MAX_FILE_PATH, "%s%s_%s_%d_%s%s",
            dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
            i, outputSuffix, mGlobalCodecName[mTestCodec]);
        memset(context[i], 0x00, sizeof(media_codec_context_t));

        context[i]->codec_id = get_codec_id(mTestCodec);
        context[i]->encoder = TRUE;
        params = &context[i]->video_enc_params;
        params->width = mTestWidth;
        params->height = mTestHeight;
        params->pix_fmt = mTestPixFmt;
        params->frame_buf_count = 5;
        params->external_frame_buf = FALSE;
        params->bitstream_buf_count = 5;
        if (context[i]->codec_id == MEDIA_CODEC_ID_H264) {
            params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
        } else {
            params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
        }
        ASSERT_EQ(get_rc_params(context[i], &params->rc_params),
            (int32_t)0);
        params->gop_params.decoding_refresh_type = 2;
        params->gop_params.gop_preset_idx = 2;
        params->rot_degree = MC_CCW_0;
        params->mir_direction = MC_DIRECTION_NONE;
        params->frame_cropping_flag = FALSE;

        memset(&ctx[i], 0x00, sizeof(ctx[i]));
        ctx[i].context = context[i];
        ctx[i].inputFileName = inputFileName[i];
        ctx[i].outputFileName = outputFileName[i];
        ctx[i].testLog = mTestLog;
        ctx[i].md5Test = mTestMd5;
        if (ctx[i].md5Test) {
            char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
            snprintf(inputMd5FileName[i], MAX_FILE_PATH, "%s%s_%s_%d_%s%s",
                dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
                dedicatedSuffix, i, mGlobalCodecName[mTestCodec], inputMd5Suffix);
            ctx[i].inputMd5FileName = inputMd5FileName[i];
        }
        pthread_create(&thread_id[i], NULL, (void* (*)(void*))do_sync_encoding, &ctx[i]);
    }

    for (i = 0; i < mTestThreadNum; i++) {
        pthread_join(thread_id[i], &retVal[i]);
        printf("%s thread %d return = %ld\n", TAG, i, (intptr_t)retVal[i]);
    }
    for (i = 0; i < MAX_VPU_INSTANCE; i++) {
        if (context[i] != NULL) {
            free(context[i]);
        }
    }
}

TEST_F(MediaCodecTest, test_encoding_case_multi_h264_h265) {
    pthread_t thread_id[MAX_VPU_INSTANCE];
    void* retVal[MAX_VPU_INSTANCE];
    media_codec_context_t *context[MAX_VPU_INSTANCE];
    for (int i = 0; i < MAX_VPU_INSTANCE; i++) {
        context[i] = (media_codec_context_t *)malloc(sizeof(media_codec_context_t));
        ASSERT_NE(context[i], nullptr);
    }
    MediaCodecTestContext ctx[MAX_VPU_INSTANCE];
    mc_video_codec_enc_params_t *params;
    hb_s32 i = 0;
    char outputFileName[MAX_VPU_INSTANCE][MAX_FILE_PATH];
    char inputFileName[MAX_VPU_INSTANCE][MAX_FILE_PATH];
    char inputMd5FileName[MAX_VPU_INSTANCE][MAX_FILE_PATH];
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "multi2Inst";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);

    mTestThreadNum = 2;

    for (i = 0; i < mTestThreadNum; i++) {
        mTestCodec = i < 1 ? TEST_CODEC_ID_H265 : TEST_CODEC_ID_H264;
        snprintf(inputFileName[i], MAX_FILE_PATH, "%s%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
        snprintf(outputFileName[i], MAX_FILE_PATH, "%s%s_%s_%d_%s%s",
            dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
            i, outputSuffix, mGlobalCodecName[mTestCodec]);
        memset(context[i], 0x00, sizeof(media_codec_context_t));

        context[i]->codec_id = get_codec_id(mTestCodec);
        context[i]->encoder = TRUE;
        params = &context[i]->video_enc_params;
        params->width = mTestWidth;
        params->height = mTestHeight;
        params->pix_fmt = mTestPixFmt;
        params->frame_buf_count = 5;
        params->external_frame_buf = FALSE;
        params->bitstream_buf_count = 5;
        if (context[i]->codec_id == MEDIA_CODEC_ID_H264) {
            params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
        } else {
            params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
        }
        ASSERT_EQ(get_rc_params(context[i], &params->rc_params),
            (int32_t)0);
        params->gop_params.decoding_refresh_type = 2;
        params->gop_params.gop_preset_idx = 2;
        params->rot_degree = MC_CCW_0;
        params->mir_direction = MC_DIRECTION_NONE;
        params->frame_cropping_flag = FALSE;

        memset(&ctx[i], 0x00, sizeof(ctx[i]));
        ctx[i].context = context[i];
        ctx[i].inputFileName = inputFileName[i];
        ctx[i].outputFileName = outputFileName[i];
        ctx[i].testLog = mTestLog;
        ctx[i].md5Test = mTestMd5;
        if (ctx[i].md5Test) {
            char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
            snprintf(inputMd5FileName[i], MAX_FILE_PATH, "%s%s_%s_%d_%s%s",
                dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
                dedicatedSuffix, i, mGlobalCodecName[mTestCodec], inputMd5Suffix);
            ctx[i].inputMd5FileName = inputMd5FileName[i];
        }
        pthread_create(&thread_id[i], NULL, (void* (*)(void*))do_sync_encoding, &ctx[i]);
    }

    for (i = 0; i < mTestThreadNum; i++) {
        pthread_join(thread_id[i], &retVal[i]);
        printf("%s thread %d return = %ld\n", TAG, i, (intptr_t)retVal[i]);
    }
    for (i = 0; i < MAX_VPU_INSTANCE; i++) {
        if (context[i] != NULL) {
            free(context[i]);
        }
    }
}

TEST_F(MediaCodecTest, test_encoding_case_multi_2_h264_2_h265) {
    pthread_t thread_id[MAX_VPU_INSTANCE];
    void* retVal[MAX_VPU_INSTANCE];
    media_codec_context_t *context[MAX_VPU_INSTANCE];
    for (int i = 0; i < MAX_VPU_INSTANCE; i++) {
        context[i] = (media_codec_context_t *)malloc(sizeof(media_codec_context_t));
        ASSERT_NE(context[i], nullptr);
    }
    MediaCodecTestContext ctx[MAX_VPU_INSTANCE];
    mc_video_codec_enc_params_t *params;
    hb_s32 i = 0;
    char outputFileName[MAX_VPU_INSTANCE][MAX_FILE_PATH];
    char inputFileName[MAX_VPU_INSTANCE][MAX_FILE_PATH];
    char inputMd5FileName[MAX_VPU_INSTANCE][MAX_FILE_PATH];
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "multi2Inst";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);

    mTestThreadNum = 4;

    for (i = 0; i < mTestThreadNum; i++) {
        mTestCodec = i < 2 ? TEST_CODEC_ID_H265 : TEST_CODEC_ID_H264;
        snprintf(inputFileName[i], MAX_FILE_PATH, "%s%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
        snprintf(outputFileName[i], MAX_FILE_PATH, "%s%s_%s_%d_%s%s",
            dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
            i, outputSuffix, mGlobalCodecName[mTestCodec]);
        memset(context[i], 0x00, sizeof(media_codec_context_t));

        context[i]->codec_id = get_codec_id(mTestCodec);
        context[i]->encoder = TRUE;
        params = &context[i]->video_enc_params;
        params->width = mTestWidth;
        params->height = mTestHeight;
        params->pix_fmt = mTestPixFmt;
        params->frame_buf_count = 5;
        params->external_frame_buf = FALSE;
        params->bitstream_buf_count = 5;
        if (context[i]->codec_id == MEDIA_CODEC_ID_H264) {
            params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
        } else {
            params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
        }
        ASSERT_EQ(get_rc_params(context[i], &params->rc_params),
            (int32_t)0);
        params->gop_params.decoding_refresh_type = 2;
        params->gop_params.gop_preset_idx = 2;
        params->rot_degree = MC_CCW_0;
        params->mir_direction = MC_DIRECTION_NONE;
        params->frame_cropping_flag = FALSE;

        memset(&ctx[i], 0x00, sizeof(ctx[i]));
        ctx[i].context = context[i];
        ctx[i].inputFileName = inputFileName[i];
        ctx[i].outputFileName = outputFileName[i];
        ctx[i].testLog = mTestLog;
        ctx[i].md5Test = mTestMd5;
        if (ctx[i].md5Test) {
            char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
            snprintf(inputMd5FileName[i], MAX_FILE_PATH, "%s%s_%s_%d_%s%s",
                dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
                dedicatedSuffix, i, mGlobalCodecName[mTestCodec], inputMd5Suffix);
            ctx[i].inputMd5FileName = inputMd5FileName[i];
        }
        pthread_create(&thread_id[i], NULL, (void* (*)(void*))do_sync_encoding, &ctx[i]);
    }

    for (i = 0; i < mTestThreadNum; i++) {
        pthread_join(thread_id[i], &retVal[i]);
        printf("%s thread %d return = %ld\n", TAG, i, (intptr_t)retVal[i]);
    }
    for (i = 0; i < MAX_VPU_INSTANCE; i++) {
        if (context[i] != NULL) {
            free(context[i]);
        }
    }
}

TEST_F(MediaCodecTest, test_decoding_case_h264_320x240_420p) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestWidth = 320;
    mTestHeight = 240;
    mTestPixFmt = MC_PIXEL_FORMAT_YUV420P;
    mTestFeedMode = MC_FEEDING_MODE_FRAME_SIZE;
    mTestCodec = TEST_CODEC_ID_H264;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "";
    char inputSuffix[MAX_FILE_PATH] = "normal.";
    char outputSuffix[MAX_FILE_PATH] = ".yuv";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, inputSuffix, mGlobalCodecName[mTestCodec]);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        mGlobalCodecName[mTestCodec], outputSuffix);
    mc_video_codec_dec_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = FALSE;
    params = &context->video_dec_params;
    params->feed_mode = mTestFeedMode;
    params->pix_fmt = mTestPixFmt;
    params->bitstream_buf_size = mTestWidth * mTestHeight * 3 / 2;
    params->bitstream_buf_count = 6;
    params->frame_buf_count = 6;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->h264_dec_config.bandwidth_Opt = TRUE;
        params->h264_dec_config.reorder_enable = TRUE;
        params->h264_dec_config.skip_mode = 0;
    } else {
        params->h265_dec_config.bandwidth_Opt = TRUE;
        params->h265_dec_config.reorder_enable = TRUE;
        params->h265_dec_config.skip_mode = 0;
        params->h265_dec_config.cra_as_bla = FALSE;
        params->h265_dec_config.dec_temporal_id_mode = 0;
        params->h265_dec_config.target_dec_temporal_id_plus1 = 0;
    }

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(dedicatedSuffix, MAX_FILE_PATH, "%s", "dec");
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_decoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_decoding_case_h264_352x288_420p) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestWidth = 352;
    mTestHeight = 288;
    mTestPixFmt = MC_PIXEL_FORMAT_YUV420P;
    mTestFeedMode = MC_FEEDING_MODE_FRAME_SIZE;
    mTestCodec = TEST_CODEC_ID_H264;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "";
    char inputSuffix[MAX_FILE_PATH] = "normal.";
    char outputSuffix[MAX_FILE_PATH] = ".yuv";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, inputSuffix, mGlobalCodecName[mTestCodec]);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        mGlobalCodecName[mTestCodec], outputSuffix);
    mc_video_codec_dec_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = FALSE;
    params = &context->video_dec_params;
    params->feed_mode = mTestFeedMode;
    params->pix_fmt = mTestPixFmt;
    params->bitstream_buf_size = mTestWidth * mTestHeight * 3 / 2;
    params->bitstream_buf_count = 6;
    params->frame_buf_count = 6;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->h264_dec_config.bandwidth_Opt = TRUE;
        params->h264_dec_config.reorder_enable = TRUE;
        params->h264_dec_config.skip_mode = 0;
    } else {
        params->h265_dec_config.bandwidth_Opt = TRUE;
        params->h265_dec_config.reorder_enable = TRUE;
        params->h265_dec_config.skip_mode = 0;
        params->h265_dec_config.cra_as_bla = FALSE;
        params->h265_dec_config.dec_temporal_id_mode = 0;
        params->h265_dec_config.target_dec_temporal_id_plus1 = 0;
    }

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(dedicatedSuffix, MAX_FILE_PATH, "%s", "dec");
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_decoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_decoding_case_h264_640x368_420p) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestWidth = 640;
    mTestHeight = 368;
    mTestPixFmt = MC_PIXEL_FORMAT_YUV420P;
    mTestFeedMode = MC_FEEDING_MODE_FRAME_SIZE;
    mTestCodec = TEST_CODEC_ID_H264;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "";
    char inputSuffix[MAX_FILE_PATH] = "normal.";
    char outputSuffix[MAX_FILE_PATH] = ".yuv";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, inputSuffix, mGlobalCodecName[mTestCodec]);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        mGlobalCodecName[mTestCodec], outputSuffix);
    mc_video_codec_dec_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = FALSE;
    params = &context->video_dec_params;
    params->feed_mode = mTestFeedMode;
    params->pix_fmt = mTestPixFmt;
    params->bitstream_buf_size = mTestWidth * mTestHeight * 3 / 2;
    params->bitstream_buf_count = 6;
    params->frame_buf_count = 6;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->h264_dec_config.bandwidth_Opt = TRUE;
        params->h264_dec_config.reorder_enable = TRUE;
        params->h264_dec_config.skip_mode = 0;
    } else {
        params->h265_dec_config.bandwidth_Opt = TRUE;
        params->h265_dec_config.reorder_enable = TRUE;
        params->h265_dec_config.skip_mode = 0;
        params->h265_dec_config.cra_as_bla = FALSE;
        params->h265_dec_config.dec_temporal_id_mode = 0;
        params->h265_dec_config.target_dec_temporal_id_plus1 = 0;
    }

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(dedicatedSuffix, MAX_FILE_PATH, "%s", "dec");
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_decoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_decoding_case_h264_640x480_420p) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestWidth = 640;
    mTestHeight = 480;
    mTestPixFmt = MC_PIXEL_FORMAT_YUV420P;
    mTestFeedMode = MC_FEEDING_MODE_FRAME_SIZE;
    mTestCodec = TEST_CODEC_ID_H264;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "";
    char inputSuffix[MAX_FILE_PATH] = "normal.";
    char outputSuffix[MAX_FILE_PATH] = ".yuv";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, inputSuffix, mGlobalCodecName[mTestCodec]);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        mGlobalCodecName[mTestCodec], outputSuffix);
    mc_video_codec_dec_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = FALSE;
    params = &context->video_dec_params;
    params->feed_mode = mTestFeedMode;
    params->pix_fmt = mTestPixFmt;
    params->bitstream_buf_size = mTestWidth * mTestHeight * 3 / 2;
    params->bitstream_buf_count = 6;
    params->frame_buf_count = 6;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->h264_dec_config.bandwidth_Opt = TRUE;
        params->h264_dec_config.reorder_enable = TRUE;
        params->h264_dec_config.skip_mode = 0;
    } else {
        params->h265_dec_config.bandwidth_Opt = TRUE;
        params->h265_dec_config.reorder_enable = TRUE;
        params->h265_dec_config.skip_mode = 0;
        params->h265_dec_config.cra_as_bla = FALSE;
        params->h265_dec_config.dec_temporal_id_mode = 0;
        params->h265_dec_config.target_dec_temporal_id_plus1 = 0;
    }

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(dedicatedSuffix, MAX_FILE_PATH, "%s", "dec");
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_decoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_decoding_case_h264_1280x720_420p) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestWidth = 1280;
    mTestHeight = 720;
    mTestPixFmt = MC_PIXEL_FORMAT_YUV420P;
    mTestFeedMode = MC_FEEDING_MODE_FRAME_SIZE;
    mTestCodec = TEST_CODEC_ID_H264;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "";
    char inputSuffix[MAX_FILE_PATH] = "normal.";
    char outputSuffix[MAX_FILE_PATH] = ".yuv";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, inputSuffix, mGlobalCodecName[mTestCodec]);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        mGlobalCodecName[mTestCodec], outputSuffix);
    mc_video_codec_dec_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = FALSE;
    params = &context->video_dec_params;
    params->feed_mode = mTestFeedMode;
    params->pix_fmt = mTestPixFmt;
    params->bitstream_buf_size = mTestWidth * mTestHeight * 3 / 2;
    params->bitstream_buf_count = 6;
    params->frame_buf_count = 6;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->h264_dec_config.bandwidth_Opt = TRUE;
        params->h264_dec_config.reorder_enable = TRUE;
        params->h264_dec_config.skip_mode = 0;
    } else {
        params->h265_dec_config.bandwidth_Opt = TRUE;
        params->h265_dec_config.reorder_enable = TRUE;
        params->h265_dec_config.skip_mode = 0;
        params->h265_dec_config.cra_as_bla = FALSE;
        params->h265_dec_config.dec_temporal_id_mode = 0;
        params->h265_dec_config.target_dec_temporal_id_plus1 = 0;
    }

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(dedicatedSuffix, MAX_FILE_PATH, "%s", "dec");
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_decoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_decoding_case_h264_1920x1080_420p) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestWidth = 1920;
    mTestHeight = 1080;
    mTestPixFmt = MC_PIXEL_FORMAT_YUV420P;
    mTestFeedMode = MC_FEEDING_MODE_FRAME_SIZE;
    mTestCodec = TEST_CODEC_ID_H264;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "";
    char inputSuffix[MAX_FILE_PATH] = "normal.";
    char outputSuffix[MAX_FILE_PATH] = ".yuv";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, inputSuffix, mGlobalCodecName[mTestCodec]);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        mGlobalCodecName[mTestCodec], outputSuffix);
    mc_video_codec_dec_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = FALSE;
    params = &context->video_dec_params;
    params->feed_mode = mTestFeedMode;
    params->pix_fmt = mTestPixFmt;
    params->bitstream_buf_size = mTestWidth * mTestHeight * 3 / 2;
    params->bitstream_buf_count = 6;
    params->frame_buf_count = 6;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->h264_dec_config.bandwidth_Opt = TRUE;
        params->h264_dec_config.reorder_enable = TRUE;
        params->h264_dec_config.skip_mode = 0;
    } else {
        params->h265_dec_config.bandwidth_Opt = TRUE;
        params->h265_dec_config.reorder_enable = TRUE;
        params->h265_dec_config.skip_mode = 0;
        params->h265_dec_config.cra_as_bla = FALSE;
        params->h265_dec_config.dec_temporal_id_mode = 0;
        params->h265_dec_config.target_dec_temporal_id_plus1 = 0;
    }

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(dedicatedSuffix, MAX_FILE_PATH, "%s", "dec");
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_decoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_decoding_case_h264_3840x2160_420p) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestWidth = 3840;
    mTestHeight = 2160;
    mTestPixFmt = MC_PIXEL_FORMAT_YUV420P;
    mTestFeedMode = MC_FEEDING_MODE_FRAME_SIZE;
    mTestCodec = TEST_CODEC_ID_H264;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "";
    char inputSuffix[MAX_FILE_PATH] = "normal.";
    char outputSuffix[MAX_FILE_PATH] = ".yuv";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, inputSuffix, mGlobalCodecName[mTestCodec]);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        mGlobalCodecName[mTestCodec], outputSuffix);
    mc_video_codec_dec_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = FALSE;
    params = &context->video_dec_params;
    params->feed_mode = mTestFeedMode;
    params->pix_fmt = mTestPixFmt;
    params->bitstream_buf_size = mTestWidth * mTestHeight * 3 / 2;
    params->bitstream_buf_count = 3;
    params->frame_buf_count = 3;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->h264_dec_config.bandwidth_Opt = TRUE;
        params->h264_dec_config.reorder_enable = TRUE;
        params->h264_dec_config.skip_mode = 0;
    } else {
        params->h265_dec_config.bandwidth_Opt = TRUE;
        params->h265_dec_config.reorder_enable = TRUE;
        params->h265_dec_config.skip_mode = 0;
        params->h265_dec_config.cra_as_bla = FALSE;
        params->h265_dec_config.dec_temporal_id_mode = 0;
        params->h265_dec_config.target_dec_temporal_id_plus1 = 0;
    }

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(dedicatedSuffix, MAX_FILE_PATH, "%s", "dec");
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_decoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_decoding_case_h264_3840x2160_420p_vlc_buf) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestWidth = 3840;
    mTestHeight = 2160;
    mTestPixFmt = MC_PIXEL_FORMAT_YUV420P;
    mTestFeedMode = MC_FEEDING_MODE_FRAME_SIZE;
    mTestCodec = TEST_CODEC_ID_H264;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "vlc_";
    char inputSuffix[MAX_FILE_PATH] = "normal.";
    char outputSuffix[MAX_FILE_PATH] = ".yuv";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, inputSuffix, mGlobalCodecName[mTestCodec]);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        mGlobalCodecName[mTestCodec], outputSuffix);
    mc_video_codec_dec_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = FALSE;
    params = &context->video_dec_params;
    params->feed_mode = mTestFeedMode;
    params->pix_fmt = mTestPixFmt;
    params->bitstream_buf_size = mTestWidth * mTestHeight * 3 / 2;
    params->bitstream_buf_count = 3;
    params->frame_buf_count = 3;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->h264_dec_config.bandwidth_Opt = TRUE;
        params->h264_dec_config.reorder_enable = TRUE;
        params->h264_dec_config.skip_mode = 0;
    } else {
        params->h265_dec_config.bandwidth_Opt = TRUE;
        params->h265_dec_config.reorder_enable = TRUE;
        params->h265_dec_config.skip_mode = 0;
        params->h265_dec_config.cra_as_bla = FALSE;
        params->h265_dec_config.dec_temporal_id_mode = 0;
        params->h265_dec_config.target_dec_temporal_id_plus1 = 0;
    }

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.vlc_buf_size = 10000000;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(dedicatedSuffix, MAX_FILE_PATH, "%s", "dec");
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_decoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_decoding_case_h265_320x240_420p) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestWidth = 320;
    mTestHeight = 240;
    mTestPixFmt = MC_PIXEL_FORMAT_YUV420P;
    mTestFeedMode = MC_FEEDING_MODE_FRAME_SIZE;
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "";
    char inputSuffix[MAX_FILE_PATH] = "normal.";
    char outputSuffix[MAX_FILE_PATH] = ".yuv";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, inputSuffix, mGlobalCodecName[mTestCodec]);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        mGlobalCodecName[mTestCodec], outputSuffix);
    mc_video_codec_dec_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = FALSE;
    params = &context->video_dec_params;
    params->feed_mode = mTestFeedMode;
    params->pix_fmt = mTestPixFmt;
    params->bitstream_buf_size = mTestWidth * mTestHeight * 3 / 2;
    params->bitstream_buf_count = 6;
    params->frame_buf_count = 6;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->h264_dec_config.bandwidth_Opt = TRUE;
        params->h264_dec_config.reorder_enable = TRUE;
        params->h264_dec_config.skip_mode = 0;
    } else {
        params->h265_dec_config.bandwidth_Opt = TRUE;
        params->h265_dec_config.reorder_enable = TRUE;
        params->h265_dec_config.skip_mode = 0;
        params->h265_dec_config.cra_as_bla = FALSE;
        params->h265_dec_config.dec_temporal_id_mode = 0;
        params->h265_dec_config.target_dec_temporal_id_plus1 = 0;
    }

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(dedicatedSuffix, MAX_FILE_PATH, "%s", "dec");
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_decoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_decoding_case_h265_352x288_420p) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestWidth = 352;
    mTestHeight = 288;
    mTestPixFmt = MC_PIXEL_FORMAT_YUV420P;
    mTestFeedMode = MC_FEEDING_MODE_FRAME_SIZE;
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "";
    char inputSuffix[MAX_FILE_PATH] = "normal.";
    char outputSuffix[MAX_FILE_PATH] = ".yuv";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, inputSuffix, mGlobalCodecName[mTestCodec]);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        mGlobalCodecName[mTestCodec], outputSuffix);
    mc_video_codec_dec_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = FALSE;
    params = &context->video_dec_params;
    params->feed_mode = mTestFeedMode;
    params->pix_fmt = mTestPixFmt;
    params->bitstream_buf_size = mTestWidth * mTestHeight * 3 / 2;
    params->bitstream_buf_count = 6;
    params->frame_buf_count = 6;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->h264_dec_config.bandwidth_Opt = TRUE;
        params->h264_dec_config.reorder_enable = TRUE;
        params->h264_dec_config.skip_mode = 0;
    } else {
        params->h265_dec_config.bandwidth_Opt = TRUE;
        params->h265_dec_config.reorder_enable = TRUE;
        params->h265_dec_config.skip_mode = 0;
        params->h265_dec_config.cra_as_bla = FALSE;
        params->h265_dec_config.dec_temporal_id_mode = 0;
        params->h265_dec_config.target_dec_temporal_id_plus1 = 0;
    }

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(dedicatedSuffix, MAX_FILE_PATH, "%s", "dec");
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_decoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_decoding_case_h265_640x368_420p) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestWidth = 640;
    mTestHeight = 368;
    mTestPixFmt = MC_PIXEL_FORMAT_YUV420P;
    mTestFeedMode = MC_FEEDING_MODE_FRAME_SIZE;
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "";
    char inputSuffix[MAX_FILE_PATH] = "normal.";
    char outputSuffix[MAX_FILE_PATH] = ".yuv";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, inputSuffix, mGlobalCodecName[mTestCodec]);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        mGlobalCodecName[mTestCodec], outputSuffix);
    mc_video_codec_dec_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = FALSE;
    params = &context->video_dec_params;
    params->feed_mode = mTestFeedMode;
    params->pix_fmt = mTestPixFmt;
    params->bitstream_buf_size = mTestWidth * mTestHeight * 3 / 2;
    params->bitstream_buf_count = 6;
    params->frame_buf_count = 6;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->h264_dec_config.bandwidth_Opt = TRUE;
        params->h264_dec_config.reorder_enable = TRUE;
        params->h264_dec_config.skip_mode = 0;
    } else {
        params->h265_dec_config.bandwidth_Opt = TRUE;
        params->h265_dec_config.reorder_enable = TRUE;
        params->h265_dec_config.skip_mode = 0;
        params->h265_dec_config.cra_as_bla = FALSE;
        params->h265_dec_config.dec_temporal_id_mode = 0;
        params->h265_dec_config.target_dec_temporal_id_plus1 = 0;
    }

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(dedicatedSuffix, MAX_FILE_PATH, "%s", "dec");
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_decoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_decoding_case_h265_640x480_420p) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestWidth = 640;
    mTestHeight = 480;
    mTestPixFmt = MC_PIXEL_FORMAT_YUV420P;
    mTestFeedMode = MC_FEEDING_MODE_FRAME_SIZE;
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "";
    char inputSuffix[MAX_FILE_PATH] = "normal.";
    char outputSuffix[MAX_FILE_PATH] = ".yuv";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, inputSuffix, mGlobalCodecName[mTestCodec]);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        mGlobalCodecName[mTestCodec], outputSuffix);
    mc_video_codec_dec_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = FALSE;
    params = &context->video_dec_params;
    params->feed_mode = mTestFeedMode;
    params->pix_fmt = mTestPixFmt;
    params->bitstream_buf_size = mTestWidth * mTestHeight * 3 / 2;
    params->bitstream_buf_count = 6;
    params->frame_buf_count = 8;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->h264_dec_config.bandwidth_Opt = TRUE;
        params->h264_dec_config.reorder_enable = TRUE;
        params->h264_dec_config.skip_mode = 0;
    } else {
        params->h265_dec_config.bandwidth_Opt = TRUE;
        params->h265_dec_config.reorder_enable = TRUE;
        params->h265_dec_config.skip_mode = 0;
        params->h265_dec_config.cra_as_bla = FALSE;
        params->h265_dec_config.dec_temporal_id_mode = 0;
        params->h265_dec_config.target_dec_temporal_id_plus1 = 0;
    }

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(dedicatedSuffix, MAX_FILE_PATH, "%s", "dec");
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_decoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_decoding_case_h265_1280x720_420p) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestWidth = 1280;
    mTestHeight = 720;
    mTestPixFmt = MC_PIXEL_FORMAT_YUV420P;
    mTestFeedMode = MC_FEEDING_MODE_FRAME_SIZE;
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "";
    char inputSuffix[MAX_FILE_PATH] = "normal.";
    char outputSuffix[MAX_FILE_PATH] = ".yuv";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, inputSuffix, mGlobalCodecName[mTestCodec]);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        mGlobalCodecName[mTestCodec], outputSuffix);
    mc_video_codec_dec_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = FALSE;
    params = &context->video_dec_params;
    params->feed_mode = mTestFeedMode;
    params->pix_fmt = mTestPixFmt;
    params->bitstream_buf_size = mTestWidth * mTestHeight * 3 / 2;
    params->bitstream_buf_count = 6;
    params->frame_buf_count = 6;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->h264_dec_config.bandwidth_Opt = TRUE;
        params->h264_dec_config.reorder_enable = TRUE;
        params->h264_dec_config.skip_mode = 0;
    } else {
        params->h265_dec_config.bandwidth_Opt = TRUE;
        params->h265_dec_config.reorder_enable = TRUE;
        params->h265_dec_config.skip_mode = 0;
        params->h265_dec_config.cra_as_bla = FALSE;
        params->h265_dec_config.dec_temporal_id_mode = 0;
        params->h265_dec_config.target_dec_temporal_id_plus1 = 0;
    }

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(dedicatedSuffix, MAX_FILE_PATH, "%s", "dec");
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_decoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_decoding_case_h265_1920x1080_420p) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestWidth = 1920;
    mTestHeight = 1080;
    mTestPixFmt = MC_PIXEL_FORMAT_YUV420P;
    mTestFeedMode = MC_FEEDING_MODE_FRAME_SIZE;
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "";
    char inputSuffix[MAX_FILE_PATH] = "normal.";
    char outputSuffix[MAX_FILE_PATH] = ".yuv";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, inputSuffix, mGlobalCodecName[mTestCodec]);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        mGlobalCodecName[mTestCodec], outputSuffix);
    mc_video_codec_dec_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = FALSE;
    params = &context->video_dec_params;
    params->feed_mode = mTestFeedMode;
    params->pix_fmt = mTestPixFmt;
    params->bitstream_buf_size = mTestWidth * mTestHeight * 3 / 2;
    params->bitstream_buf_count = 6;
    params->frame_buf_count = 6;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->h264_dec_config.bandwidth_Opt = TRUE;
        params->h264_dec_config.reorder_enable = TRUE;
        params->h264_dec_config.skip_mode = 0;
    } else {
        params->h265_dec_config.bandwidth_Opt = TRUE;
        params->h265_dec_config.reorder_enable = TRUE;
        params->h265_dec_config.skip_mode = 0;
        params->h265_dec_config.cra_as_bla = FALSE;
        params->h265_dec_config.dec_temporal_id_mode = 0;
        params->h265_dec_config.target_dec_temporal_id_plus1 = 0;
    }

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(dedicatedSuffix, MAX_FILE_PATH, "%s", "dec");
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_decoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_decoding_case_h265_3840x2160_420p) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestWidth = 3840;
    mTestHeight = 2160;
    mTestPixFmt = MC_PIXEL_FORMAT_YUV420P;
    mTestFeedMode = MC_FEEDING_MODE_FRAME_SIZE;
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "";
    char inputSuffix[MAX_FILE_PATH] = "normal.";
    char outputSuffix[MAX_FILE_PATH] = ".yuv";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, inputSuffix, mGlobalCodecName[mTestCodec]);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        mGlobalCodecName[mTestCodec], outputSuffix);
    mc_video_codec_dec_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = FALSE;
    params = &context->video_dec_params;
    params->feed_mode = mTestFeedMode;
    params->pix_fmt = mTestPixFmt;
    params->bitstream_buf_size = mTestWidth * mTestHeight * 3 / 2;
    params->bitstream_buf_count = 4;
    params->frame_buf_count = 4;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->h264_dec_config.bandwidth_Opt = TRUE;
        params->h264_dec_config.reorder_enable = TRUE;
        params->h264_dec_config.skip_mode = 0;
    } else {
        params->h265_dec_config.bandwidth_Opt = TRUE;
        params->h265_dec_config.reorder_enable = TRUE;
        params->h265_dec_config.skip_mode = 0;
        params->h265_dec_config.cra_as_bla = FALSE;
        params->h265_dec_config.dec_temporal_id_mode = 0;
        params->h265_dec_config.target_dec_temporal_id_plus1 = 0;
    }

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(dedicatedSuffix, MAX_FILE_PATH, "%s", "dec");
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_decoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_decoding_case_h265_4096x2160_420p) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestWidth = 4096;
    mTestHeight = 2160;
    mTestPixFmt = MC_PIXEL_FORMAT_YUV420P;
    mTestFeedMode = MC_FEEDING_MODE_FRAME_SIZE;
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "";
    char inputSuffix[MAX_FILE_PATH] = "normal.";
    char outputSuffix[MAX_FILE_PATH] = ".yuv";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, inputSuffix, mGlobalCodecName[mTestCodec]);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        mGlobalCodecName[mTestCodec], outputSuffix);
    mc_video_codec_dec_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = FALSE;
    params = &context->video_dec_params;
    params->feed_mode = mTestFeedMode;
    params->pix_fmt = mTestPixFmt;
    params->bitstream_buf_size = mTestWidth * mTestHeight * 3 / 2;
    params->bitstream_buf_count = 3;
    params->frame_buf_count = 3;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->h264_dec_config.bandwidth_Opt = TRUE;
        params->h264_dec_config.reorder_enable = TRUE;
        params->h264_dec_config.skip_mode = 0;
    } else {
        params->h265_dec_config.bandwidth_Opt = TRUE;
        params->h265_dec_config.reorder_enable = TRUE;
        params->h265_dec_config.skip_mode = 0;
        params->h265_dec_config.cra_as_bla = FALSE;
        params->h265_dec_config.dec_temporal_id_mode = 0;
        params->h265_dec_config.target_dec_temporal_id_plus1 = 0;
    }

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(dedicatedSuffix, MAX_FILE_PATH, "%s", "dec");
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_decoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_decoding_case_h264_feed_stream) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestFeedMode = MC_FEEDING_MODE_STREAM_SIZE;
    mTestCodec = TEST_CODEC_ID_H264;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "feedStream";
    char inputSuffix[MAX_FILE_PATH] = "normal.";
    char outputSuffix[MAX_FILE_PATH] = ".yuv";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, inputSuffix, mGlobalCodecName[mTestCodec]);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        mGlobalCodecName[mTestCodec], outputSuffix);
    mc_video_codec_dec_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = FALSE;
    params = &context->video_dec_params;
    params->feed_mode = mTestFeedMode;
    params->pix_fmt = mTestPixFmt;
    params->bitstream_buf_size = mTestWidth * mTestHeight * 3 / 2;
    params->bitstream_buf_count = 6;
    params->frame_buf_count = 6;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->h264_dec_config.bandwidth_Opt = TRUE;
        params->h264_dec_config.reorder_enable = TRUE;
        params->h264_dec_config.skip_mode = 0;
    } else {
        params->h265_dec_config.bandwidth_Opt = TRUE;
        params->h265_dec_config.reorder_enable = TRUE;
        params->h265_dec_config.skip_mode = 0;
        params->h265_dec_config.cra_as_bla = FALSE;
        params->h265_dec_config.dec_temporal_id_mode = 0;
        params->h265_dec_config.target_dec_temporal_id_plus1 = 0;
    }

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_decoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_decoding_case_h265_feed_stream) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestFeedMode = MC_FEEDING_MODE_STREAM_SIZE;
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "feedStream";
    char inputSuffix[MAX_FILE_PATH] = "normal.";
    char outputSuffix[MAX_FILE_PATH] = ".yuv";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, inputSuffix, mGlobalCodecName[mTestCodec]);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        mGlobalCodecName[mTestCodec], outputSuffix);
    mc_video_codec_dec_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = FALSE;
    params = &context->video_dec_params;
    params->feed_mode = mTestFeedMode;
    params->pix_fmt = mTestPixFmt;
    params->bitstream_buf_size = ((mTestWidth * mTestHeight * 3 / 2) + 0x3FF) & (~0x3FF);
    params->bitstream_buf_count = 6;
    params->frame_buf_count = 6;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->h264_dec_config.bandwidth_Opt = TRUE;
        params->h264_dec_config.reorder_enable = TRUE;
        params->h264_dec_config.skip_mode = 0;
    } else {
        params->h265_dec_config.bandwidth_Opt = TRUE;
        params->h265_dec_config.reorder_enable = TRUE;
        params->h265_dec_config.skip_mode = 0;
        params->h265_dec_config.cra_as_bla = FALSE;
        params->h265_dec_config.dec_temporal_id_mode = 0;
        params->h265_dec_config.target_dec_temporal_id_plus1 = 0;
    }

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_decoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_decoding_case_h265_feed_stream_abnormal) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestFeedMode = MC_FEEDING_MODE_STREAM_SIZE;
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "feedStream_abnormal";
    char inputSuffix[MAX_FILE_PATH] = "normal.";
    char outputSuffix[MAX_FILE_PATH] = ".yuv";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, inputSuffix, mGlobalCodecName[mTestCodec]);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        mGlobalCodecName[mTestCodec], outputSuffix);
    mc_video_codec_dec_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = FALSE;
    params = &context->video_dec_params;
    params->feed_mode = mTestFeedMode;
    params->pix_fmt = mTestPixFmt;
    params->bitstream_buf_size = ((mTestWidth * mTestHeight * 3 / 2) + 0x3FF) & (~0x3FF);
    params->bitstream_buf_count = 6;
    params->frame_buf_count = 6;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->h264_dec_config.bandwidth_Opt = TRUE;
        params->h264_dec_config.reorder_enable = TRUE;
        params->h264_dec_config.skip_mode = 0;
    } else {
        params->h265_dec_config.bandwidth_Opt = TRUE;
        params->h265_dec_config.reorder_enable = TRUE;
        params->h265_dec_config.skip_mode = 0;
        params->h265_dec_config.cra_as_bla = FALSE;
        params->h265_dec_config.dec_temporal_id_mode = 0;
        params->h265_dec_config.target_dec_temporal_id_plus1 = 0;
    }

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    ctx.feedingSize = 4096;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_decoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_decoding_case_h265_feed_external_stream) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestFeedMode = MC_FEEDING_MODE_STREAM_SIZE;
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "feedExStream";
    char inputSuffix[MAX_FILE_PATH] = "normal.";
    char outputSuffix[MAX_FILE_PATH] = ".yuv";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, inputSuffix, mGlobalCodecName[mTestCodec]);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        mGlobalCodecName[mTestCodec], outputSuffix);
    mc_video_codec_dec_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = FALSE;
    params = &context->video_dec_params;
    params->feed_mode = mTestFeedMode;
    params->pix_fmt = mTestPixFmt;
    params->bitstream_buf_size = ((mTestWidth * mTestHeight * 3 / 2) + 0x3FF) & (~0x3FF);
    params->bitstream_buf_count = 6;
    params->frame_buf_count = 6;
    params->external_bitstream_buf = TRUE;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->h264_dec_config.bandwidth_Opt = TRUE;
        params->h264_dec_config.reorder_enable = TRUE;
        params->h264_dec_config.skip_mode = 0;
    } else {
        params->h265_dec_config.bandwidth_Opt = TRUE;
        params->h265_dec_config.reorder_enable = TRUE;
        params->h265_dec_config.skip_mode = 0;
        params->h265_dec_config.cra_as_bla = FALSE;
        params->h265_dec_config.dec_temporal_id_mode = 0;
        params->h265_dec_config.target_dec_temporal_id_plus1 = 0;
    }

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_decoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_decoding_case_nv12) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestPixFmt = MC_PIXEL_FORMAT_NV12;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "decoding";
    char inputSuffix[MAX_FILE_PATH] = "normal.";
    char outputSuffix[MAX_FILE_PATH] = ".yuv";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, inputSuffix, mGlobalCodecName[mTestCodec]);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        mGlobalCodecName[mTestCodec], outputSuffix);
    mc_video_codec_dec_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = FALSE;
    params = &context->video_dec_params;
    params->feed_mode = mTestFeedMode;
    params->pix_fmt = mTestPixFmt;
    params->bitstream_buf_size = mTestWidth * mTestHeight * 3 / 2;
    params->bitstream_buf_count = 6;
    params->frame_buf_count = 6;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->h264_dec_config.bandwidth_Opt = TRUE;
        params->h264_dec_config.reorder_enable = TRUE;
        params->h264_dec_config.skip_mode = 0;
    } else {
        params->h265_dec_config.bandwidth_Opt = TRUE;
        params->h265_dec_config.reorder_enable = TRUE;
        params->h265_dec_config.skip_mode = 0;
        params->h265_dec_config.cra_as_bla = FALSE;
        params->h265_dec_config.dec_temporal_id_mode = 0;
        params->h265_dec_config.target_dec_temporal_id_plus1 = 0;
    }

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_decoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_decoding_case_nv21) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestPixFmt = MC_PIXEL_FORMAT_NV21;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "decoding";
    char inputSuffix[MAX_FILE_PATH] = "normal.";
    char outputSuffix[MAX_FILE_PATH] = ".yuv";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, inputSuffix, mGlobalCodecName[mTestCodec]);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        mGlobalCodecName[mTestCodec], outputSuffix);
    mc_video_codec_dec_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = FALSE;
    params = &context->video_dec_params;
    params->feed_mode = mTestFeedMode;
    params->pix_fmt = mTestPixFmt;
    params->bitstream_buf_size = mTestWidth * mTestHeight * 3 / 2;
    params->bitstream_buf_count = 6;
    params->frame_buf_count = 6;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->h264_dec_config.bandwidth_Opt = TRUE;
        params->h264_dec_config.reorder_enable = TRUE;
        params->h264_dec_config.skip_mode = 0;
    } else {
        params->h265_dec_config.bandwidth_Opt = TRUE;
        params->h265_dec_config.reorder_enable = TRUE;
        params->h265_dec_config.skip_mode = 0;
        params->h265_dec_config.cra_as_bla = FALSE;
        params->h265_dec_config.dec_temporal_id_mode = 0;
        params->h265_dec_config.target_dec_temporal_id_plus1 = 0;
    }

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_decoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_decoding_case_bs_size_min) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "bsSizeMin";
    char inputSuffix[MAX_FILE_PATH] = "normal.";
    char outputSuffix[MAX_FILE_PATH] = ".yuv";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, inputSuffix, mGlobalCodecName[mTestCodec]);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        mGlobalCodecName[mTestCodec], outputSuffix);
    mc_video_codec_dec_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = FALSE;
    params = &context->video_dec_params;
    params->feed_mode = mTestFeedMode;
    params->pix_fmt = mTestPixFmt;
    params->bitstream_buf_size = mTestWidth * mTestHeight * 3 / 2;
    params->bitstream_buf_count = 6;
    params->frame_buf_count = 6;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->h264_dec_config.bandwidth_Opt = TRUE;
        params->h264_dec_config.reorder_enable = TRUE;
        params->h264_dec_config.skip_mode = 0;
    } else {
        params->h265_dec_config.bandwidth_Opt = TRUE;
        params->h265_dec_config.reorder_enable = TRUE;
        params->h265_dec_config.skip_mode = 0;
        params->h265_dec_config.cra_as_bla = FALSE;
        params->h265_dec_config.dec_temporal_id_mode = 0;
        params->h265_dec_config.target_dec_temporal_id_plus1 = 0;
    }

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_decoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_decoding_case_bs_size_abnormal) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "bsSizeAbnormal";
    char inputSuffix[MAX_FILE_PATH] = "normal.";
    char outputSuffix[MAX_FILE_PATH] = ".yuv";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, inputSuffix, mGlobalCodecName[mTestCodec]);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        mGlobalCodecName[mTestCodec], outputSuffix);
    mc_video_codec_dec_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = FALSE;
    params = &context->video_dec_params;
    params->feed_mode = mTestFeedMode;
    params->pix_fmt = mTestPixFmt;
    params->bitstream_buf_size = mTestWidth * mTestHeight * 3 / 2 + 1;
    params->bitstream_buf_count = 6;
    params->frame_buf_count = 6;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->h264_dec_config.bandwidth_Opt = TRUE;
        params->h264_dec_config.reorder_enable = TRUE;
        params->h264_dec_config.skip_mode = 0;
    } else {
        params->h265_dec_config.bandwidth_Opt = TRUE;
        params->h265_dec_config.reorder_enable = TRUE;
        params->h265_dec_config.skip_mode = 0;
        params->h265_dec_config.cra_as_bla = FALSE;
        params->h265_dec_config.dec_temporal_id_mode = 0;
        params->h265_dec_config.target_dec_temporal_id_plus1 = 0;
    }

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_decoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_decoding_case_bs_size_max) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "bsSizeMax";
    char inputSuffix[MAX_FILE_PATH] = "normal.";
    char outputSuffix[MAX_FILE_PATH] = ".yuv";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, inputSuffix, mGlobalCodecName[mTestCodec]);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        mGlobalCodecName[mTestCodec], outputSuffix);
    mc_video_codec_dec_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = FALSE;
    params = &context->video_dec_params;
    params->feed_mode = mTestFeedMode;
    params->pix_fmt = mTestPixFmt;
    params->bitstream_buf_size = 20 * 1024 * 1024; // It's not the max
    params->bitstream_buf_count = 6;
    params->frame_buf_count = 6;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->h264_dec_config.bandwidth_Opt = TRUE;
        params->h264_dec_config.reorder_enable = TRUE;
        params->h264_dec_config.skip_mode = 0;
    } else {
        params->h265_dec_config.bandwidth_Opt = TRUE;
        params->h265_dec_config.reorder_enable = TRUE;
        params->h265_dec_config.skip_mode = 0;
        params->h265_dec_config.cra_as_bla = FALSE;
        params->h265_dec_config.dec_temporal_id_mode = 0;
        params->h265_dec_config.target_dec_temporal_id_plus1 = 0;
    }

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_decoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_decoding_case_bs_cnt_min) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "bsCntMin";
    char inputSuffix[MAX_FILE_PATH] = "normal.";
    char outputSuffix[MAX_FILE_PATH] = ".yuv";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, inputSuffix, mGlobalCodecName[mTestCodec]);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        mGlobalCodecName[mTestCodec], outputSuffix);
    mc_video_codec_dec_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = FALSE;
    params = &context->video_dec_params;
    params->feed_mode = mTestFeedMode;
    params->pix_fmt = mTestPixFmt;
    params->bitstream_buf_size = mTestWidth * mTestHeight * 3 / 2;
#ifdef J5
    params->bitstream_buf_count = 2;
#else
    params->bitstream_buf_count = 1;
#endif
    params->frame_buf_count = 6;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->h264_dec_config.bandwidth_Opt = TRUE;
        params->h264_dec_config.reorder_enable = TRUE;
        params->h264_dec_config.skip_mode = 0;
    } else {
        params->h265_dec_config.bandwidth_Opt = TRUE;
        params->h265_dec_config.reorder_enable = TRUE;
        params->h265_dec_config.skip_mode = 0;
        params->h265_dec_config.cra_as_bla = FALSE;
        params->h265_dec_config.dec_temporal_id_mode = 0;
        params->h265_dec_config.target_dec_temporal_id_plus1 = 0;
    }

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_decoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_decoding_case_bs_cnt_max) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "bsCntMax";
    char inputSuffix[MAX_FILE_PATH] = "normal.";
    char outputSuffix[MAX_FILE_PATH] = ".yuv";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, inputSuffix, mGlobalCodecName[mTestCodec]);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        mGlobalCodecName[mTestCodec], outputSuffix);
    mc_video_codec_dec_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = FALSE;
    params = &context->video_dec_params;
    params->feed_mode = mTestFeedMode;
    params->pix_fmt = mTestPixFmt;
    params->bitstream_buf_size = mTestWidth * mTestHeight * 3 / 2;
    params->bitstream_buf_count = 200;
    params->frame_buf_count = 6;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->h264_dec_config.bandwidth_Opt = TRUE;
        params->h264_dec_config.reorder_enable = TRUE;
        params->h264_dec_config.skip_mode = 0;
    } else {
        params->h265_dec_config.bandwidth_Opt = TRUE;
        params->h265_dec_config.reorder_enable = TRUE;
        params->h265_dec_config.skip_mode = 0;
        params->h265_dec_config.cra_as_bla = FALSE;
        params->h265_dec_config.dec_temporal_id_mode = 0;
        params->h265_dec_config.target_dec_temporal_id_plus1 = 0;
    }

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_decoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_decoding_case_fb_cnt_min) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "fbCntMin";
    char inputSuffix[MAX_FILE_PATH] = "normal.";
    char outputSuffix[MAX_FILE_PATH] = ".yuv";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, inputSuffix, mGlobalCodecName[mTestCodec]);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        mGlobalCodecName[mTestCodec], outputSuffix);
    mc_video_codec_dec_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = FALSE;
    params = &context->video_dec_params;
    params->feed_mode = mTestFeedMode;
    params->pix_fmt = mTestPixFmt;
    params->bitstream_buf_size = mTestWidth * mTestHeight * 3 / 2;
    params->bitstream_buf_count = 6;
    params->frame_buf_count = 1;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->h264_dec_config.bandwidth_Opt = TRUE;
        params->h264_dec_config.reorder_enable = TRUE;
        params->h264_dec_config.skip_mode = 0;
    } else {
        params->h265_dec_config.bandwidth_Opt = TRUE;
        params->h265_dec_config.reorder_enable = TRUE;
        params->h265_dec_config.skip_mode = 0;
        params->h265_dec_config.cra_as_bla = FALSE;
        params->h265_dec_config.dec_temporal_id_mode = 0;
        params->h265_dec_config.target_dec_temporal_id_plus1 = 0;
    }

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_decoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_decoding_case_fb_cnt_max) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "fbCntMax";
    char inputSuffix[MAX_FILE_PATH] = "normal.";
    char outputSuffix[MAX_FILE_PATH] = ".yuv";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, inputSuffix, mGlobalCodecName[mTestCodec]);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        mGlobalCodecName[mTestCodec], outputSuffix);
    mc_video_codec_dec_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = FALSE;
    params = &context->video_dec_params;
    params->feed_mode = mTestFeedMode;
    params->pix_fmt = mTestPixFmt;
    params->bitstream_buf_size = mTestWidth * mTestHeight * 3 / 2;
    params->bitstream_buf_count = 6;
    params->frame_buf_count = 31;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->h264_dec_config.bandwidth_Opt = TRUE;
        params->h264_dec_config.reorder_enable = TRUE;
        params->h264_dec_config.skip_mode = 0;
    } else {
        params->h265_dec_config.bandwidth_Opt = TRUE;
        params->h265_dec_config.reorder_enable = TRUE;
        params->h265_dec_config.skip_mode = 0;
        params->h265_dec_config.cra_as_bla = FALSE;
        params->h265_dec_config.dec_temporal_id_mode = 0;
        params->h265_dec_config.target_dec_temporal_id_plus1 = 0;
    }

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_decoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_decoding_case_seq_change) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "seqChange";
    char inputSuffix[MAX_FILE_PATH] = "seqChange.";
    char outputSuffix[MAX_FILE_PATH] = ".yuv";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, inputSuffix, mGlobalCodecName[mTestCodec]);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        mGlobalCodecName[mTestCodec], outputSuffix);
    mc_video_codec_dec_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = FALSE;
    params = &context->video_dec_params;
    params->feed_mode = mTestFeedMode;
    params->pix_fmt = mTestPixFmt;
    params->bitstream_buf_size = mTestWidth * mTestHeight * 3 / 2;
    params->bitstream_buf_count = 6;
    params->frame_buf_count = 5;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->h264_dec_config.bandwidth_Opt = TRUE;
        params->h264_dec_config.reorder_enable = TRUE;
        params->h264_dec_config.skip_mode = 0;
    } else {
        params->h265_dec_config.bandwidth_Opt = TRUE;
        params->h265_dec_config.reorder_enable = TRUE;
        params->h265_dec_config.skip_mode = 0;
        params->h265_dec_config.cra_as_bla = FALSE;
        params->h265_dec_config.dec_temporal_id_mode = 0;
        params->h265_dec_config.target_dec_temporal_id_plus1 = 0;
    }

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_decoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_decoding_case_seq_change_1920x1080) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "seqChange";
    char inputSuffix[MAX_FILE_PATH] = "seqChange.";
    char outputSuffix[MAX_FILE_PATH] = ".yuv";
    mTestWidth = 1920;
    mTestHeight = 1080;
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, inputSuffix, mGlobalCodecName[mTestCodec]);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        mGlobalCodecName[mTestCodec], outputSuffix);
    mc_video_codec_dec_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = FALSE;
    params = &context->video_dec_params;
    params->feed_mode = mTestFeedMode;
    params->pix_fmt = mTestPixFmt;
    params->bitstream_buf_size = mTestWidth * mTestHeight * 3 / 2;
    params->bitstream_buf_count = 6;
    params->frame_buf_count = 5;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->h264_dec_config.bandwidth_Opt = TRUE;
        params->h264_dec_config.reorder_enable = TRUE;
        params->h264_dec_config.skip_mode = 0;
    } else {
        params->h265_dec_config.bandwidth_Opt = TRUE;
        params->h265_dec_config.reorder_enable = TRUE;
        params->h265_dec_config.skip_mode = 0;
        params->h265_dec_config.cra_as_bla = FALSE;
        params->h265_dec_config.dec_temporal_id_mode = 0;
        params->h265_dec_config.target_dec_temporal_id_plus1 = 0;
    }

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_decoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_decoding_case_h264_bw_opt_off) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H264;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "bwOff";
    char inputSuffix[MAX_FILE_PATH] = "normal.";
    char outputSuffix[MAX_FILE_PATH] = ".yuv";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, inputSuffix, mGlobalCodecName[mTestCodec]);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        mGlobalCodecName[mTestCodec], outputSuffix);
    mc_video_codec_dec_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = FALSE;
    params = &context->video_dec_params;
    params->feed_mode = mTestFeedMode;
    params->pix_fmt = mTestPixFmt;
    params->bitstream_buf_size = mTestWidth * mTestHeight * 3 / 2;
    params->bitstream_buf_count = 6;
    params->frame_buf_count = 31;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->h264_dec_config.bandwidth_Opt = FALSE;
        params->h264_dec_config.reorder_enable = TRUE;
        params->h264_dec_config.skip_mode = 0;
    } else {
        params->h265_dec_config.bandwidth_Opt = FALSE;
        params->h265_dec_config.reorder_enable = TRUE;
        params->h265_dec_config.skip_mode = 0;
        params->h265_dec_config.cra_as_bla = FALSE;
        params->h265_dec_config.dec_temporal_id_mode = 0;
        params->h265_dec_config.target_dec_temporal_id_plus1 = 0;
    }

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_decoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_decoding_case_h264_reorder_off) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H264;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "reorderOff";
    char inputSuffix[MAX_FILE_PATH] = "normal.";
    char outputSuffix[MAX_FILE_PATH] = ".yuv";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, inputSuffix, mGlobalCodecName[mTestCodec]);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        mGlobalCodecName[mTestCodec], outputSuffix);
    mc_video_codec_dec_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = FALSE;
    params = &context->video_dec_params;
    params->feed_mode = mTestFeedMode;
    params->pix_fmt = mTestPixFmt;
    params->bitstream_buf_size = mTestWidth * mTestHeight * 3 / 2;
    params->bitstream_buf_count = 6;
    params->frame_buf_count = 31;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->h264_dec_config.bandwidth_Opt = TRUE;
        params->h264_dec_config.reorder_enable = FALSE;
        params->h264_dec_config.skip_mode = 0;
    } else {
        params->h265_dec_config.bandwidth_Opt = TRUE;
        params->h265_dec_config.reorder_enable = FALSE;
        params->h265_dec_config.skip_mode = 0;
        params->h265_dec_config.cra_as_bla = FALSE;
        params->h265_dec_config.dec_temporal_id_mode = 0;
        params->h265_dec_config.target_dec_temporal_id_plus1 = 0;
    }

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_decoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_decoding_effect_case_h264_skip_mode_1) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H264;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "skipMode1";
    char inputSuffix[MAX_FILE_PATH] = "normal.";
    char outputSuffix[MAX_FILE_PATH] = ".yuv";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, inputSuffix, mGlobalCodecName[mTestCodec]);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        mGlobalCodecName[mTestCodec], outputSuffix);
    mc_video_codec_dec_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = FALSE;
    params = &context->video_dec_params;
    params->feed_mode = mTestFeedMode;
    params->pix_fmt = mTestPixFmt;
    params->bitstream_buf_size = mTestWidth * mTestHeight * 3 / 2;
    params->bitstream_buf_count = 6;
    params->frame_buf_count = 31;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->h264_dec_config.bandwidth_Opt = TRUE;
        params->h264_dec_config.reorder_enable = FALSE;
        params->h264_dec_config.skip_mode = 0x01;
    } else {
        params->h265_dec_config.bandwidth_Opt = TRUE;
        params->h265_dec_config.reorder_enable = FALSE;
        params->h265_dec_config.skip_mode = 0x01;
        params->h265_dec_config.cra_as_bla = FALSE;
        params->h265_dec_config.dec_temporal_id_mode = 0;
        params->h265_dec_config.target_dec_temporal_id_plus1 = 0;
    }

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_decoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_decoding_effect_case_h264_skip_mode_2) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H264;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "skipMode2";
    char inputSuffix[MAX_FILE_PATH] = "normal.";
    char outputSuffix[MAX_FILE_PATH] = ".yuv";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, inputSuffix, mGlobalCodecName[mTestCodec]);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        mGlobalCodecName[mTestCodec], outputSuffix);
    mc_video_codec_dec_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = FALSE;
    params = &context->video_dec_params;
    params->feed_mode = mTestFeedMode;
    params->pix_fmt = mTestPixFmt;
    params->bitstream_buf_size = mTestWidth * mTestHeight * 3 / 2;
    params->bitstream_buf_count = 6;
    params->frame_buf_count = 31;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->h264_dec_config.bandwidth_Opt = TRUE;
        params->h264_dec_config.reorder_enable = FALSE;
        params->h264_dec_config.skip_mode = 0x02;
    } else {
        params->h265_dec_config.bandwidth_Opt = TRUE;
        params->h265_dec_config.reorder_enable = FALSE;
        params->h265_dec_config.skip_mode = 0x02;
        params->h265_dec_config.cra_as_bla = FALSE;
        params->h265_dec_config.dec_temporal_id_mode = 0;
        params->h265_dec_config.target_dec_temporal_id_plus1 = 0;
    }

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_decoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_decoding_effect_case_h264_skip_mode_3) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H264;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "skipMode3";
    char inputSuffix[MAX_FILE_PATH] = "normal.";
    char outputSuffix[MAX_FILE_PATH] = ".yuv";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, inputSuffix, mGlobalCodecName[mTestCodec]);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        mGlobalCodecName[mTestCodec], outputSuffix);
    mc_video_codec_dec_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = FALSE;
    params = &context->video_dec_params;
    params->feed_mode = mTestFeedMode;
    params->pix_fmt = mTestPixFmt;
    params->bitstream_buf_size = mTestWidth * mTestHeight * 3 / 2;
    params->bitstream_buf_count = 6;
    params->frame_buf_count = 31;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->h264_dec_config.bandwidth_Opt = TRUE;
        params->h264_dec_config.reorder_enable = FALSE;
        params->h264_dec_config.skip_mode = 0x03;
    } else {
        params->h265_dec_config.bandwidth_Opt = TRUE;
        params->h265_dec_config.reorder_enable = FALSE;
        params->h265_dec_config.skip_mode = 0x03;
        params->h265_dec_config.cra_as_bla = FALSE;
        params->h265_dec_config.dec_temporal_id_mode = 0;
        params->h265_dec_config.target_dec_temporal_id_plus1 = 0;
    }

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_decoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_decoding_case_h265_bw_opt_off) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "bwOff";
    char inputSuffix[MAX_FILE_PATH] = "normal.";
    char outputSuffix[MAX_FILE_PATH] = ".yuv";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, inputSuffix, mGlobalCodecName[mTestCodec]);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        mGlobalCodecName[mTestCodec], outputSuffix);
    mc_video_codec_dec_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = FALSE;
    params = &context->video_dec_params;
    params->feed_mode = mTestFeedMode;
    params->pix_fmt = mTestPixFmt;
    params->bitstream_buf_size = mTestWidth * mTestHeight * 3 / 2;
    params->bitstream_buf_count = 6;
    params->frame_buf_count = 31;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->h264_dec_config.bandwidth_Opt = FALSE;
        params->h264_dec_config.reorder_enable = TRUE;
        params->h264_dec_config.skip_mode = 0;
    } else {
        params->h265_dec_config.bandwidth_Opt = FALSE;
        params->h265_dec_config.reorder_enable = TRUE;
        params->h265_dec_config.skip_mode = 0;
        params->h265_dec_config.cra_as_bla = FALSE;
        params->h265_dec_config.dec_temporal_id_mode = 0;
        params->h265_dec_config.target_dec_temporal_id_plus1 = 0;
    }

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_decoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_decoding_case_h265_reorder_off) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "reorderOff";
    char inputSuffix[MAX_FILE_PATH] = "normal.";
    char outputSuffix[MAX_FILE_PATH] = ".yuv";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, inputSuffix, mGlobalCodecName[mTestCodec]);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        mGlobalCodecName[mTestCodec], outputSuffix);
    mc_video_codec_dec_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = FALSE;
    params = &context->video_dec_params;
    params->feed_mode = mTestFeedMode;
    params->pix_fmt = mTestPixFmt;
    params->bitstream_buf_size = mTestWidth * mTestHeight * 3 / 2;
    params->bitstream_buf_count = 6;
    params->frame_buf_count = 31;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->h264_dec_config.bandwidth_Opt = TRUE;
        params->h264_dec_config.reorder_enable = FALSE;
        params->h264_dec_config.skip_mode = 0;
    } else {
        params->h265_dec_config.bandwidth_Opt = TRUE;
        params->h265_dec_config.reorder_enable = FALSE;
        params->h265_dec_config.skip_mode = 0;
        params->h265_dec_config.cra_as_bla = FALSE;
        params->h265_dec_config.dec_temporal_id_mode = 0;
        params->h265_dec_config.target_dec_temporal_id_plus1 = 0;
    }

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_decoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_decoding_effect_case_h265_skip_mode_1) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "skipMode1";
    char inputSuffix[MAX_FILE_PATH] = "normal.";
    char outputSuffix[MAX_FILE_PATH] = ".yuv";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, inputSuffix, mGlobalCodecName[mTestCodec]);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        mGlobalCodecName[mTestCodec], outputSuffix);
    mc_video_codec_dec_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = FALSE;
    params = &context->video_dec_params;
    params->feed_mode = mTestFeedMode;
    params->pix_fmt = mTestPixFmt;
    params->bitstream_buf_size = mTestWidth * mTestHeight * 3 / 2;
    params->bitstream_buf_count = 6;
    params->frame_buf_count = 6;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->h264_dec_config.bandwidth_Opt = TRUE;
        params->h264_dec_config.reorder_enable = TRUE;
        params->h264_dec_config.skip_mode = 0x01;
    } else {
        params->h265_dec_config.bandwidth_Opt = TRUE;
        params->h265_dec_config.reorder_enable = TRUE;
        params->h265_dec_config.skip_mode = 0x01;
        params->h265_dec_config.cra_as_bla = FALSE;
        params->h265_dec_config.dec_temporal_id_mode = 0;
        params->h265_dec_config.target_dec_temporal_id_plus1 = 0;
    }

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_decoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_decoding_effect_case_h265_skip_mode_2) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "skipMode2";
    char inputSuffix[MAX_FILE_PATH] = "normal.";
    char outputSuffix[MAX_FILE_PATH] = ".yuv";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, inputSuffix, mGlobalCodecName[mTestCodec]);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        mGlobalCodecName[mTestCodec], outputSuffix);
    mc_video_codec_dec_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = FALSE;
    params = &context->video_dec_params;
    params->feed_mode = mTestFeedMode;
    params->pix_fmt = mTestPixFmt;
    params->bitstream_buf_size = mTestWidth * mTestHeight * 3 / 2;
    params->bitstream_buf_count = 6;
    params->frame_buf_count = 6;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->h264_dec_config.bandwidth_Opt = TRUE;
        params->h264_dec_config.reorder_enable = TRUE;
        params->h264_dec_config.skip_mode = 0x02;
    } else {
        params->h265_dec_config.bandwidth_Opt = TRUE;
        params->h265_dec_config.reorder_enable = TRUE;
        params->h265_dec_config.skip_mode = 0x02;
        params->h265_dec_config.cra_as_bla = FALSE;
        params->h265_dec_config.dec_temporal_id_mode = 0;
        params->h265_dec_config.target_dec_temporal_id_plus1 = 0;
    }

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_decoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_decoding_effect_case_h265_skip_mode_3) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "skipMode3";
    char inputSuffix[MAX_FILE_PATH] = "normal.";
    char outputSuffix[MAX_FILE_PATH] = ".yuv";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, inputSuffix, mGlobalCodecName[mTestCodec]);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        mGlobalCodecName[mTestCodec], outputSuffix);
    mc_video_codec_dec_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = FALSE;
    params = &context->video_dec_params;
    params->feed_mode = mTestFeedMode;
    params->pix_fmt = mTestPixFmt;
    params->bitstream_buf_size = mTestWidth * mTestHeight * 3 / 2;
    params->bitstream_buf_count = 6;
    params->frame_buf_count = 6;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->h264_dec_config.bandwidth_Opt = TRUE;
        params->h264_dec_config.reorder_enable = TRUE;
        params->h264_dec_config.skip_mode = 0x03;
    } else {
        params->h265_dec_config.bandwidth_Opt = TRUE;
        params->h265_dec_config.reorder_enable = TRUE;
#ifdef J5
        params->h265_dec_config.skip_mode = 0x02;
#else
        params->h265_dec_config.skip_mode = 0x03;
#endif
        params->h265_dec_config.cra_as_bla = FALSE;
        params->h265_dec_config.dec_temporal_id_mode = 0;
        params->h265_dec_config.target_dec_temporal_id_plus1 = 0;
    }

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_decoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_decoding_effect_case_h265_cra_as_bla) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "craAsBla";
    char inputSuffix[MAX_FILE_PATH] = "normal.";
    char outputSuffix[MAX_FILE_PATH] = ".yuv";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, inputSuffix, mGlobalCodecName[mTestCodec]);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        mGlobalCodecName[mTestCodec], outputSuffix);
    mc_video_codec_dec_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = FALSE;
    params = &context->video_dec_params;
    params->feed_mode = mTestFeedMode;
    params->pix_fmt = mTestPixFmt;
    params->bitstream_buf_size = mTestWidth * mTestHeight * 3 / 2;
    params->bitstream_buf_count = 6;
    params->frame_buf_count = 6;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->h264_dec_config.bandwidth_Opt = TRUE;
        params->h264_dec_config.reorder_enable = TRUE;
        params->h264_dec_config.skip_mode = 0x0;
    } else {
        params->h265_dec_config.bandwidth_Opt = TRUE;
        params->h265_dec_config.reorder_enable = TRUE;
        params->h265_dec_config.skip_mode = 0x0;
        params->h265_dec_config.cra_as_bla = TRUE;
        params->h265_dec_config.dec_temporal_id_mode = 0;
        params->h265_dec_config.target_dec_temporal_id_plus1 = 0;
    }

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_decoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_decoding_case_get_userdata) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "get_userdata";
    char inputSuffix[MAX_FILE_PATH] = "userdata.";
    char outputSuffix[MAX_FILE_PATH] = ".yuv";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, inputSuffix, mGlobalCodecName[mTestCodec]);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        mGlobalCodecName[mTestCodec], outputSuffix);
    mc_video_codec_dec_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = FALSE;
    params = &context->video_dec_params;
    params->feed_mode = mTestFeedMode;
    params->pix_fmt = mTestPixFmt;
    params->bitstream_buf_size = mTestWidth * mTestHeight * 3 / 2;
    params->bitstream_buf_count = 6;
    params->frame_buf_count = 6;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->h264_dec_config.bandwidth_Opt = TRUE;
        params->h264_dec_config.reorder_enable = TRUE;
        params->h264_dec_config.skip_mode = 0x0;
    } else {
        params->h265_dec_config.bandwidth_Opt = TRUE;
        params->h265_dec_config.reorder_enable = TRUE;
        params->h265_dec_config.skip_mode = 0x0;
        params->h265_dec_config.cra_as_bla = FALSE;
        params->h265_dec_config.dec_temporal_id_mode = 0;
        params->h265_dec_config.target_dec_temporal_id_plus1 = 0;
    }

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.enable_get_userdata = 1;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_decoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_decoding_case_h265_temp_id) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "tempId";
    char inputSuffix[MAX_FILE_PATH] = "tempId.";
    char outputSuffix[MAX_FILE_PATH] = ".yuv";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, inputSuffix, mGlobalCodecName[mTestCodec]);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        mGlobalCodecName[mTestCodec], outputSuffix);
    mc_video_codec_dec_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = FALSE;
    params = &context->video_dec_params;
    params->feed_mode = mTestFeedMode;
    params->pix_fmt = mTestPixFmt;
    params->bitstream_buf_size = mTestWidth * mTestHeight * 3 / 2;
    params->bitstream_buf_count = 6;
    params->frame_buf_count = 6;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->h264_dec_config.bandwidth_Opt = TRUE;
        params->h264_dec_config.reorder_enable = TRUE;
        params->h264_dec_config.skip_mode = 0x0;
    } else {
        params->h265_dec_config.bandwidth_Opt = TRUE;
        params->h265_dec_config.reorder_enable = TRUE;
        params->h265_dec_config.skip_mode = 0x0;
        params->h265_dec_config.cra_as_bla = FALSE;
        params->h265_dec_config.dec_temporal_id_mode = 0;
        params->h265_dec_config.target_dec_temporal_id_plus1 = 1;
    }

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_decoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_decoding_case_h265_temp_id_2) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "tempId2";
    char inputSuffix[MAX_FILE_PATH] = "tempId.";
    char outputSuffix[MAX_FILE_PATH] = ".yuv";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, inputSuffix, mGlobalCodecName[mTestCodec]);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        mGlobalCodecName[mTestCodec], outputSuffix);
    mc_video_codec_dec_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = FALSE;
    params = &context->video_dec_params;
    params->feed_mode = mTestFeedMode;
    params->pix_fmt = mTestPixFmt;
    params->bitstream_buf_size = mTestWidth * mTestHeight * 3 / 2;
    params->bitstream_buf_count = 6;
    params->frame_buf_count = 6;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->h264_dec_config.bandwidth_Opt = TRUE;
        params->h264_dec_config.reorder_enable = TRUE;
        params->h264_dec_config.skip_mode = 0x0;
    } else {
        params->h265_dec_config.bandwidth_Opt = TRUE;
        params->h265_dec_config.reorder_enable = TRUE;
        params->h265_dec_config.skip_mode = 0x0;
        params->h265_dec_config.cra_as_bla = FALSE;
        params->h265_dec_config.dec_temporal_id_mode = 0;
        params->h265_dec_config.target_dec_temporal_id_plus1 = 2;
    }

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_decoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_decoding_case_h265_temp_id_3) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "tempId3";
    char inputSuffix[MAX_FILE_PATH] = "tempId.";
    char outputSuffix[MAX_FILE_PATH] = ".yuv";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, inputSuffix, mGlobalCodecName[mTestCodec]);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        mGlobalCodecName[mTestCodec], outputSuffix);
    mc_video_codec_dec_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = FALSE;
    params = &context->video_dec_params;
    params->feed_mode = mTestFeedMode;
    params->pix_fmt = mTestPixFmt;
    params->bitstream_buf_size = mTestWidth * mTestHeight * 3 / 2;
    params->bitstream_buf_count = 6;
    params->frame_buf_count = 6;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->h264_dec_config.bandwidth_Opt = TRUE;
        params->h264_dec_config.reorder_enable = TRUE;
        params->h264_dec_config.skip_mode = 0x0;
    } else {
        params->h265_dec_config.bandwidth_Opt = TRUE;
        params->h265_dec_config.reorder_enable = TRUE;
        params->h265_dec_config.skip_mode = 0x0;
        params->h265_dec_config.cra_as_bla = FALSE;
#ifdef J5
        params->h265_dec_config.dec_temporal_id_mode = 0;
#else
        params->h265_dec_config.dec_temporal_id_mode = 1;
#endif
        params->h265_dec_config.target_dec_temporal_id_plus1 = 2;
    }

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_decoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_decoding_case_external_frame) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "externalFrame";
    char inputSuffix[MAX_FILE_PATH] = "normal.";
    char outputSuffix[MAX_FILE_PATH] = ".yuv";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, inputSuffix, mGlobalCodecName[mTestCodec]);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        mGlobalCodecName[mTestCodec], outputSuffix);
    mc_video_codec_dec_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = FALSE;
    params = &context->video_dec_params;
    params->feed_mode = mTestFeedMode;
    params->pix_fmt = mTestPixFmt;
    params->bitstream_buf_size = mTestWidth * mTestHeight * 3 / 2;
    params->bitstream_buf_count = 6;
    params->external_bitstream_buf = TRUE;
    params->frame_buf_count = 6;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->h264_dec_config.bandwidth_Opt = TRUE;
        params->h264_dec_config.reorder_enable = TRUE;
        params->h264_dec_config.skip_mode = 0;
    } else {
        params->h265_dec_config.bandwidth_Opt = TRUE;
        params->h265_dec_config.reorder_enable = TRUE;
        params->h265_dec_config.skip_mode = 0;
        params->h265_dec_config.cra_as_bla = 0;
        params->h265_dec_config.dec_temporal_id_mode = 0;
        params->h265_dec_config.target_dec_temporal_id_plus1 = 0;
    }

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_decoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_decoding_case_external_frame_2) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "externalFrame2";
    char inputSuffix[MAX_FILE_PATH] = "normal.";
    char outputSuffix[MAX_FILE_PATH] = ".yuv";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, inputSuffix, mGlobalCodecName[mTestCodec]);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        mGlobalCodecName[mTestCodec], outputSuffix);

    mc_video_codec_dec_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = FALSE;
    params = &context->video_dec_params;
    params->feed_mode = mTestFeedMode;
    params->pix_fmt = mTestPixFmt;
    params->bitstream_buf_size = mTestWidth * mTestHeight * 3 / 2;
    params->bitstream_buf_count = 6;
    params->external_bitstream_buf = TRUE;
    params->frame_buf_count = 6;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->h264_dec_config.bandwidth_Opt = TRUE;
        params->h264_dec_config.reorder_enable = TRUE;
        params->h264_dec_config.skip_mode = 0;
    } else {
        params->h265_dec_config.bandwidth_Opt = TRUE;
        params->h265_dec_config.reorder_enable = TRUE;
        params->h265_dec_config.skip_mode = 0;
        params->h265_dec_config.cra_as_bla = 0;
        params->h265_dec_config.dec_temporal_id_mode = 0;
        params->h265_dec_config.target_dec_temporal_id_plus1 = 0;
    }

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_decoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_decoding_case_poll) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "decoding_poll";
    char inputSuffix[MAX_FILE_PATH] = "normal.";
    char outputSuffix[MAX_FILE_PATH] = ".yuv";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, inputSuffix, mGlobalCodecName[mTestCodec]);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        mGlobalCodecName[mTestCodec], outputSuffix);
    mc_video_codec_dec_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = FALSE;
    params = &context->video_dec_params;
    params->feed_mode = mTestFeedMode;
    params->pix_fmt = mTestPixFmt;
    params->bitstream_buf_size = mTestWidth * mTestHeight * 3 / 2;
    params->bitstream_buf_count = 6;
    params->frame_buf_count = 6;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->h264_dec_config.bandwidth_Opt = TRUE;
        params->h264_dec_config.reorder_enable = TRUE;
        params->h264_dec_config.skip_mode = 0;
    } else {
        params->h265_dec_config.bandwidth_Opt = TRUE;
        params->h265_dec_config.reorder_enable = TRUE;
        params->h265_dec_config.skip_mode = 0;
        params->h265_dec_config.cra_as_bla = 0;
        params->h265_dec_config.dec_temporal_id_mode = 0;
        params->h265_dec_config.target_dec_temporal_id_plus1 = 0;
    }

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_poll_decoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_decoding_case_async) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "decoding_async";
    char inputSuffix[MAX_FILE_PATH] = "normal.";
    char outputSuffix[MAX_FILE_PATH] = ".yuv";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, inputSuffix, mGlobalCodecName[mTestCodec]);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        mGlobalCodecName[mTestCodec], outputSuffix);
    mc_video_codec_dec_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = FALSE;
    params = &context->video_dec_params;
    params->feed_mode = mTestFeedMode;
    params->pix_fmt = mTestPixFmt;
    params->bitstream_buf_size = mTestWidth * mTestHeight * 3 / 2;
    params->bitstream_buf_count = 6;
    params->frame_buf_count = 6;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->h264_dec_config.bandwidth_Opt = TRUE;
        params->h264_dec_config.reorder_enable = TRUE;
        params->h264_dec_config.skip_mode = 0;
    } else {
        params->h265_dec_config.bandwidth_Opt = TRUE;
        params->h265_dec_config.reorder_enable = TRUE;
        params->h265_dec_config.skip_mode = 0;
        params->h265_dec_config.cra_as_bla = 0;
        params->h265_dec_config.dec_temporal_id_mode = 0;
        params->h265_dec_config.target_dec_temporal_id_plus1 = 0;
    }

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_async_decoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}

TEST_F(MediaCodecTest, test_decoding_case_multi_2_h264) {
    pthread_t thread_id[MAX_VPU_INSTANCE];
    void* retVal[MAX_VPU_INSTANCE];
    media_codec_context_t *context[MAX_VPU_INSTANCE];
    for (int i = 0; i < MAX_VPU_INSTANCE; i++) {
        context[i] = (media_codec_context_t *)malloc(sizeof(media_codec_context_t));
        ASSERT_NE(context[i], nullptr);
    }
    MediaCodecTestContext ctx[MAX_VPU_INSTANCE];
    mc_video_codec_dec_params_t *params;
    hb_s32 i = 0;
    char outputFileName[MAX_VPU_INSTANCE][MAX_FILE_PATH];
    char inputFileName[MAX_VPU_INSTANCE][MAX_FILE_PATH];
    char inputMd5FileName[MAX_VPU_INSTANCE][MAX_FILE_PATH];
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "multi2Instance";
    char inputSuffix[MAX_FILE_PATH] = "normal.";
    char outputSuffix[MAX_FILE_PATH] = ".yuv";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);

    mTestThreadNum = 2;
    mTestCodec = TEST_CODEC_ID_H264;
    for (i = 0; i < mTestThreadNum; i++) {
        snprintf(inputFileName[i], MAX_FILE_PATH, "%s%s%s",
            dedicatedInputPrefix, inputSuffix, mGlobalCodecName[mTestCodec]);
        snprintf(outputFileName[i], MAX_FILE_PATH, "%s%s_%s_%d_%s%s",
            dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
            i, mGlobalCodecName[mTestCodec], outputSuffix);
        memset(context[i], 0x00, sizeof(media_codec_context_t));
        context[i]->codec_id = get_codec_id(mTestCodec);
        context[i]->encoder = FALSE;

        params = &context[i]->video_dec_params;
        params->feed_mode = mTestFeedMode;
        params->pix_fmt = mTestPixFmt;
        params->bitstream_buf_size = mTestWidth * mTestHeight * 3 / 2;
        params->bitstream_buf_count = 6;
        params->frame_buf_count = 6;
        if (context[i]->codec_id == MEDIA_CODEC_ID_H264) {
            params->h264_dec_config.bandwidth_Opt = TRUE;
            params->h264_dec_config.reorder_enable = TRUE;
            params->h264_dec_config.skip_mode = 0;
        } else {
            params->h265_dec_config.bandwidth_Opt = TRUE;
            params->h265_dec_config.reorder_enable = TRUE;
            params->h265_dec_config.skip_mode = 0;
            params->h265_dec_config.cra_as_bla = 0;
            params->h265_dec_config.dec_temporal_id_mode = 0;
            params->h265_dec_config.target_dec_temporal_id_plus1 = 0;
        }

        memset(&ctx[i], 0x00, sizeof(ctx[i]));
        ctx[i].context = context[i];
        ctx[i].inputFileName = inputFileName[i];
        ctx[i].outputFileName = outputFileName[i];
        ctx[i].testLog = mTestLog;
        ctx[i].md5Test = mTestMd5;
        if (ctx[i].md5Test) {
            char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
            snprintf(inputMd5FileName[i], MAX_FILE_PATH, "%s%s_%s_%d_%s%s",
                dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
                dedicatedSuffix, i, mGlobalCodecName[mTestCodec], inputMd5Suffix);
            ctx[i].inputMd5FileName = inputMd5FileName[i];
        }

        pthread_create(&thread_id[i], NULL, (void* (*)(void*))do_sync_decoding, &ctx[i]);
    }


    for (i = 0; i < mTestThreadNum; i++) {
        pthread_join(thread_id[i], &retVal[i]);
        printf("%s thread %d return = %ld\n", TAG, i, (intptr_t)retVal[i]);
    }
    for (i = 0; i < MAX_VPU_INSTANCE; i++) {
        if (context[i] != NULL) {
            free(context[i]);
        }
    }
}

TEST_F(MediaCodecTest, test_decoding_case_multi_4_h264) {
    pthread_t thread_id[MAX_VPU_INSTANCE];
    void* retVal[MAX_VPU_INSTANCE];
    media_codec_context_t *context[MAX_VPU_INSTANCE];
    for (int i = 0; i < MAX_VPU_INSTANCE; i++) {
        context[i] = (media_codec_context_t *)malloc(sizeof(media_codec_context_t));
        ASSERT_NE(context[i], nullptr);
    }
    MediaCodecTestContext ctx[MAX_VPU_INSTANCE];
    mc_video_codec_dec_params_t *params;
    hb_s32 i = 0;
    char outputFileName[MAX_VPU_INSTANCE][MAX_FILE_PATH];
    char inputFileName[MAX_VPU_INSTANCE][MAX_FILE_PATH];
    char inputMd5FileName[MAX_VPU_INSTANCE][MAX_FILE_PATH];
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "multi4Instance";
    char inputSuffix[MAX_FILE_PATH] = "normal.";
    char outputSuffix[MAX_FILE_PATH] = ".yuv";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);

    mTestThreadNum = 4;
    mTestCodec = TEST_CODEC_ID_H264;
    for (i = 0; i < mTestThreadNum; i++) {
        snprintf(inputFileName[i], MAX_FILE_PATH, "%s%s%s",
            dedicatedInputPrefix, inputSuffix, mGlobalCodecName[mTestCodec]);
        snprintf(outputFileName[i], MAX_FILE_PATH, "%s%s_%s_%d_%s%s",
            dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
            i, mGlobalCodecName[mTestCodec], outputSuffix);
        memset(context[i], 0x00, sizeof(media_codec_context_t));
        context[i]->codec_id = get_codec_id(mTestCodec);
        context[i]->encoder = FALSE;

        params = &context[i]->video_dec_params;
        params->feed_mode = mTestFeedMode;
        params->pix_fmt = mTestPixFmt;
        params->bitstream_buf_size = mTestWidth * mTestHeight * 3 / 2;
        params->bitstream_buf_count = 6;
        params->frame_buf_count = 6;
        if (context[i]->codec_id == MEDIA_CODEC_ID_H264) {
            params->h264_dec_config.bandwidth_Opt = TRUE;
            params->h264_dec_config.reorder_enable = TRUE;
            params->h264_dec_config.skip_mode = 0;
        } else {
            params->h265_dec_config.bandwidth_Opt = TRUE;
            params->h265_dec_config.reorder_enable = TRUE;
            params->h265_dec_config.skip_mode = 0;
            params->h265_dec_config.cra_as_bla = 0;
            params->h265_dec_config.dec_temporal_id_mode = 0;
            params->h265_dec_config.target_dec_temporal_id_plus1 = 0;
        }

        memset(&ctx[i], 0x00, sizeof(ctx[i]));
        ctx[i].context = context[i];
        ctx[i].inputFileName = inputFileName[i];
        ctx[i].outputFileName = outputFileName[i];
        ctx[i].testLog = mTestLog;
        ctx[i].md5Test = mTestMd5;
        if (ctx[i].md5Test) {
            char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
            snprintf(inputMd5FileName[i], MAX_FILE_PATH, "%s%s_%s_%d_%s%s",
                dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
                dedicatedSuffix, i, mGlobalCodecName[mTestCodec], inputMd5Suffix);
            ctx[i].inputMd5FileName = inputMd5FileName[i];
        }

        pthread_create(&thread_id[i], NULL, (void* (*)(void*))do_sync_decoding, &ctx[i]);
    }


    for (i = 0; i < mTestThreadNum; i++) {
        pthread_join(thread_id[i], &retVal[i]);
        printf("%s thread %d return = %ld\n", TAG, i, (intptr_t)retVal[i]);
    }
    for (i = 0; i < MAX_VPU_INSTANCE; i++) {
        if (context[i] != NULL) {
            free(context[i]);
        }
    }
}

TEST_F(MediaCodecTest, test_decoding_case_multi_2_h265) {
    pthread_t thread_id[MAX_VPU_INSTANCE];
    void* retVal[MAX_VPU_INSTANCE];
    media_codec_context_t *context[MAX_VPU_INSTANCE];
    for (int i = 0; i < MAX_VPU_INSTANCE; i++) {
        context[i] = (media_codec_context_t *)malloc(sizeof(media_codec_context_t));
        ASSERT_NE(context[i], nullptr);
    }
    MediaCodecTestContext ctx[MAX_VPU_INSTANCE];
    mc_video_codec_dec_params_t *params;
    hb_s32 i = 0;
    char outputFileName[MAX_VPU_INSTANCE][MAX_FILE_PATH];
    char inputFileName[MAX_VPU_INSTANCE][MAX_FILE_PATH];
    char inputMd5FileName[MAX_VPU_INSTANCE][MAX_FILE_PATH];
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "multi2Instance";
    char inputSuffix[MAX_FILE_PATH] = "normal.";
    char outputSuffix[MAX_FILE_PATH] = ".yuv";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);

    mTestThreadNum = 2;
    mTestCodec = TEST_CODEC_ID_H265;
    for (i = 0; i < mTestThreadNum; i++) {
        snprintf(inputFileName[i], MAX_FILE_PATH, "%s%s%s",
            dedicatedInputPrefix, inputSuffix, mGlobalCodecName[mTestCodec]);
        snprintf(outputFileName[i], MAX_FILE_PATH, "%s%s_%s_%d_%s%s",
            dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
            i, mGlobalCodecName[mTestCodec], outputSuffix);
        memset(context[i], 0x00, sizeof(media_codec_context_t));
        context[i]->codec_id = get_codec_id(mTestCodec);
        context[i]->encoder = FALSE;

        params = &context[i]->video_dec_params;
        params->feed_mode = mTestFeedMode;
        params->pix_fmt = mTestPixFmt;
        params->bitstream_buf_size = mTestWidth * mTestHeight * 3 / 2;
        params->bitstream_buf_count = 6;
        params->frame_buf_count = 6;
        if (context[i]->codec_id == MEDIA_CODEC_ID_H264) {
            params->h264_dec_config.bandwidth_Opt = TRUE;
            params->h264_dec_config.reorder_enable = TRUE;
            params->h264_dec_config.skip_mode = 0;
        } else {
            params->h265_dec_config.bandwidth_Opt = TRUE;
            params->h265_dec_config.reorder_enable = TRUE;
            params->h265_dec_config.skip_mode = 0;
            params->h265_dec_config.cra_as_bla = 0;
            params->h265_dec_config.dec_temporal_id_mode = 0;
            params->h265_dec_config.target_dec_temporal_id_plus1 = 0;
        }

        memset(&ctx[i], 0x00, sizeof(ctx[i]));
        ctx[i].context = context[i];
        ctx[i].inputFileName = inputFileName[i];
        ctx[i].outputFileName = outputFileName[i];
        ctx[i].testLog = mTestLog;
        ctx[i].md5Test = mTestMd5;
        if (ctx[i].md5Test) {
            char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
            snprintf(inputMd5FileName[i], MAX_FILE_PATH, "%s%s_%s_%d_%s%s",
                dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
                dedicatedSuffix, i, mGlobalCodecName[mTestCodec], inputMd5Suffix);
            ctx[i].inputMd5FileName = inputMd5FileName[i];
        }

        pthread_create(&thread_id[i], NULL, (void* (*)(void*))do_sync_decoding, &ctx[i]);
    }


    for (i = 0; i < mTestThreadNum; i++) {
        pthread_join(thread_id[i], &retVal[i]);
        printf("%s thread %d return = %ld\n", TAG, i, (intptr_t)retVal[i]);
    }
    for (i = 0; i < MAX_VPU_INSTANCE; i++) {
        if (context[i] != NULL) {
            free(context[i]);
        }
    }
}

TEST_F(MediaCodecTest, test_decoding_case_multi_2_h264_2_h265) {
    pthread_t thread_id[MAX_VPU_INSTANCE];
    void* retVal[MAX_VPU_INSTANCE];
    media_codec_context_t *context[MAX_VPU_INSTANCE];
    for (int i = 0; i < MAX_VPU_INSTANCE; i++) {
        context[i] = (media_codec_context_t *)malloc(sizeof(media_codec_context_t));
        ASSERT_NE(context[i], nullptr);
    }
    MediaCodecTestContext ctx[MAX_VPU_INSTANCE];
    mc_video_codec_dec_params_t *params;
    hb_s32 i = 0;
    char outputFileName[MAX_VPU_INSTANCE][MAX_FILE_PATH];
    char inputFileName[MAX_VPU_INSTANCE][MAX_FILE_PATH];
    char inputMd5FileName[MAX_VPU_INSTANCE][MAX_FILE_PATH];
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "multi4H2645Instance";
    char inputSuffix[MAX_FILE_PATH] = "normal.";
    char outputSuffix[MAX_FILE_PATH] = ".yuv";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);

    mTestThreadNum = 4;
    for (i = 0; i < mTestThreadNum; i++) {
        mTestCodec = i < 2 ? TEST_CODEC_ID_H264 : TEST_CODEC_ID_H265;
        snprintf(inputFileName[i], MAX_FILE_PATH, "%s%s%s",
            dedicatedInputPrefix, inputSuffix, mGlobalCodecName[mTestCodec]);
        snprintf(outputFileName[i], MAX_FILE_PATH, "%s%s_%s_%d_%s%s",
            dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
            i, mGlobalCodecName[mTestCodec], outputSuffix);
        memset(context[i], 0x00, sizeof(media_codec_context_t));
        context[i]->codec_id = get_codec_id(mTestCodec);
        context[i]->encoder = FALSE;

        params = &context[i]->video_dec_params;
        params->feed_mode = mTestFeedMode;
        params->pix_fmt = mTestPixFmt;
        params->bitstream_buf_size = mTestWidth * mTestHeight * 3 / 2;
        params->bitstream_buf_count = 6;
        params->frame_buf_count = 6;
        if (context[i]->codec_id == MEDIA_CODEC_ID_H264) {
            params->h264_dec_config.bandwidth_Opt = TRUE;
            params->h264_dec_config.reorder_enable = TRUE;
            params->h264_dec_config.skip_mode = 0;
        } else {
            params->h265_dec_config.bandwidth_Opt = TRUE;
            params->h265_dec_config.reorder_enable = TRUE;
            params->h265_dec_config.skip_mode = 0;
            params->h265_dec_config.cra_as_bla = 0;
            params->h265_dec_config.dec_temporal_id_mode = 0;
            params->h265_dec_config.target_dec_temporal_id_plus1 = 0;
        }

        memset(&ctx[i], 0x00, sizeof(ctx[i]));
        ctx[i].context = context[i];
        ctx[i].inputFileName = inputFileName[i];
        ctx[i].outputFileName = outputFileName[i];
        ctx[i].testLog = mTestLog;
        ctx[i].md5Test = mTestMd5;
        if (ctx[i].md5Test) {
            char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
            snprintf(inputMd5FileName[i], MAX_FILE_PATH, "%s%s_%s_%d_%s%s",
                dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
                dedicatedSuffix, i, mGlobalCodecName[mTestCodec], inputMd5Suffix);
            ctx[i].inputMd5FileName = inputMd5FileName[i];
        }

        pthread_create(&thread_id[i], NULL, (void* (*)(void*))do_sync_decoding, &ctx[i]);
    }


    for (i = 0; i < mTestThreadNum; i++) {
        pthread_join(thread_id[i], &retVal[i]);
        printf("%s thread %d return = %ld\n", TAG, i, (intptr_t)retVal[i]);
    }
    for (i = 0; i < MAX_VPU_INSTANCE; i++) {
        if (context[i] != NULL) {
            free(context[i]);
        }
    }
}

TEST_F(MediaCodecTest, test_encoding_decoding_case_multi_2) {
    pthread_t thread_id[2];
    void* ret[2];

    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "encDecMulti";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    if (context->codec_id == MEDIA_CODEC_ID_H264) {
        params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
    } else {
        params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    }
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = 0;
    ctx.stabilityTest = 1;
    ctx.duration = mTestTime;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = "enc.md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    pthread_create(&thread_id[0], NULL, (void* (*)(void*))do_sync_encoding, &ctx);

    char outputFileName2[MAX_FILE_PATH];
    char inputFileName2[MAX_FILE_PATH];
    char dedicatedInputPrefix2[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix2[MAX_FILE_PATH] = "";
    char dedicatedSuffix2[MAX_FILE_PATH] = "encDecMulti";
    char inputSuffix2[MAX_FILE_PATH] = "normal.";
    char outputSuffix2[MAX_FILE_PATH] = ".yuv";
    snprintf(dedicatedInputPrefix2, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName2, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix2, inputSuffix2, mGlobalCodecName[mTestCodec]);
    snprintf(dedicatedOutputPrefix2, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName2, MAX_FILE_PATH, "%s%s_%s_%s%s",
        dedicatedOutputPrefix2, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix2,
        mGlobalCodecName[mTestCodec], outputSuffix2);
    mc_video_codec_dec_params_t *params2;
    media_codec_context_t *context2 = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    memset(context2, 0x00, sizeof(media_codec_context_t));
    context2->codec_id = get_codec_id(mTestCodec);
    context2->encoder = FALSE;
    params2 = &context2->video_dec_params;
    params2->feed_mode = mTestFeedMode;
    params2->pix_fmt = mTestPixFmt;
    params2->bitstream_buf_size = mTestWidth * mTestHeight * 3 / 2;
    params2->bitstream_buf_count = 3;
    params2->frame_buf_count = 3;
    if (context2->codec_id == MEDIA_CODEC_ID_H264) {
        params2->h264_dec_config.bandwidth_Opt = TRUE;
        params2->h264_dec_config.reorder_enable = TRUE;
        params2->h264_dec_config.skip_mode = 0;
    } else {
        params2->h265_dec_config.bandwidth_Opt = TRUE;
        params2->h265_dec_config.reorder_enable = TRUE;
        params2->h265_dec_config.skip_mode = 0;
        params2->h265_dec_config.cra_as_bla = FALSE;
        params2->h265_dec_config.dec_temporal_id_mode = 0;
        params2->h265_dec_config.target_dec_temporal_id_plus1 = 0;
    }

    MediaCodecTestContext ctx2;
    memset(&ctx2, 0x00, sizeof(ctx2));
    ctx2.context = context2;
    ctx2.inputFileName = inputFileName2;
    ctx2.outputFileName = outputFileName2;
    ctx2.testLog = mTestLog;
    ctx2.md5Test = 0;
    ctx2.stabilityTest = 1;
    ctx2.duration = mTestTime;
    char inputMd5FileName2[MAX_FILE_PATH];
    if (ctx2.md5Test) {
        char inputMd5Suffix2[MAX_FILE_PATH] = "dec.md5";
        snprintf(inputMd5FileName2, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix2, mGlobalPixFmtName[mTestPixFmt],
            dedicatedSuffix2, mGlobalCodecName[mTestCodec], inputMd5Suffix2);
        ctx2.inputMd5FileName = inputMd5FileName2;
    }

    pthread_create(&thread_id[1], NULL, (void* (*)(void*))do_sync_decoding, &ctx2);

    pthread_join(thread_id[0], &ret[0]);
    printf("thread1 return = %ld\n", (intptr_t)ret[0]);

    pthread_join(thread_id[1], &ret[1]);
    printf("thread2 return = %ld\n", (intptr_t)ret[1]);
    if (context != NULL) {
        free(context);
    }
    if (context2 != NULL) {
        free(context2);
    }
}

TEST_F(MediaCodecTest,
            test_encoding_decoding_case_multiProcess_2) {
    pid_t child;
    int status;

    child = fork();
    if (child < 0) {
        printf("%s Failed to create child process(current %d, parent %d)!\n",
            TAG, getpid(), getppid());
        exit(1);
    } else if (child == 0) {
        printf( "%s In child process %d(parent %d).\n",
            TAG, getpid(), getppid());
        char outputFileName[MAX_FILE_PATH];
        char inputFileName[MAX_FILE_PATH];
        char dedicatedInputPrefix[MAX_FILE_PATH] = "";
        char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
        char dedicatedSuffix[MAX_FILE_PATH] = "EncDecMultiPro0";
        char inputSuffix[MAX_FILE_PATH] = ".yuv";
        char outputSuffix[MAX_FILE_PATH] = ".";
        snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
            mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
        snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
        snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
            mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
        snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
            dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
            outputSuffix, mGlobalCodecName[mTestCodec]);
        mc_video_codec_enc_params_t *params;
        media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
        ASSERT_NE(context, nullptr);
        memset(context, 0x00, sizeof(media_codec_context_t));
        context->codec_id = get_codec_id(mTestCodec);
        context->encoder = TRUE;
        params = &context->video_enc_params;
        params->width = mTestWidth;
        params->height = mTestHeight;
        params->pix_fmt = mTestPixFmt;
        params->frame_buf_count = 5;
        params->external_frame_buf = FALSE;
        params->bitstream_buf_count = 5;
        if (context->codec_id == MEDIA_CODEC_ID_H264) {
            params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
        } else {
            params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
        }
        ASSERT_EQ(get_rc_params(context, &params->rc_params),
            (int32_t)0);
        params->gop_params.decoding_refresh_type = 2;
        params->gop_params.gop_preset_idx = 2;
        params->rot_degree = MC_CCW_0;
        params->mir_direction = MC_DIRECTION_NONE;
        params->frame_cropping_flag = FALSE;
        
        MediaCodecTestContext ctx;
        memset(&ctx, 0x00, sizeof(ctx));
        ctx.context = context;
        ctx.inputFileName = inputFileName;
        ctx.outputFileName = outputFileName;
        ctx.testLog = mTestLog;
        ctx.md5Test = mTestMd5;
        char inputMd5FileName[MAX_FILE_PATH];
        if (ctx.md5Test) {
            char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
            snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
                dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
                dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
            ctx.inputMd5FileName = inputMd5FileName;
        }
        do_sync_encoding(&ctx);
        if (context != NULL) {
            free(context);
        }
        exit(0);
    } else {
        printf( "%s In parent process %d(pparent %d).\n",
            TAG, getpid(), getppid());
        char outputFileName[MAX_FILE_PATH];
        char inputFileName[MAX_FILE_PATH];
        char dedicatedInputPrefix[MAX_FILE_PATH] = "";
        char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
        char dedicatedSuffix[MAX_FILE_PATH] = "EncDecMultiPro1";
        char inputSuffix[MAX_FILE_PATH] = "normal.";
        char outputSuffix[MAX_FILE_PATH] = ".yuv";
        snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
            mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
        snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
            dedicatedInputPrefix, inputSuffix, mGlobalCodecName[mTestCodec]);
        snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
            mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
        snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
            mGlobalCodecName[mTestCodec], outputSuffix);
        mc_video_codec_dec_params_t *params;
        media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
        ASSERT_NE(context, nullptr);
        memset(context, 0x00, sizeof(media_codec_context_t));
        context->codec_id = get_codec_id(mTestCodec);
        context->encoder = FALSE;
        params = &context->video_dec_params;
        params->feed_mode = mTestFeedMode;
        params->pix_fmt = mTestPixFmt;
        params->bitstream_buf_size = mTestWidth * mTestHeight * 3 / 2;
        params->bitstream_buf_count = 3;
        params->frame_buf_count = 3;
        if (context->codec_id == MEDIA_CODEC_ID_H264) {
            params->h264_dec_config.bandwidth_Opt = TRUE;
            params->h264_dec_config.reorder_enable = TRUE;
            params->h264_dec_config.skip_mode = 0;
        } else {
            params->h265_dec_config.bandwidth_Opt = TRUE;
            params->h265_dec_config.reorder_enable = TRUE;
            params->h265_dec_config.skip_mode = 0;
            params->h265_dec_config.cra_as_bla = FALSE;
            params->h265_dec_config.dec_temporal_id_mode = 0;
            params->h265_dec_config.target_dec_temporal_id_plus1 = 0;
        }
        
        MediaCodecTestContext ctx;
        memset(&ctx, 0x00, sizeof(ctx));
        ctx.context = context;
        ctx.inputFileName = inputFileName;
        ctx.outputFileName = outputFileName;
        ctx.testLog = mTestLog;
        ctx.md5Test = mTestMd5;
        char inputMd5FileName[MAX_FILE_PATH];
        if (ctx.md5Test) {
            char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
            snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
                dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
                dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
            ctx.inputMd5FileName = inputMd5FileName;
        }
        do_sync_decoding(&ctx);
        waitpid(child, &status, 0);
        printf( "%s Child process exited with status %d.\n", TAG, status);
        if (context != NULL) {
            free(context);
        }
    }
}

TEST_F(MediaCodecTest,
            test_encoding_case_multiProcess_2) {
    pid_t child;
    int status;

    child = fork();
    if (child < 0) {
        printf("%s Failed to create child process(current %d, parent %d)!\n",
            TAG, getpid(), getppid());
        exit(1);
    } else if (child == 0) {
        printf( "%s In child process %d(parent %d).\n",
            TAG, getpid(), getppid());
        char outputFileName[MAX_FILE_PATH];
        char inputFileName[MAX_FILE_PATH];
        char dedicatedInputPrefix[MAX_FILE_PATH] = "";
        char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
        char dedicatedSuffix[MAX_FILE_PATH] = "EncMultiPro0";
        char inputSuffix[MAX_FILE_PATH] = ".yuv";
        char outputSuffix[MAX_FILE_PATH] = ".";
        snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
            mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
        snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
        snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
            mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
        snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
            dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
            outputSuffix, mGlobalCodecName[mTestCodec]);
        mc_video_codec_enc_params_t *params;
        media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
        ASSERT_NE(context, nullptr);
        memset(context, 0x00, sizeof(media_codec_context_t));
        context->codec_id = get_codec_id(mTestCodec);
        context->encoder = TRUE;
        params = &context->video_enc_params;
        params->width = mTestWidth;
        params->height = mTestHeight;
        params->pix_fmt = mTestPixFmt;
        params->frame_buf_count = 5;
        params->external_frame_buf = FALSE;
        params->bitstream_buf_count = 5;
        if (context->codec_id == MEDIA_CODEC_ID_H264) {
            params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
        } else {
            params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
        }
        ASSERT_EQ(get_rc_params(context, &params->rc_params),
            (int32_t)0);
        params->gop_params.decoding_refresh_type = 2;
        params->gop_params.gop_preset_idx = 2;
        params->rot_degree = MC_CCW_0;
        params->mir_direction = MC_DIRECTION_NONE;
        params->frame_cropping_flag = FALSE;
        
        MediaCodecTestContext ctx;
        memset(&ctx, 0x00, sizeof(ctx));
        ctx.context = context;
        ctx.inputFileName = inputFileName;
        ctx.outputFileName = outputFileName;
        ctx.testLog = mTestLog;
        ctx.md5Test = mTestMd5;
        char inputMd5FileName[MAX_FILE_PATH];
        if (ctx.md5Test) {
            char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
            snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
                dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
                dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
            ctx.inputMd5FileName = inputMd5FileName;
        }
        do_sync_encoding(&ctx);
        if (context != NULL) {
            free(context);
        }
        exit(0);
    } else {
        printf( "%s In parent process %d(pparent %d).\n",
            TAG, getpid(), getppid());
        char outputFileName[MAX_FILE_PATH];
        char inputFileName[MAX_FILE_PATH];
        char dedicatedInputPrefix[MAX_FILE_PATH] = "";
        char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
        char dedicatedSuffix[MAX_FILE_PATH] = "EncMultiPro1";
        char inputSuffix[MAX_FILE_PATH] = ".yuv";
        char outputSuffix[MAX_FILE_PATH] = ".";
        snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
            mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
        snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
        snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
            mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
        snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
            dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
            outputSuffix, mGlobalCodecName[mTestCodec]);
        mc_video_codec_enc_params_t *params;
        media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
        ASSERT_NE(context, nullptr);
        memset(context, 0x00, sizeof(media_codec_context_t));
        context->codec_id = get_codec_id(mTestCodec);
        context->encoder = TRUE;
        params = &context->video_enc_params;
        params->width = mTestWidth;
        params->height = mTestHeight;
        params->pix_fmt = mTestPixFmt;
        params->frame_buf_count = 5;
        params->external_frame_buf = FALSE;
        params->bitstream_buf_count = 5;
        if (context->codec_id == MEDIA_CODEC_ID_H264) {
            params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
        } else {
            params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
        }
        ASSERT_EQ(get_rc_params(context, &params->rc_params),
            (int32_t)0);
        params->gop_params.decoding_refresh_type = 2;
        params->gop_params.gop_preset_idx = 2;
        params->rot_degree = MC_CCW_0;
        params->mir_direction = MC_DIRECTION_NONE;
        params->frame_cropping_flag = FALSE;
        
        MediaCodecTestContext ctx;
        memset(&ctx, 0x00, sizeof(ctx));
        ctx.context = context;
        ctx.inputFileName = inputFileName;
        ctx.outputFileName = outputFileName;
        ctx.testLog = mTestLog;
        ctx.md5Test = mTestMd5;
        char inputMd5FileName[MAX_FILE_PATH];
        if (ctx.md5Test) {
            char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
            snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
                dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
                dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
            ctx.inputMd5FileName = inputMd5FileName;
        }
        do_sync_encoding(&ctx);
        waitpid(child, &status, 0);
        printf( "%s Child process exited with status %d.\n", TAG, status);
        if (context != NULL) {
            free(context);
        }
    }
}

TEST_F(MediaCodecTest,
            test_decoding_case_multiProcess_2) {
    pid_t child;
    int status;

    child = fork();
    if (child < 0) {
        printf("%s Failed to create child process(current %d, parent %d)!\n",
            TAG, getpid(), getppid());
        exit(1);
    } else if (child == 0) {
        printf( "%s In child process %d(parent %d).\n",
            TAG, getpid(), getppid());
        char outputFileName[MAX_FILE_PATH];
        char inputFileName[MAX_FILE_PATH];
        char dedicatedInputPrefix[MAX_FILE_PATH] = "";
        char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
        char dedicatedSuffix[MAX_FILE_PATH] = "DecMultiPro0";
        char inputSuffix[MAX_FILE_PATH] = "normal.";
        char outputSuffix[MAX_FILE_PATH] = ".yuv";
        snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
            mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
        snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
            dedicatedInputPrefix, inputSuffix, mGlobalCodecName[mTestCodec]);
        snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
            mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
        snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
            mGlobalCodecName[mTestCodec], outputSuffix);
        mc_video_codec_dec_params_t *params;
        media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
        ASSERT_NE(context, nullptr);
        memset(context, 0x00, sizeof(media_codec_context_t));
        context->codec_id = get_codec_id(mTestCodec);
        context->encoder = FALSE;
        params = &context->video_dec_params;
        params->feed_mode = mTestFeedMode;
        params->pix_fmt = mTestPixFmt;
        params->bitstream_buf_size = mTestWidth * mTestHeight * 3 / 2;
        params->bitstream_buf_count = 3;
        params->frame_buf_count = 3;
        if (context->codec_id == MEDIA_CODEC_ID_H264) {
            params->h264_dec_config.bandwidth_Opt = TRUE;
            params->h264_dec_config.reorder_enable = TRUE;
            params->h264_dec_config.skip_mode = 0;
        } else {
            params->h265_dec_config.bandwidth_Opt = TRUE;
            params->h265_dec_config.reorder_enable = TRUE;
            params->h265_dec_config.skip_mode = 0;
            params->h265_dec_config.cra_as_bla = FALSE;
            params->h265_dec_config.dec_temporal_id_mode = 0;
            params->h265_dec_config.target_dec_temporal_id_plus1 = 0;
        }
        
        MediaCodecTestContext ctx;
        memset(&ctx, 0x00, sizeof(ctx));
        ctx.context = context;
        ctx.inputFileName = inputFileName;
        ctx.outputFileName = outputFileName;
        ctx.testLog = mTestLog;
        ctx.md5Test = mTestMd5;
        char inputMd5FileName[MAX_FILE_PATH];
        if (ctx.md5Test) {
            char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
            snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
                dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
                dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
            ctx.inputMd5FileName = inputMd5FileName;
        }
        do_sync_decoding(&ctx);
        if (context != NULL) {
            free(context);
        }
        exit(0);
    } else {
        printf( "%s In parent process %d(pparent %d).\n",
            TAG, getpid(), getppid());
        char outputFileName[MAX_FILE_PATH];
        char inputFileName[MAX_FILE_PATH];
        char dedicatedInputPrefix[MAX_FILE_PATH] = "";
        char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
        char dedicatedSuffix[MAX_FILE_PATH] = "DecMultiPro1";
        char inputSuffix[MAX_FILE_PATH] = "normal.";
        char outputSuffix[MAX_FILE_PATH] = ".yuv";
        snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
            mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
        snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
            dedicatedInputPrefix, inputSuffix, mGlobalCodecName[mTestCodec]);
        snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
            mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
        snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
            mGlobalCodecName[mTestCodec], outputSuffix);
        mc_video_codec_dec_params_t *params;
        media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
        ASSERT_NE(context, nullptr);
        memset(context, 0x00, sizeof(media_codec_context_t));
        context->codec_id = get_codec_id(mTestCodec);
        context->encoder = FALSE;
        params = &context->video_dec_params;
        params->feed_mode = mTestFeedMode;
        params->pix_fmt = mTestPixFmt;
        params->bitstream_buf_size = mTestWidth * mTestHeight * 3 / 2;
        params->bitstream_buf_count = 3;
        params->frame_buf_count = 3;
        if (context->codec_id == MEDIA_CODEC_ID_H264) {
            params->h264_dec_config.bandwidth_Opt = TRUE;
            params->h264_dec_config.reorder_enable = TRUE;
            params->h264_dec_config.skip_mode = 0;
        } else {
            params->h265_dec_config.bandwidth_Opt = TRUE;
            params->h265_dec_config.reorder_enable = TRUE;
            params->h265_dec_config.skip_mode = 0;
            params->h265_dec_config.cra_as_bla = FALSE;
            params->h265_dec_config.dec_temporal_id_mode = 0;
            params->h265_dec_config.target_dec_temporal_id_plus1 = 0;
        }
        
        MediaCodecTestContext ctx;
        memset(&ctx, 0x00, sizeof(ctx));
        ctx.context = context;
        ctx.inputFileName = inputFileName;
        ctx.outputFileName = outputFileName;
        ctx.testLog = mTestLog;
        ctx.md5Test = mTestMd5;
        char inputMd5FileName[MAX_FILE_PATH];
        if (ctx.md5Test) {
            char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
            snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
                dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
                dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
            ctx.inputMd5FileName = inputMd5FileName;
        }
        do_sync_decoding(&ctx);
        waitpid(child, &status, 0);
        printf( "%s Child process exited with status %d.\n", TAG, status);
        if (context != NULL) {
            free(context);
        }
    }
}

TEST_F(MediaCodecTest, test_encoding_decoding_abnormal_quitting) {
    pid_t child;
    int status;

    child = fork();
    if (child < 0) {
        printf("%s Failed to create child process(current %d, parent %d)!\n",
            TAG, getpid(), getppid());
        exit(1);
    } else if (child == 0) {
        printf( "%s In child process %d(parent %d).\n",
            TAG, getpid(), getppid());
        char outputFileName[MAX_FILE_PATH];
        char inputFileName[MAX_FILE_PATH];
        char dedicatedInputPrefix[MAX_FILE_PATH] = "";
        char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
        char dedicatedSuffix[MAX_FILE_PATH] = "abnormalPro2_1";
        char inputSuffix[MAX_FILE_PATH] = ".yuv";
        char outputSuffix[MAX_FILE_PATH] = ".";
        snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
            mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
        snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
        snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
            mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
        snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
            dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
            outputSuffix, mGlobalCodecName[mTestCodec]);
        mc_video_codec_enc_params_t *params;
        media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
        ASSERT_NE(context, nullptr);
        memset(context, 0x00, sizeof(media_codec_context_t));
        context->codec_id = get_codec_id(mTestCodec);
        context->encoder = TRUE;
        params = &context->video_enc_params;
        params->width = mTestWidth;
        params->height = mTestHeight;
        params->pix_fmt = mTestPixFmt;
        params->frame_buf_count = 5;
        params->external_frame_buf = FALSE;
        params->bitstream_buf_count = 5;
        if (context->codec_id == MEDIA_CODEC_ID_H264) {
            params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
        } else {
            params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
        }
        ASSERT_EQ(get_rc_params(context, &params->rc_params),
            (int32_t)0);
        params->gop_params.decoding_refresh_type = 2;
        params->gop_params.gop_preset_idx = 2;
        params->rot_degree = MC_CCW_0;
        params->mir_direction = MC_DIRECTION_NONE;
        params->frame_cropping_flag = FALSE;
        
        MediaCodecTestContext ctx;
        memset(&ctx, 0x00, sizeof(ctx));
        ctx.context = context;
        ctx.inputFileName = inputFileName;
        ctx.outputFileName = outputFileName;
        ctx.testLog = mTestLog;
        ctx.testAbnormalQuit = 1;
        ctx.md5Test = mTestMd5;
        char inputMd5FileName[MAX_FILE_PATH];
        if (ctx.md5Test) {
            char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
            snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
                dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
                dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
            ctx.inputMd5FileName = inputMd5FileName;
        }
        do_sync_encoding(&ctx);
        if (context != NULL) {
            free(context);
        }
        exit(0);
    } else {
        waitpid(child, &status, 0);
        printf( "%s Child process exited with status %d.\n", TAG, status);

        printf( "%s In parent process %d(pparent %d).\n",
            TAG, getpid(), getppid());
        char outputFileName[MAX_FILE_PATH];
        char inputFileName[MAX_FILE_PATH];
        char dedicatedInputPrefix[MAX_FILE_PATH] = "";
        char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
        char dedicatedSuffix[MAX_FILE_PATH] = "abnormalPro2_2";
        char inputSuffix[MAX_FILE_PATH] = "normal.";
        char outputSuffix[MAX_FILE_PATH] = ".yuv";
        snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
            mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
        snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
            dedicatedInputPrefix, inputSuffix, mGlobalCodecName[mTestCodec]);
        snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
            mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
        snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
            mGlobalCodecName[mTestCodec], outputSuffix);
        mc_video_codec_dec_params_t *params;
        media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
        ASSERT_NE(context, nullptr);
        memset(context, 0x00, sizeof(media_codec_context_t));
        context->codec_id = get_codec_id(mTestCodec);
        context->encoder = FALSE;
        params = &context->video_dec_params;
        params->feed_mode = mTestFeedMode;
        params->pix_fmt = mTestPixFmt;
        params->bitstream_buf_size = mTestWidth * mTestHeight * 3 / 2;
        params->bitstream_buf_count = 3;
        params->frame_buf_count = 3;
        if (context->codec_id == MEDIA_CODEC_ID_H264) {
            params->h264_dec_config.bandwidth_Opt = TRUE;
            params->h264_dec_config.reorder_enable = TRUE;
            params->h264_dec_config.skip_mode = 0;
        } else {
            params->h265_dec_config.bandwidth_Opt = TRUE;
            params->h265_dec_config.reorder_enable = TRUE;
            params->h265_dec_config.skip_mode = 0;
            params->h265_dec_config.cra_as_bla = FALSE;
            params->h265_dec_config.dec_temporal_id_mode = 0;
            params->h265_dec_config.target_dec_temporal_id_plus1 = 0;
        }
        
        MediaCodecTestContext ctx;
        memset(&ctx, 0x00, sizeof(ctx));
        ctx.context = context;
        ctx.inputFileName = inputFileName;
        ctx.outputFileName = outputFileName;
        ctx.testLog = mTestLog;
        ctx.md5Test = mTestMd5;
        char inputMd5FileName[MAX_FILE_PATH];
        if (ctx.md5Test) {
            char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
            snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
                dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
                dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
            ctx.inputMd5FileName = inputMd5FileName;
        }
        do_sync_decoding(&ctx);
        waitpid(child, &status, 0);
        printf( "%s Child process exited with status %d.\n", TAG, status);
        if (context != NULL) {
            free(context);
        }
    }
}

TEST_F(MediaCodecTest,
            test_decoding_case_multiProcess_2_h264_2_h265) {
    pid_t child[3];
    int status[3];

    child[0] = fork();
    if (child[0] < 0) {
        printf("%s Failed to create child %d process(current %d, parent %d)!\n",
            TAG, 0, getpid(), getppid());
        exit(1);
    } else if (child[0] == 0) {
        printf( "%s In child process %d(parent %d).\n",
            TAG, getpid(), getppid());
        char outputFileName[MAX_FILE_PATH];
        char inputFileName[MAX_FILE_PATH];
        char dedicatedInputPrefix[MAX_FILE_PATH] = "";
        char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
        char dedicatedSuffix[MAX_FILE_PATH] = "multiPro2H2642H265_0";
        char inputSuffix[MAX_FILE_PATH] = "normal.";
        char outputSuffix[MAX_FILE_PATH] = ".yuv";
        snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
            mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
        snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
            dedicatedInputPrefix, inputSuffix, mGlobalCodecName[mTestCodec]);
        snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
            mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
        snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
            mGlobalCodecName[mTestCodec], outputSuffix);
        mc_video_codec_dec_params_t *params;
        media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
        ASSERT_NE(context, nullptr);
        memset(context, 0x00, sizeof(media_codec_context_t));
        context->codec_id = get_codec_id(mTestCodec);
        context->encoder = FALSE;
        params = &context->video_dec_params;
        params->feed_mode = mTestFeedMode;
        params->pix_fmt = mTestPixFmt;
        params->bitstream_buf_size = mTestWidth * mTestHeight * 3 / 2;
        params->bitstream_buf_count = 6;
        params->frame_buf_count = 6;
        if (context->codec_id == MEDIA_CODEC_ID_H264) {
            params->h264_dec_config.bandwidth_Opt = TRUE;
            params->h264_dec_config.reorder_enable = TRUE;
            params->h264_dec_config.skip_mode = 0;
        } else {
            params->h265_dec_config.bandwidth_Opt = TRUE;
            params->h265_dec_config.reorder_enable = TRUE;
            params->h265_dec_config.skip_mode = 0;
            params->h265_dec_config.cra_as_bla = FALSE;
            params->h265_dec_config.dec_temporal_id_mode = 0;
            params->h265_dec_config.target_dec_temporal_id_plus1 = 0;
        }

        MediaCodecTestContext ctx;
        memset(&ctx, 0x00, sizeof(ctx));
        ctx.context = context;
        ctx.inputFileName = inputFileName;
        ctx.outputFileName = outputFileName;
        ctx.testLog = mTestLog;
        ctx.md5Test = mTestMd5;
        char inputMd5FileName[MAX_FILE_PATH];
        if (ctx.md5Test) {
            char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
            snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
                dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
                dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
            ctx.inputMd5FileName = inputMd5FileName;
        }
        do_sync_decoding(&ctx);
        if (context != NULL) {
            free(context);
        }
        exit(0);
    } else {
        child[1] = fork();
        if (child[1] < 0) {
            printf("%s Failed to create child %d process(current %d, parent %d)!\n",
                TAG, 1, getpid(), getppid());
            exit(1);
        } else if (child[1] == 0) {
            printf( "%s In child process %d(parent %d).\n",
                TAG, getpid(), getppid());
            char outputFileName[MAX_FILE_PATH];
            char inputFileName[MAX_FILE_PATH];
            char dedicatedInputPrefix[MAX_FILE_PATH] = "";
            char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
            char dedicatedSuffix[MAX_FILE_PATH] = "multiPro2H2642H265_1";
            char inputSuffix[MAX_FILE_PATH] = "normal.";
            char outputSuffix[MAX_FILE_PATH] = ".yuv";
            snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
                mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
            snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
                dedicatedInputPrefix, inputSuffix, mGlobalCodecName[mTestCodec]);
            snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
                mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
            snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
                dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
                mGlobalCodecName[mTestCodec], outputSuffix);
            mc_video_codec_dec_params_t *params;
            media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
            ASSERT_NE(context, nullptr);
            memset(context, 0x00, sizeof(media_codec_context_t));
            context->codec_id = get_codec_id(mTestCodec);
            context->encoder = FALSE;
            params = &context->video_dec_params;
            params->feed_mode = mTestFeedMode;
            params->pix_fmt = mTestPixFmt;
            params->bitstream_buf_size = mTestWidth * mTestHeight * 3 / 2;
            params->bitstream_buf_count = 6;
            params->frame_buf_count = 6;
            if (context->codec_id == MEDIA_CODEC_ID_H264) {
                params->h264_dec_config.bandwidth_Opt = TRUE;
                params->h264_dec_config.reorder_enable = TRUE;
                params->h264_dec_config.skip_mode = 0;
            } else {
                params->h265_dec_config.bandwidth_Opt = TRUE;
                params->h265_dec_config.reorder_enable = TRUE;
                params->h265_dec_config.skip_mode = 0;
                params->h265_dec_config.cra_as_bla = FALSE;
                params->h265_dec_config.dec_temporal_id_mode = 0;
                params->h265_dec_config.target_dec_temporal_id_plus1 = 0;
            }
            
            MediaCodecTestContext ctx;
            memset(&ctx, 0x00, sizeof(ctx));
            ctx.context = context;
            ctx.inputFileName = inputFileName;
            ctx.outputFileName = outputFileName;
            ctx.testLog = mTestLog;
            ctx.md5Test = mTestMd5;
            char inputMd5FileName[MAX_FILE_PATH];
            if (ctx.md5Test) {
                char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
                snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
                    dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
                    dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
                ctx.inputMd5FileName = inputMd5FileName;
            }
            do_sync_decoding(&ctx);
            if (context != NULL) {
                free(context);
            }
            exit(0);
        } else {
            child[2] = fork();
            if (child[2] < 0) {
                printf("%s Failed to create child %d process(current %d, parent %d)!\n",
                    TAG, 2, getpid(), getppid());
                exit(1);
            } else if (child[2] == 0) {
                printf( "%s In child process %d(parent %d).\n",
                    TAG, getpid(), getppid());
                char outputFileName[MAX_FILE_PATH];
                char inputFileName[MAX_FILE_PATH];
                char dedicatedInputPrefix[MAX_FILE_PATH] = "";
                char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
                char dedicatedSuffix[MAX_FILE_PATH] = "multiPro2H2642H265_2";
                char inputSuffix[MAX_FILE_PATH] = "normal.";
                char outputSuffix[MAX_FILE_PATH] = ".yuv";
                snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
                    mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
                snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
                    dedicatedInputPrefix, inputSuffix, mGlobalCodecName[mTestCodec]);
                snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
                    mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
                snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
                    dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
                    mGlobalCodecName[mTestCodec], outputSuffix);
                mc_video_codec_dec_params_t *params;
                media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
                ASSERT_NE(context, nullptr);
                memset(context, 0x00, sizeof(media_codec_context_t));
                context->codec_id = get_codec_id(mTestCodec);
                context->encoder = FALSE;
                params = &context->video_dec_params;
                params->feed_mode = mTestFeedMode;
                params->pix_fmt = mTestPixFmt;
                params->bitstream_buf_size = mTestWidth * mTestHeight * 3 / 2;
                params->bitstream_buf_count = 6;
                params->frame_buf_count = 6;
                if (context->codec_id == MEDIA_CODEC_ID_H264) {
                    params->h264_dec_config.bandwidth_Opt = TRUE;
                    params->h264_dec_config.reorder_enable = TRUE;
                    params->h264_dec_config.skip_mode = 0;
                } else {
                    params->h265_dec_config.bandwidth_Opt = TRUE;
                    params->h265_dec_config.reorder_enable = TRUE;
                    params->h265_dec_config.skip_mode = 0;
                    params->h265_dec_config.cra_as_bla = FALSE;
                    params->h265_dec_config.dec_temporal_id_mode = 0;
                    params->h265_dec_config.target_dec_temporal_id_plus1 = 0;
                }
                
                MediaCodecTestContext ctx;
                memset(&ctx, 0x00, sizeof(ctx));
                ctx.context = context;
                ctx.inputFileName = inputFileName;
                ctx.outputFileName = outputFileName;
                ctx.testLog = mTestLog;
                ctx.md5Test = mTestMd5;
                char inputMd5FileName[MAX_FILE_PATH];
                if (ctx.md5Test) {
                    char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
                    snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
                        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
                        dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
                    ctx.inputMd5FileName = inputMd5FileName;
                }
                do_sync_decoding(&ctx);
                if (context != NULL) {
                    free(context);
                }
                exit(0);
            } else {
                printf( "%s In child process %d(parent %d).\n",
                    TAG, getpid(), getppid());
                char outputFileName[MAX_FILE_PATH];
                char inputFileName[MAX_FILE_PATH];
                char dedicatedInputPrefix[MAX_FILE_PATH] = "";
                char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
                char dedicatedSuffix[MAX_FILE_PATH] = "multiPro2H2642H265_3";
                char inputSuffix[MAX_FILE_PATH] = "normal.";
                char outputSuffix[MAX_FILE_PATH] = ".yuv";
                snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
                    mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
                snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
                    dedicatedInputPrefix, inputSuffix, mGlobalCodecName[mTestCodec]);
                snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
                    mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
                snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
                    dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
                    mGlobalCodecName[mTestCodec], outputSuffix);
                mc_video_codec_dec_params_t *params;
                media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
                ASSERT_NE(context, nullptr);
                memset(context, 0x00, sizeof(media_codec_context_t));
                context->codec_id = get_codec_id(mTestCodec);
                context->encoder = FALSE;
                params = &context->video_dec_params;
                params->feed_mode = mTestFeedMode;
                params->pix_fmt = mTestPixFmt;
                params->bitstream_buf_size = mTestWidth * mTestHeight * 3 / 2;
                params->bitstream_buf_count = 6;
                params->frame_buf_count = 6;
                if (context->codec_id == MEDIA_CODEC_ID_H264) {
                    params->h264_dec_config.bandwidth_Opt = TRUE;
                    params->h264_dec_config.reorder_enable = TRUE;
                    params->h264_dec_config.skip_mode = 0;
                } else {
                    params->h265_dec_config.bandwidth_Opt = TRUE;
                    params->h265_dec_config.reorder_enable = TRUE;
                    params->h265_dec_config.skip_mode = 0;
                    params->h265_dec_config.cra_as_bla = FALSE;
                    params->h265_dec_config.dec_temporal_id_mode = 0;
                    params->h265_dec_config.target_dec_temporal_id_plus1 = 0;
                }
                
                MediaCodecTestContext ctx;
                memset(&ctx, 0x00, sizeof(ctx));
                ctx.context = context;
                ctx.inputFileName = inputFileName;
                ctx.outputFileName = outputFileName;
                ctx.testLog = mTestLog;
                ctx.md5Test = mTestMd5;
                char inputMd5FileName[MAX_FILE_PATH];
                if (ctx.md5Test) {
                    char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
                    snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
                        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
                        dedicatedSuffix, mGlobalCodecName[mTestCodec], inputMd5Suffix);
                    ctx.inputMd5FileName = inputMd5FileName;
                }
                do_sync_decoding(&ctx);
                waitpid(child[0], &status[0], 0);
                printf( "%s Child process %d exited with status %d.\n",
                    TAG, 0, status[0]);
                waitpid(child[1], &status[1], 0);
                printf( "%s Child process %d exited with status %d.\n",
                    TAG, 1, status[1]);
                waitpid(child[2], &status[2], 0);
                printf( "%s Child process %d exited with status %d.\n",
                    TAG, 2, status[2]);
                if (context != NULL) {
                    free(context);
                }
            }
        }
    }
}

TEST_F(MediaCodecTest, test_encoding_case_async_pf) {
    pthread_t thread_id[MAX_VPU_INSTANCE];
    void* retVal[MAX_VPU_INSTANCE];
    media_codec_context_t *context[MAX_VPU_INSTANCE];
    for (int i = 0; i < MAX_VPU_INSTANCE; i++) {
        context[i] = (media_codec_context_t *)malloc(sizeof(media_codec_context_t));
        ASSERT_NE(context[i], nullptr);
    }
    MediaCodecTestContext ctx[MAX_VPU_INSTANCE];
    mc_video_codec_enc_params_t *params;
    hb_s32 i = 0;
    char outputFileName[MAX_VPU_INSTANCE][MAX_FILE_PATH];
    char inputFileName[MAX_VPU_INSTANCE][MAX_FILE_PATH];
    char inputMd5FileName[MAX_VPU_INSTANCE][MAX_FILE_PATH];
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "asyncPF";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);

    for (i = 0; i < mTestThreadNum; i++) {
        snprintf(inputFileName[i], MAX_FILE_PATH, "%s%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
        snprintf(outputFileName[i], MAX_FILE_PATH, "%s%s_%s_%d_%s%s",
            dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
            i, outputSuffix, mGlobalCodecName[mTestCodec]);
        memset(context[i], 0x00, sizeof(media_codec_context_t));
    
        context[i]->codec_id = get_codec_id(mTestCodec);
        context[i]->encoder = TRUE;
        params = &context[i]->video_enc_params;
        params->width = mTestWidth;
        params->height = mTestHeight;
        params->pix_fmt = mTestPixFmt;
        params->frame_buf_count = 5;
        params->external_frame_buf = mTestBufMode;
        params->bitstream_buf_count = 5;
        if (context[i]->codec_id == MEDIA_CODEC_ID_H264) {
            params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
        } else {
            params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
        }
        ASSERT_EQ(get_rc_params(context[i], &params->rc_params),
            (int32_t)0);
        params->gop_params.decoding_refresh_type = 2;
        params->gop_params.gop_preset_idx = 2;
        params->rot_degree = MC_CCW_0;
        params->mir_direction = MC_DIRECTION_NONE;
        params->frame_cropping_flag = FALSE;

        memset(&ctx[i], 0x00, sizeof(ctx[i]));
        ctx[i].context = context[i];
        ctx[i].inputFileName = inputFileName[i];
        ctx[i].outputFileName = outputFileName[i];
        ctx[i].testLog = mTestLog;
        ctx[i].duration = mTestTime;
        ctx[i].pfTest = mTestPF;
        ctx[i].md5Test = 0;
        if (context[i]->codec_id == MEDIA_CODEC_ID_H264) {
            ctx[i].targetFps = params->rc_params.h264_cbr_params.frame_rate;
        } else {
            ctx[i].targetFps = params->rc_params.h265_cbr_params.frame_rate;
        }
        if (ctx[i].md5Test) {
            char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
            snprintf(inputMd5FileName[i], MAX_FILE_PATH, "%s%s_%s_%d_%s%s",
                dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
                dedicatedSuffix, i, mGlobalCodecName[mTestCodec], inputMd5Suffix);
            ctx[i].inputMd5FileName = inputMd5FileName[i];
        }
        pthread_create(&thread_id[i], NULL, (void* (*)(void*))do_async_encoding, &ctx[i]);
    }

    for (i = 0; i < mTestThreadNum; i++) {
        pthread_join(thread_id[i], &retVal[i]);
        printf("%s thread %d return = %ld\n", TAG, i, (intptr_t)retVal[i]);
    }
    for (i = 0; i < MAX_VPU_INSTANCE; i++) {
        if (context[i] != NULL) {
            free(context[i]);
        }
    }
}

TEST_F(MediaCodecTest, test_encoding_case_poll_multi_thread) {
    pthread_t thread_id[MAX_VPU_INSTANCE];
    void* retVal[MAX_VPU_INSTANCE];
    media_codec_context_t *context[MAX_VPU_INSTANCE];
    for (int i = 0; i < MAX_VPU_INSTANCE; i++) {
        context[i] = (media_codec_context_t *)malloc(sizeof(media_codec_context_t));
        ASSERT_NE(context[i], nullptr);
    }
    MediaCodecTestContext ctx[MAX_VPU_INSTANCE];
    mc_video_codec_enc_params_t *params;
    hb_s32 i = 0;
    char outputFileName[MAX_VPU_INSTANCE][MAX_FILE_PATH];
    char inputFileName[MAX_VPU_INSTANCE][MAX_FILE_PATH];
    char inputMd5FileName[MAX_VPU_INSTANCE][MAX_FILE_PATH];
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "pollMulti";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);

    for (i = 0; i < mTestThreadNum; i++) {
        snprintf(inputFileName[i], MAX_FILE_PATH, "%s%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
        snprintf(outputFileName[i], MAX_FILE_PATH, "%s%s_%s_%d_%s%s",
            dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
            i, outputSuffix, mGlobalCodecName[mTestCodec]);
        memset(context[i], 0x00, sizeof(media_codec_context_t));

        context[i]->codec_id = get_codec_id(mTestCodec);
        context[i]->encoder = TRUE;
        params = &context[i]->video_enc_params;
        params->width = mTestWidth;
        params->height = mTestHeight;
        params->pix_fmt = mTestPixFmt;
        params->frame_buf_count = 5;
        params->external_frame_buf = mTestBufMode;
        params->bitstream_buf_count = 5;
        if (context[i]->codec_id == MEDIA_CODEC_ID_H264) {
            params->rc_params.mode = MC_AV_RC_MODE_H264CBR;
        } else {
            params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
        }
        ASSERT_EQ(get_rc_params(context[i], &params->rc_params),
            (int32_t)0);
        params->gop_params.decoding_refresh_type = 2;
        params->gop_params.gop_preset_idx = 2;
        params->rot_degree = MC_CCW_0;
        params->mir_direction = MC_DIRECTION_NONE;
        params->frame_cropping_flag = FALSE;

        memset(&ctx[i], 0x00, sizeof(ctx[i]));
        ctx[i].context = context[i];
        ctx[i].inputFileName = inputFileName[i];
        ctx[i].outputFileName = outputFileName[i];
        ctx[i].testLog = mTestLog;
        ctx[i].duration = mTestTime;
        ctx[i].pfTest = mTestPF;
        ctx[i].md5Test = 0;
        if (context[i]->codec_id == MEDIA_CODEC_ID_H264) {
            ctx[i].targetFps = params->rc_params.h264_cbr_params.frame_rate;
        } else {
            ctx[i].targetFps = params->rc_params.h265_cbr_params.frame_rate;
        }
        if (ctx[i].md5Test) {
            char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
            snprintf(inputMd5FileName[i], MAX_FILE_PATH, "%s%s_%s_%d_%s%s",
                dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
                dedicatedSuffix, i, mGlobalCodecName[mTestCodec], inputMd5Suffix);
            ctx[i].inputMd5FileName = inputMd5FileName[i];
        }
        pthread_create(&thread_id[i], NULL, (void* (*)(void*))do_poll_encoding, &ctx[i]);
    }

    for (i = 0; i < mTestThreadNum; i++) {
        pthread_join(thread_id[i], &retVal[i]);
        printf("%s thread %d return = %ld\n", TAG, i, (intptr_t)retVal[i]);
    }
    for (i = 0; i < MAX_VPU_INSTANCE; i++) {
        if (context[i] != NULL) {
            free(context[i]);
        }
    }
}

TEST_F(MediaCodecTest, test_decoding_case_async_pf) {
    pthread_t thread_id[MAX_VPU_INSTANCE];
    void* retVal[MAX_VPU_INSTANCE];
    media_codec_context_t *context[MAX_VPU_INSTANCE];
    for (int i = 0; i < MAX_VPU_INSTANCE; i++) {
        context[i] = (media_codec_context_t *)malloc(sizeof(media_codec_context_t));
        ASSERT_NE(context[i], nullptr);
    }
    MediaCodecTestContext ctx[MAX_VPU_INSTANCE];
    mc_video_codec_dec_params_t *params;
    hb_s32 i = 0;
    char outputFileName[MAX_VPU_INSTANCE][MAX_FILE_PATH];
    char inputFileName[MAX_VPU_INSTANCE][MAX_FILE_PATH];
    char inputMd5FileName[MAX_VPU_INSTANCE][MAX_FILE_PATH];
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "asyncPF";
    char inputSuffix[MAX_FILE_PATH] = "normal.";
    char outputSuffix[MAX_FILE_PATH] = ".yuv";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);

    for (i = 0; i < mTestThreadNum; i++) {
        snprintf(inputFileName[i], MAX_FILE_PATH, "%s%s%s",
            dedicatedInputPrefix, inputSuffix, mGlobalCodecName[mTestCodec]);
        snprintf(outputFileName[i], MAX_FILE_PATH, "%s%s_%s_%d_%s%s",
            dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
            i, mGlobalCodecName[mTestCodec], outputSuffix);
        memset(context[i], 0x00, sizeof(media_codec_context_t));
        context[i]->codec_id = get_codec_id(mTestCodec);
        context[i]->encoder = FALSE;

        params = &context[i]->video_dec_params;
        params->feed_mode = mTestFeedMode;
        params->pix_fmt = mTestPixFmt;
        params->bitstream_buf_size = ((mTestWidth * mTestHeight * 3 / 2) + 0x3FF) & (~0x3FF);
        params->bitstream_buf_count = 6;
        params->frame_buf_count = 6;
        params->external_bitstream_buf = mTestBufMode;
        if (context[i]->codec_id == MEDIA_CODEC_ID_H264) {
            params->h264_dec_config.bandwidth_Opt = TRUE;
            params->h264_dec_config.reorder_enable = TRUE;
            params->h264_dec_config.skip_mode = 0;
        } else {
            params->h265_dec_config.bandwidth_Opt = TRUE;
            params->h265_dec_config.reorder_enable = TRUE;
            params->h265_dec_config.skip_mode = 0;
            params->h265_dec_config.cra_as_bla = 0;
            params->h265_dec_config.dec_temporal_id_mode = 0;
            params->h265_dec_config.target_dec_temporal_id_plus1 = 0;
        }

        memset(&ctx[i], 0x00, sizeof(ctx[i]));
        ctx[i].context = context[i];
        ctx[i].inputFileName = inputFileName[i];
        ctx[i].outputFileName = outputFileName[i];
        ctx[i].testLog = mTestLog;
        ctx[i].pfTest = mTestPF;
        ctx[i].duration = mTestTime;
        ctx[i].md5Test = 0;
        if (ctx[i].md5Test) {
            char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
            snprintf(inputMd5FileName[i], MAX_FILE_PATH, "%s%s_%s_%d_%s%s",
                dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
                dedicatedSuffix, i, mGlobalCodecName[mTestCodec], inputMd5Suffix);
            ctx[i].inputMd5FileName = inputMd5FileName[i];
        }

        pthread_create(&thread_id[i], NULL, (void* (*)(void*))do_async_decoding, &ctx[i]);
    }


    for (i = 0; i < mTestThreadNum; i++) {
        pthread_join(thread_id[i], &retVal[i]);
        printf("%s thread %d return = %ld\n", TAG, i, (intptr_t)retVal[i]);
    }
    for (i = 0; i < MAX_VPU_INSTANCE; i++) {
        if (context[i] != NULL) {
            free(context[i]);
        }
    }
}

TEST_F(MediaCodecTest, test_decoding_case_poll_multi_thread) {
    pthread_t thread_id[MAX_VPU_INSTANCE];
    void* retVal[MAX_VPU_INSTANCE];
    media_codec_context_t *context[MAX_VPU_INSTANCE];
    for (int i = 0; i < MAX_VPU_INSTANCE; i++) {
        context[i] = (media_codec_context_t *)malloc(sizeof(media_codec_context_t));
        ASSERT_NE(context[i], nullptr);
    }
    MediaCodecTestContext ctx[MAX_VPU_INSTANCE];
    mc_video_codec_dec_params_t *params;
    hb_s32 i = 0;
    char outputFileName[MAX_VPU_INSTANCE][MAX_FILE_PATH];
    char inputFileName[MAX_VPU_INSTANCE][MAX_FILE_PATH];
    char inputMd5FileName[MAX_VPU_INSTANCE][MAX_FILE_PATH];
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "pollMulti";
    char inputSuffix[MAX_FILE_PATH] = "normal.";
    char outputSuffix[MAX_FILE_PATH] = ".yuv";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);

    for (i = 0; i < mTestThreadNum; i++) {
        snprintf(inputFileName[i], MAX_FILE_PATH, "%s%s%s",
            dedicatedInputPrefix, inputSuffix, mGlobalCodecName[mTestCodec]);
        snprintf(outputFileName[i], MAX_FILE_PATH, "%s%s_%s_%d_%s%s",
            dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
            i, mGlobalCodecName[mTestCodec], outputSuffix);
        memset(context[i], 0x00, sizeof(media_codec_context_t));
        context[i]->codec_id = get_codec_id(mTestCodec);
        context[i]->encoder = FALSE;

        params = &context[i]->video_dec_params;
        params->feed_mode = mTestFeedMode;
        params->pix_fmt = mTestPixFmt;
        params->bitstream_buf_size = ((mTestWidth * mTestHeight * 3 / 2) + 0x3FF) & (~0x3FF);
        params->bitstream_buf_count = 6;
        params->frame_buf_count = 6;
        params->external_bitstream_buf = mTestBufMode;
        if (context[i]->codec_id == MEDIA_CODEC_ID_H264) {
            params->h264_dec_config.bandwidth_Opt = TRUE;
            params->h264_dec_config.reorder_enable = TRUE;
            params->h264_dec_config.skip_mode = 0;
        } else {
            params->h265_dec_config.bandwidth_Opt = TRUE;
            params->h265_dec_config.reorder_enable = TRUE;
            params->h265_dec_config.skip_mode = 0;
            params->h265_dec_config.cra_as_bla = 0;
            params->h265_dec_config.dec_temporal_id_mode = 0;
            params->h265_dec_config.target_dec_temporal_id_plus1 = 0;
        }

        memset(&ctx[i], 0x00, sizeof(ctx[i]));
        ctx[i].context = context[i];
        ctx[i].inputFileName = inputFileName[i];
        ctx[i].outputFileName = outputFileName[i];
        ctx[i].testLog = mTestLog;
        ctx[i].pfTest = mTestPF;
        ctx[i].duration = mTestTime;
        ctx[i].md5Test = 0;
        if (ctx[i].md5Test) {
            char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
            snprintf(inputMd5FileName[i], MAX_FILE_PATH, "%s%s_%s_%d_%s%s",
                dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
                dedicatedSuffix, i, mGlobalCodecName[mTestCodec], inputMd5Suffix);
            ctx[i].inputMd5FileName = inputMd5FileName[i];
        }

        pthread_create(&thread_id[i], NULL, (void* (*)(void*))do_poll_decoding, &ctx[i]);
    }


    for (i = 0; i < mTestThreadNum; i++) {
        pthread_join(thread_id[i], &retVal[i]);
        printf("%s thread %d return = %ld\n", TAG, i, (intptr_t)retVal[i]);
    }
    for (i = 0; i < MAX_VPU_INSTANCE; i++) {
        if (context[i] != NULL) {
            free(context[i]);
        }
    }
}

TEST_F(MediaCodecTest, test_stability_single_encoding_case) {
    pthread_t thread_id[MAX_VPU_INSTANCE];
    void* retVal[MAX_VPU_INSTANCE];
    void* (*funcModel)(void*)  = NULL;
    media_codec_context_t *context[MAX_VPU_INSTANCE];
    for (int i = 0; i < MAX_VPU_INSTANCE; i++) {
        context[i] = (media_codec_context_t *)malloc(sizeof(media_codec_context_t));
        ASSERT_NE(context[i], nullptr);
    }
    MediaCodecTestContext ctx[MAX_VPU_INSTANCE];
    mc_video_codec_enc_params_t *params;
    hb_s32 i = 0;
    char outputFileName[MAX_VPU_INSTANCE][MAX_FILE_PATH];
    char inputFileName[MAX_VPU_INSTANCE][MAX_FILE_PATH];
    char inputMd5FileName[MAX_VPU_INSTANCE][MAX_FILE_PATH];
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "stabilitySingle";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);

    mTestThreadNum = 1;
    for (i = 0; i < mTestThreadNum; i++) {
        mTestCodec = i < 1 ? TEST_CODEC_ID_H265 : TEST_CODEC_ID_H264;
        snprintf(inputFileName[i], MAX_FILE_PATH, "%s%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
        snprintf(outputFileName[i], MAX_FILE_PATH, "%s%s_%s_%d_%s%s",
            dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
            i, outputSuffix, mGlobalCodecName[mTestCodec]);
        memset(context[i], 0x00, sizeof(media_codec_context_t));

        context[i]->codec_id = get_codec_id(mTestCodec);
        context[i]->encoder = TRUE;
        params = &context[i]->video_enc_params;
        params->width = mTestWidth;
        params->height = mTestHeight;
        params->pix_fmt = mTestPixFmt;
        params->frame_buf_count = 5;
        params->external_frame_buf = mTestBufMode;
        params->bitstream_buf_count = 5;
        params->rc_params.mode = (mc_video_rate_control_mode_t)mTestRCMode;
        ASSERT_EQ(get_rc_params(context[i], &params->rc_params),
            (int32_t)0);
        params->gop_params.decoding_refresh_type = 2;
        params->gop_params.gop_preset_idx = mTestGopIdx;
        params->rot_degree = MC_CCW_0;
        params->mir_direction = MC_DIRECTION_NONE;
        params->frame_cropping_flag = FALSE;

        memset(&ctx[i], 0x00, sizeof(ctx[i]));
        ctx[i].context = context[i];
        ctx[i].inputFileName = inputFileName[i];
        ctx[i].outputFileName = outputFileName[i];
        ctx[i].testLog = mTestLog;
        ctx[i].duration = mTestTime;
        ctx[i].stabilityTest = 1;
        ctx[i].pfTest = mTestPF;
        ctx[i].md5Test = 0;
        if (ctx[i].md5Test) {
            char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
            snprintf(inputMd5FileName[i], MAX_FILE_PATH, "%s%s_%s_%d_%s%s",
                dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
                dedicatedSuffix, i, mGlobalCodecName[mTestCodec], inputMd5Suffix);
            ctx[i].inputMd5FileName = inputMd5FileName[i];
        }
        if (mTestWorkMode == THREAD_WORK_MODE_POLL) {
            funcModel = (void* (*)(void*))do_poll_encoding;
        } else if (mTestWorkMode == THREAD_WORK_MODE_ASYNC) {
            funcModel = (void* (*)(void*))do_async_encoding;
        } else if (mTestWorkMode == THREAD_WORK_MODE_SYNC) {
            funcModel = (void* (*)(void*))do_sync_encoding;
        }
        pthread_create(&thread_id[i], NULL, funcModel, &ctx[i]);
    }

    for (i = 0; i < mTestThreadNum; i++) {
        pthread_join(thread_id[i], &retVal[i]);
        printf("%s thread %d return = %ld\n", TAG, i, (intptr_t)retVal[i]);
    }
    for (i = 0; i < MAX_VPU_INSTANCE; i++) {
        if (context[i] != NULL) {
            free(context[i]);
        }
    }
}

TEST_F(MediaCodecTest, test_stability_multi_encoding_case) {
    pthread_t thread_id[MAX_VPU_INSTANCE];
    void* retVal[MAX_VPU_INSTANCE];
    void* (*funcModel)(void*)  = NULL;
    media_codec_context_t *context[MAX_VPU_INSTANCE];
    for (int i = 0; i < MAX_VPU_INSTANCE; i++) {
        context[i] = (media_codec_context_t *)malloc(sizeof(media_codec_context_t));
        ASSERT_NE(context[i], nullptr);
    }
    MediaCodecTestContext ctx[MAX_VPU_INSTANCE];
    mc_video_codec_enc_params_t *params;
    hb_s32 i = 0;
    char outputFileName[MAX_VPU_INSTANCE][MAX_FILE_PATH];
    char inputFileName[MAX_VPU_INSTANCE][MAX_FILE_PATH];
    char inputMd5FileName[MAX_VPU_INSTANCE][MAX_FILE_PATH];
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "stabilityMulti";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);

    for (i = 0; i < mTestThreadNum; i++) {
        snprintf(inputFileName[i], MAX_FILE_PATH, "%s%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
        snprintf(outputFileName[i], MAX_FILE_PATH, "%s%s_%s_%d%s%s",
            dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
            i, outputSuffix, mGlobalCodecName[mTestCodec]);
        memset(context[i], 0x00, sizeof(media_codec_context_t));

        context[i]->codec_id = get_codec_id(mTestCodec);
        context[i]->encoder = TRUE;
        params = &context[i]->video_enc_params;
        params->width = mTestWidth;
        params->height = mTestHeight;
        params->pix_fmt = mTestPixFmt;
        params->frame_buf_count = 5;
        params->external_frame_buf = mTestBufMode;
        params->bitstream_buf_count = 5;
        params->rc_params.mode = (mc_video_rate_control_mode_t)mTestRCMode;
        ASSERT_EQ(get_rc_params(context[i], &params->rc_params),
            (int32_t)0);
        params->gop_params.decoding_refresh_type = 2;
        params->gop_params.gop_preset_idx = mTestGopIdx;
        params->rot_degree = MC_CCW_0;
        params->mir_direction = MC_DIRECTION_NONE;
        params->frame_cropping_flag = FALSE;
        switch (params->rc_params.mode) {
        case MC_AV_RC_MODE_H265CBR:
            params->rc_params.h265_cbr_params.frame_rate = mTestFrameRate ? mTestFrameRate : 30;
            break;
        case MC_AV_RC_MODE_H265VBR:
            params->rc_params.h265_vbr_params.frame_rate = mTestFrameRate ? mTestFrameRate : 30;
            break;
        case MC_AV_RC_MODE_H265AVBR:
            params->rc_params.h265_avbr_params.frame_rate = mTestFrameRate ? mTestFrameRate : 30;
            break;
        case MC_AV_RC_MODE_H265FIXQP:
            params->rc_params.h265_fixqp_params.frame_rate = mTestFrameRate ? mTestFrameRate : 30;
            break;
        case MC_AV_RC_MODE_H265QPMAP:
            params->rc_params.h265_qpmap_params.frame_rate = mTestFrameRate ? mTestFrameRate : 30;
            break;
        default:
            break;
        }

        memset(&ctx[i], 0x00, sizeof(ctx[i]));
        ctx[i].context = context[i];
        ctx[i].inputFileName = inputFileName[i];
        ctx[i].outputFileName = outputFileName[i];
        ctx[i].testLog = mTestLog;
        ctx[i].duration = mTestTime;
        ctx[i].stabilityTest = 1;
        ctx[i].pfTest = mTestPF;
        ctx[i].md5Test = 0;
        ctx[i].delaytest = mTestDelay;
        ctx[i].delaytime = mTestDelayTime;
        ctx[i].workMode = mTestWorkMode;
        ctx[i].frametime = mTestFrameRate ? (1000000/mTestFrameRate) : 0; //us
        ctx[i].readonce = mTestReadOnce;
        if (ctx[i].md5Test) {
            char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
            snprintf(inputMd5FileName[i], MAX_FILE_PATH, "%s%s_%s_%d_%s%s",
                dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
                dedicatedSuffix, i, mGlobalCodecName[mTestCodec], inputMd5Suffix);
            ctx[i].inputMd5FileName = inputMd5FileName[i];
        }
        if (mTestWorkMode == THREAD_WORK_MODE_POLL) {
            funcModel = (void* (*)(void*))do_poll_encoding;
        } else if (mTestWorkMode == THREAD_WORK_MODE_ASYNC) {
            funcModel = (void* (*)(void*))do_async_encoding;
        } else if (mTestWorkMode == THREAD_WORK_MODE_SYNC) {
            funcModel = (void* (*)(void*))do_sync_encoding;
        }
        pthread_create(&thread_id[i], NULL, funcModel, &ctx[i]);
    }

    for (i = 0; i < mTestThreadNum; i++) {
        pthread_join(thread_id[i], &retVal[i]);
        printf("%s thread %d return = %ld\n", TAG, i, (intptr_t)retVal[i]);
    }
    for (i = 0; i < MAX_VPU_INSTANCE; i++) {
        if (context[i] != NULL) {
            free(context[i]);
        }
    }
}

TEST_F(MediaCodecTest, test_stability_multi_encoding_case_gopI) {
    pthread_t thread_id[MAX_VPU_INSTANCE];
    void* retVal[MAX_VPU_INSTANCE];
    void* (*funcModel)(void*)  = NULL;
    media_codec_context_t *context[MAX_VPU_INSTANCE];
    for (int i = 0; i < MAX_VPU_INSTANCE; i++) {
        context[i] = (media_codec_context_t *)malloc(sizeof(media_codec_context_t));
        ASSERT_NE(context[i], nullptr);
    }
    MediaCodecTestContext ctx[MAX_VPU_INSTANCE];
    mc_video_codec_enc_params_t *params;
    hb_s32 i = 0;
    char outputFileName[MAX_VPU_INSTANCE][MAX_FILE_PATH];
    char inputFileName[MAX_VPU_INSTANCE][MAX_FILE_PATH];
    char inputMd5FileName[MAX_VPU_INSTANCE][MAX_FILE_PATH];
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "stabilityMulti";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);

    for (i = 0; i < mTestThreadNum; i++) {
        snprintf(inputFileName[i], MAX_FILE_PATH, "%s%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
        snprintf(outputFileName[i], MAX_FILE_PATH, "%s%s_%s_%d%s%s",
            dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
            i, outputSuffix, mGlobalCodecName[mTestCodec]);
        memset(context[i], 0x00, sizeof(media_codec_context_t));

        context[i]->codec_id = get_codec_id(mTestCodec);
        context[i]->encoder = TRUE;
        params = &context[i]->video_enc_params;
        params->width = mTestWidth;
        params->height = mTestHeight;
        params->pix_fmt = mTestPixFmt;
        params->frame_buf_count = 5;
        params->external_frame_buf = mTestBufMode;
        params->bitstream_buf_count = 5;
        params->rc_params.mode = (mc_video_rate_control_mode_t)mTestRCMode;
        ASSERT_EQ(get_rc_params(context[i], &params->rc_params),
            (int32_t)0);
		params->rc_params.h265_cbr_params.bit_rate = 50000;
        params->gop_params.decoding_refresh_type = 2;
        params->gop_params.gop_preset_idx = 1;
        params->rot_degree = MC_CCW_0;
        params->mir_direction = MC_DIRECTION_NONE;
        params->frame_cropping_flag = FALSE;

        memset(&ctx[i], 0x00, sizeof(ctx[i]));
        ctx[i].context = context[i];
        ctx[i].inputFileName = inputFileName[i];
        ctx[i].outputFileName = outputFileName[i];
        ctx[i].testLog = mTestLog;
        ctx[i].duration = mTestTime;
        ctx[i].stabilityTest = 1;
        ctx[i].pfTest = mTestPF;
        ctx[i].md5Test = 0;
        ctx[i].delaytest = mTestDelay;
        ctx[i].delaytime = mTestDelayTime;
        ctx[i].workMode = mTestWorkMode;
        if (ctx[i].md5Test) {
            char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
            snprintf(inputMd5FileName[i], MAX_FILE_PATH, "%s%s_%s_%d_%s%s",
                dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
                dedicatedSuffix, i, mGlobalCodecName[mTestCodec], inputMd5Suffix);
            ctx[i].inputMd5FileName = inputMd5FileName[i];
        }
        if (mTestWorkMode == THREAD_WORK_MODE_POLL) {
            funcModel = (void* (*)(void*))do_poll_encoding;
        } else if (mTestWorkMode == THREAD_WORK_MODE_ASYNC) {
            funcModel = (void* (*)(void*))do_async_encoding;
        } else if (mTestWorkMode == THREAD_WORK_MODE_SYNC) {
            funcModel = (void* (*)(void*))do_sync_encoding;
        }
        pthread_create(&thread_id[i], NULL, funcModel, &ctx[i]);
    }

    for (i = 0; i < mTestThreadNum; i++) {
        pthread_join(thread_id[i], &retVal[i]);
        printf("%s thread %d return = %ld\n", TAG, i, (intptr_t)retVal[i]);
    }
    for (i = 0; i < MAX_VPU_INSTANCE; i++) {
        if (context[i] != NULL) {
            free(context[i]);
        }
    }
}

TEST_F(MediaCodecTest, test_stability_single_decoding_case) {
    pthread_t thread_id[MAX_VPU_INSTANCE];
    void* retVal[MAX_VPU_INSTANCE];
    void* (*funcModel)(void*)  = NULL;
    media_codec_context_t *context[MAX_VPU_INSTANCE];
    for (int i = 0; i < MAX_VPU_INSTANCE; i++) {
        context[i] = (media_codec_context_t *)malloc(sizeof(media_codec_context_t));
        ASSERT_NE(context[i], nullptr);
    }
    MediaCodecTestContext ctx[MAX_VPU_INSTANCE];
    mc_video_codec_dec_params_t *params;
    hb_s32 i = 0;
    char outputFileName[MAX_VPU_INSTANCE][MAX_FILE_PATH];
    char inputFileName[MAX_VPU_INSTANCE][MAX_FILE_PATH];
    char inputMd5FileName[MAX_VPU_INSTANCE][MAX_FILE_PATH];
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "stabilitySingle";
    char inputSuffix[MAX_FILE_PATH] = "normal.";
    char outputSuffix[MAX_FILE_PATH] = ".yuv";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);

    mTestThreadNum = 1;
    for (i = 0; i < mTestThreadNum; i++) {
        snprintf(inputFileName[i], MAX_FILE_PATH, "%s%s%s",
            dedicatedInputPrefix, inputSuffix, mGlobalCodecName[mTestCodec]);
        snprintf(outputFileName[i], MAX_FILE_PATH, "%s%s_%s_%d_%s%s",
            dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
            i, mGlobalCodecName[mTestCodec], outputSuffix);
        memset(context[i], 0x00, sizeof(media_codec_context_t));
        context[i]->codec_id = get_codec_id(mTestCodec);
        context[i]->encoder = FALSE;

        params = &context[i]->video_dec_params;
        params->feed_mode = mTestFeedMode;
        params->pix_fmt = mTestPixFmt;
        params->bitstream_buf_size = ((mTestWidth * mTestHeight * 3 / 2) + 0x3FF) & (~0x3FF);
        params->bitstream_buf_count = 6;
        params->frame_buf_count = 6;
        params->external_bitstream_buf = mTestBufMode;
        if (context[i]->codec_id == MEDIA_CODEC_ID_H264) {
            params->h264_dec_config.bandwidth_Opt = TRUE;
            params->h264_dec_config.reorder_enable = TRUE;
            params->h264_dec_config.skip_mode = 0;
        } else {
            params->h265_dec_config.bandwidth_Opt = TRUE;
            params->h265_dec_config.reorder_enable = TRUE;
            params->h265_dec_config.skip_mode = 0;
            params->h265_dec_config.cra_as_bla = 0;
            params->h265_dec_config.dec_temporal_id_mode = 0;
            params->h265_dec_config.target_dec_temporal_id_plus1 = 0;
        }

        memset(&ctx[i], 0x00, sizeof(ctx[i]));
        ctx[i].context = context[i];
        ctx[i].inputFileName = inputFileName[i];
        ctx[i].outputFileName = outputFileName[i];
        ctx[i].testLog = mTestLog;
        ctx[i].pfTest = mTestPF;
        ctx[i].duration = mTestTime;
        ctx[i].stabilityTest = 1;
        ctx[i].md5Test = 0;
        if (ctx[i].md5Test) {
            char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
            snprintf(inputMd5FileName[i], MAX_FILE_PATH, "%s%s_%s_%d_%s%s",
                dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
                dedicatedSuffix, i, mGlobalCodecName[mTestCodec], inputMd5Suffix);
            ctx[i].inputMd5FileName = inputMd5FileName[i];
        }
        if (mTestWorkMode == THREAD_WORK_MODE_POLL) {
            funcModel = (void* (*)(void*))do_poll_decoding;
        } else if (mTestWorkMode == THREAD_WORK_MODE_ASYNC) {
            funcModel = (void* (*)(void*))do_async_decoding;
        } else if (mTestWorkMode == THREAD_WORK_MODE_SYNC) {
            funcModel = (void* (*)(void*))do_sync_decoding;
        }
        pthread_create(&thread_id[i], NULL, funcModel, &ctx[i]);
    }


    for (i = 0; i < mTestThreadNum; i++) {
        pthread_join(thread_id[i], &retVal[i]);
        printf("%s thread %d return = %ld\n", TAG, i, (intptr_t)retVal[i]);
    }
    for (i = 0; i < MAX_VPU_INSTANCE; i++) {
        if (context[i] != NULL) {
            free(context[i]);
        }
    }
}

TEST_F(MediaCodecTest, test_stability_multi_decoding_case) {
    pthread_t thread_id[MAX_VPU_INSTANCE];
    void* retVal[MAX_VPU_INSTANCE];
    void* (*funcModel)(void*)  = NULL;
    media_codec_context_t *context[MAX_VPU_INSTANCE];
    for (int i = 0; i < MAX_VPU_INSTANCE; i++) {
        context[i] = (media_codec_context_t *)malloc(sizeof(media_codec_context_t));
        ASSERT_NE(context[i], nullptr);
    }
    MediaCodecTestContext ctx[MAX_VPU_INSTANCE];
    mc_video_codec_dec_params_t *params;
    hb_s32 i = 0;
    char outputFileName[MAX_VPU_INSTANCE][MAX_FILE_PATH];
    char inputFileName[MAX_VPU_INSTANCE][MAX_FILE_PATH];
    char inputMd5FileName[MAX_VPU_INSTANCE][MAX_FILE_PATH];
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "stabilityMulti";
    char inputSuffix[MAX_FILE_PATH] = "normal.";
    char outputSuffix[MAX_FILE_PATH] = ".yuv";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);

    for (i = 0; i < mTestThreadNum; i++) {
        snprintf(inputFileName[i], MAX_FILE_PATH, "%s%s%s",
            dedicatedInputPrefix, inputSuffix, mGlobalCodecName[mTestCodec]);
        snprintf(outputFileName[i], MAX_FILE_PATH, "%s%s_%s_%d_%s%s",
            dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
            i, mGlobalCodecName[mTestCodec], outputSuffix);
        memset(context[i], 0x00, sizeof(media_codec_context_t));
        context[i]->codec_id = get_codec_id(mTestCodec);
        context[i]->encoder = FALSE;

        params = &context[i]->video_dec_params;
        params->feed_mode = mTestFeedMode;
        params->pix_fmt = mTestPixFmt;
        params->bitstream_buf_size = ((mTestWidth * mTestHeight * 3 / 2) + 0x3FF) & (~0x3FF);
        params->bitstream_buf_count = 6;
        params->frame_buf_count = 6;
        params->external_bitstream_buf = mTestBufMode;
        if (context[i]->codec_id == MEDIA_CODEC_ID_H264) {
            params->h264_dec_config.bandwidth_Opt = TRUE;
            params->h264_dec_config.reorder_enable = TRUE;
            params->h264_dec_config.skip_mode = 0;
        } else {
            params->h265_dec_config.bandwidth_Opt = TRUE;
            params->h265_dec_config.reorder_enable = TRUE;
            params->h265_dec_config.skip_mode = 0;
            params->h265_dec_config.cra_as_bla = 0;
            params->h265_dec_config.dec_temporal_id_mode = 0;
            params->h265_dec_config.target_dec_temporal_id_plus1 = 0;
        }

        memset(&ctx[i], 0x00, sizeof(ctx[i]));
        ctx[i].context = context[i];
        ctx[i].inputFileName = inputFileName[i];
        ctx[i].outputFileName = outputFileName[i];
        ctx[i].testLog = mTestLog;
        ctx[i].pfTest = mTestPF;
        ctx[i].duration = mTestTime;
        ctx[i].stabilityTest = 1;
        ctx[i].md5Test = 0;
        ctx[i].delaytest = mTestDelay;
        ctx[i].delaytime = mTestDelayTime;
        ctx[i].workMode = mTestWorkMode;
        ctx[i].frametime = mTestFrameRate ? (1000000/mTestFrameRate) : 0; //us
        ctx[i].readonce = mTestReadOnce;
        if (ctx[i].md5Test) {
            char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
            snprintf(inputMd5FileName[i], MAX_FILE_PATH, "%s%s_%s_%d_%s%s",
                dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
                dedicatedSuffix, i, mGlobalCodecName[mTestCodec], inputMd5Suffix);
            ctx[i].inputMd5FileName = inputMd5FileName[i];
        }
        if (mTestWorkMode == THREAD_WORK_MODE_POLL) {
            funcModel = (void* (*)(void*))do_poll_decoding;
        } else if (mTestWorkMode == THREAD_WORK_MODE_ASYNC) {
            funcModel = (void* (*)(void*))do_async_decoding;
        } else if (mTestWorkMode == THREAD_WORK_MODE_SYNC) {
            funcModel = (void* (*)(void*))do_sync_decoding;
        }
        pthread_create(&thread_id[i], NULL, funcModel, &ctx[i]);
    }


    for (i = 0; i < mTestThreadNum; i++) {
        pthread_join(thread_id[i], &retVal[i]);
        printf("%s thread %d return = %ld\n", TAG, i, (intptr_t)retVal[i]);
    }
    for (i = 0; i < MAX_VPU_INSTANCE; i++) {
        if (context[i] != NULL) {
            free(context[i]);
        }
    }
}

TEST_F(MediaCodecTest, test_stability_single_encoding_case_with_parameter_setting) {
    pthread_t thread_id[MAX_VPU_INSTANCE];
    void* retVal[MAX_VPU_INSTANCE];
    media_codec_context_t *context[MAX_VPU_INSTANCE];
    for (int i = 0; i < MAX_VPU_INSTANCE; i++) {
        context[i] = (media_codec_context_t *)malloc(sizeof(media_codec_context_t));
        ASSERT_NE(context[i], nullptr);
    }
    MediaCodecTestContext ctx[MAX_VPU_INSTANCE];
    mc_video_codec_enc_params_t *params;
    hb_s32 i = 0;
    char outputFileName[MAX_VPU_INSTANCE][MAX_FILE_PATH];
    char inputFileName[MAX_VPU_INSTANCE][MAX_FILE_PATH];
    char inputMd5FileName[MAX_VPU_INSTANCE][MAX_FILE_PATH];
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "stabilitySingle_paramSet";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);

    for (i = 0; i < mTestThreadNum; i++) {
#ifndef J5
        mTestCodec = i < 1 ? TEST_CODEC_ID_H265 : TEST_CODEC_ID_H264;
#else
        mTestCodec = TEST_CODEC_ID_H265;
#endif
        snprintf(inputFileName[i], MAX_FILE_PATH, "%s%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
        snprintf(outputFileName[i], MAX_FILE_PATH, "%s%s_%s_%d_%s%s",
            dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
            i, outputSuffix, mGlobalCodecName[mTestCodec]);
        memset(context[i], 0x00, sizeof(media_codec_context_t));

        context[i]->codec_id = get_codec_id(mTestCodec);
        context[i]->encoder = TRUE;
        params = &context[i]->video_enc_params;
        params->width = mTestWidth;
        params->height = mTestHeight;
        params->pix_fmt = mTestPixFmt;
        params->frame_buf_count = 5;
        params->external_frame_buf = FALSE;
        params->bitstream_buf_count = 5;
        if (context[i]->codec_id == MEDIA_CODEC_ID_H264) {
            params->rc_params.mode = MC_AV_RC_MODE_H264AVBR;
        } else {
            params->rc_params.mode = MC_AV_RC_MODE_H265AVBR;
        }
        ASSERT_EQ(get_rc_params(context[i], &params->rc_params),
            (int32_t)0);
        params->gop_params.decoding_refresh_type = 2;
        params->gop_params.gop_preset_idx = 2;
        params->rot_degree = MC_CCW_0;
        params->mir_direction = MC_DIRECTION_NONE;
        params->frame_cropping_flag = FALSE;
        if (context[i]->codec_id == MEDIA_CODEC_ID_H264) {
            params->rc_params.h264_avbr_params.hvs_qp_enable = 0;
            params->rc_params.h264_avbr_params.qp_map_enable = 1;
        } else {
            params->rc_params.h265_cbr_params.hvs_qp_enable = 0;
            params->rc_params.h265_avbr_params.qp_map_enable = 1;
        }

        memset(&ctx[i], 0x00, sizeof(ctx[i]));
        ctx[i].context = context[i];
        ctx[i].inputFileName = inputFileName[i];
        ctx[i].outputFileName = outputFileName[i];
        ctx[i].testLog = mTestLog;
        ctx[i].duration = mTestTime;
        ctx[i].stabilityTest = 1;
        ctx[i].stabilityParaTest = 1;
        ctx[i].dynamicMessage = (ENC_CONFIG_MESSAGE)0xFFFF;
        ctx[i].pfTest = mTestPF;
        ctx[i].md5Test = 0;
        mc_video_longterm_ref_mode_t *ref_mode = &ctx[i].ref_mode;
        ref_mode->use_longterm = 1;
        ref_mode->longterm_pic_period = 8;
        ref_mode->longterm_pic_using_period = 4;

        mc_video_roi_params_ex_t *roiEx = &ctx[i].roiEx;
        roiEx->roi_mode = 1;
        roiEx->roi_idx = 0;
        roiEx->roi_enable = 1;
        roiEx->roi_val = 5;
        roiEx->roi_delta_qp = 2;
        roiEx->crop_rect.x_pos = 0;
        roiEx->crop_rect.y_pos = 0;
        roiEx->crop_rect.width = (((params->width + 0x3f)&~0x3f) >> 6) - 1;
        roiEx->crop_rect.height = (((params->height + 0x3f)&~0x3f) >> 6) - 1;

        ctx[i].message = (ENC_CONFIG_MESSAGE)(ENC_CONFIG_ROI_EX | ENC_CONFIG_LONGTERM_REF);
        if (context[i]->codec_id == MEDIA_CODEC_ID_H264) {
            ctx[i].targetFps = params->rc_params.h264_cbr_params.frame_rate;
        } else {
            ctx[i].targetFps = params->rc_params.h265_cbr_params.frame_rate;
        }
        if (ctx[i].md5Test) {
            char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
            snprintf(inputMd5FileName[i], MAX_FILE_PATH, "%s%s_%s_%d_%s%s",
                dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
                dedicatedSuffix, i, mGlobalCodecName[mTestCodec], inputMd5Suffix);
            ctx[i].inputMd5FileName = inputMd5FileName[i];
        }
        pthread_create(&thread_id[i], NULL, (void* (*)(void*))do_sync_encoding, &ctx[i]);
    }

    for (i = 0; i < mTestThreadNum; i++) {
        pthread_join(thread_id[i], &retVal[i]);
        printf("%s thread %d return = %ld\n", TAG, i, (intptr_t)retVal[i]);
    }
    for (i = 0; i < MAX_VPU_INSTANCE; i++) {
        if (context[i] != NULL) {
            free(context[i]);
        }
    }
}

TEST_F(MediaCodecTest, test_encoding_case_h265_use_cfg) {
    char outputFileName[MAX_FILE_PATH];
    char inputFileName[MAX_FILE_PATH];
    mTestWidth = 640;
    mTestHeight = 480;
    mTestPixFmt = MC_PIXEL_FORMAT_YUV420P;
    mTestCodec = TEST_CODEC_ID_H265;
    char dedicatedInputPrefix[MAX_FILE_PATH] = "";
    char dedicatedOutputPrefix[MAX_FILE_PATH] = "";
    char dedicatedSuffix[MAX_FILE_PATH] = "use_cfg";
    char inputSuffix[MAX_FILE_PATH] = ".yuv";
    char outputSuffix[MAX_FILE_PATH] = ".";
    snprintf(dedicatedInputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mInputPrefix, G_DEFAULT_VIDEO_INPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(inputFileName, MAX_FILE_PATH, "%s%s%s",
        dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt], inputSuffix);
    snprintf(dedicatedOutputPrefix, MAX_FILE_PATH, "%s%s%dx%d_",
        mOutputPrefix, G_DEFAULT_VIDEO_OUTPUT_SUFFIX, mTestWidth, mTestHeight);
    snprintf(outputFileName, MAX_FILE_PATH, "%s%s_%s%s%s",
        dedicatedOutputPrefix, mGlobalPixFmtName[mTestPixFmt], dedicatedSuffix,
        outputSuffix, mGlobalCodecName[mTestCodec]);
    mc_video_codec_enc_params_t *params;
    media_codec_context_t *context = (media_codec_context_t *)malloc(sizeof(media_codec_context_t ));
    ASSERT_NE(context, nullptr);
    memset(context, 0x00, sizeof(media_codec_context_t));
    context->codec_id = get_codec_id(mTestCodec);
    context->encoder = TRUE;
    params = &context->video_enc_params;
    params->width = mTestWidth;
    params->height = mTestHeight;
    params->pix_fmt = mTestPixFmt;
    params->frame_buf_count = 5;
    params->external_frame_buf = FALSE;
    params->bitstream_buf_count = 5;
    params->rc_params.mode = MC_AV_RC_MODE_H265CBR;
    ASSERT_EQ(get_rc_params(context, &params->rc_params),
        (int32_t)0);
    params->gop_params.decoding_refresh_type = 2;
    params->gop_params.gop_preset_idx = 2;
    params->rot_degree = MC_CCW_0;
    params->mir_direction = MC_DIRECTION_NONE;
    params->frame_cropping_flag = FALSE;

    MediaCodecTestContext ctx;
    memset(&ctx, 0x00, sizeof(ctx));
    ctx.context = context;
    ctx.inputFileName = inputFileName;
    ctx.outputFileName = outputFileName;
    ctx.testLog = mTestLog;
    ctx.md5Test = mTestMd5;
    char inputMd5FileName[MAX_FILE_PATH];
    if (ctx.md5Test) {
        char inputMd5Suffix[MAX_FILE_PATH] = ".md5";
        snprintf(inputMd5FileName, MAX_FILE_PATH, "%s%s_%s_%s%s",
            dedicatedInputPrefix, mGlobalPixFmtName[mTestPixFmt],
            mGlobalCodecName[mTestCodec], dedicatedSuffix, inputMd5Suffix);
        ctx.inputMd5FileName = inputMd5FileName;
    }
    do_sync_encoding(&ctx);
    if (context != NULL) {
        free(context);
    }
}


/*TEST_F(MediaCodecTest, test_encoding_case_h265_async_pf1) {
    pid_t pid = getpid();
    struct sched_param param;
    param.sched_priority = sched_get_priority_max(SCHED_FIFO);
    sched_setscheduler(pid, SCHED_FIFO, &param);
    pthread_setschedparam(pthread_self(), SCHED_FIFO, &param);
    nice(-19);
}*/

}  // namespace test
}  // namespace mediaCodec
